import { B as Block } from './Button-05bf7cea.js';
import { u as uploadToHuggingFace, c as copy } from './utils-8f25e669.js';
import { d as dequal } from './index-21d69e4c.js';
import { S as ShareButton } from './ShareButton-b044e1b5.js';
import { S as Static } from './Index-2cec2c56.js';
import './Index.svelte_svelte_type_style_lang-09b631ef.js';
import { M as MarkdownCode } from './Example.svelte_svelte_type_style_lang-b83dcc5a.js';
import { g as get_fetchable_url_or_file, n as normalise_file } from './index-5550136d.js';
import { C as Check } from './Check-1d114215.js';
import { C as Copy } from './Copy-ea46e0bf.js';
import { B as BlockLabel } from './BlockLabel-09bb0248.js';
import './IconButton-fb69b8dd.js';
import './svelte/svelte.js';

/* home/runner/work/gradio/gradio/js/icons/src/Chat.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$7,
	append: append$5,
	attr: attr$7,
	detach: detach$7,
	init: init$7,
	insert: insert$7,
	noop: noop$4,
	safe_not_equal: safe_not_equal$7,
	svg_element: svg_element$2
} = window.__gradio__svelte__internal;
function create_fragment$7(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element$2("svg");
			path0 = svg_element$2("path");
			path1 = svg_element$2("path");
			attr$7(path0, "fill", "currentColor");
			attr$7(path0, "d", "M17.74 30L16 29l4-7h6a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h9v2H6a4 4 0 0 1-4-4V8a4 4 0 0 1 4-4h20a4 4 0 0 1 4 4v12a4 4 0 0 1-4 4h-4.84Z");
			attr$7(path1, "fill", "currentColor");
			attr$7(path1, "d", "M8 10h16v2H8zm0 6h10v2H8z");
			attr$7(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$7(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr$7(svg, "aria-hidden", "true");
			attr$7(svg, "role", "img");
			attr$7(svg, "class", "iconify iconify--carbon");
			attr$7(svg, "width", "100%");
			attr$7(svg, "height", "100%");
			attr$7(svg, "preserveAspectRatio", "xMidYMid meet");
			attr$7(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert$7(target, svg, anchor);
			append$5(svg, path0);
			append$5(svg, path1);
		},
		p: noop$4,
		i: noop$4,
		o: noop$4,
		d(detaching) {
			if (detaching) {
				detach$7(svg);
			}
		}
	};
}

class Chat extends SvelteComponent$7 {
	constructor(options) {
		super();
		init$7(this, options, null, create_fragment$7, safe_not_equal$7, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Dislike.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$6,
	append: append$4,
	attr: attr$6,
	detach: detach$6,
	init: init$6,
	insert: insert$6,
	noop: noop$3,
	safe_not_equal: safe_not_equal$6,
	svg_element: svg_element$1
} = window.__gradio__svelte__internal;
function create_fragment$6(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_fill_value;

	return {
		c() {
			svg = svg_element$1("svg");
			path0 = svg_element$1("path");
			path1 = svg_element$1("path");
			attr$6(path0, "stroke", "currentColor");
			attr$6(path0, "stroke-width", "1.5");
			attr$6(path0, "stroke-linecap", "round");
			attr$6(path0, "d", "M16.472 3.5H4.1a.6.6 0 0 0-.6.6v9.8a.6.6 0 0 0 .6.6h2.768a2 2 0 0 1 1.715.971l2.71 4.517a1.631 1.631 0 0 0 2.961-1.308l-1.022-3.408a.6.6 0 0 1 .574-.772h4.575a2 2 0 0 0 1.93-2.526l-1.91-7A2 2 0 0 0 16.473 3.5Z");
			attr$6(path1, "stroke", "currentColor");
			attr$6(path1, "stroke-width", "1.5");
			attr$6(path1, "stroke-linecap", "round");
			attr$6(path1, "stroke-linejoin", "round");
			attr$6(path1, "d", "M7 14.5v-11");
			attr$6(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$6(svg, "width", "15px");
			attr$6(svg, "height", "15px");
			attr$6(svg, "viewBox", "0 0 24 24");
			attr$6(svg, "fill", svg_fill_value = /*actioned*/ ctx[0] ? "currentColor" : "none");
			attr$6(svg, "stroke-width", "1.5");
			attr$6(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$6(target, svg, anchor);
			append$4(svg, path0);
			append$4(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*actioned*/ 1 && svg_fill_value !== (svg_fill_value = /*actioned*/ ctx[0] ? "currentColor" : "none")) {
				attr$6(svg, "fill", svg_fill_value);
			}
		},
		i: noop$3,
		o: noop$3,
		d(detaching) {
			if (detaching) {
				detach$6(svg);
			}
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { actioned } = $$props;

	$$self.$$set = $$props => {
		if ('actioned' in $$props) $$invalidate(0, actioned = $$props.actioned);
	};

	return [actioned];
}

class Dislike extends SvelteComponent$6 {
	constructor(options) {
		super();
		init$6(this, options, instance$6, create_fragment$6, safe_not_equal$6, { actioned: 0 });
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Like.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$5,
	append: append$3,
	attr: attr$5,
	detach: detach$5,
	init: init$5,
	insert: insert$5,
	noop: noop$2,
	safe_not_equal: safe_not_equal$5,
	svg_element
} = window.__gradio__svelte__internal;
function create_fragment$5(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_fill_value;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr$5(path0, "stroke", "currentColor");
			attr$5(path0, "stroke-width", "1.5");
			attr$5(path0, "stroke-linecap", "round");
			attr$5(path0, "d", "M16.472 20H4.1a.6.6 0 0 1-.6-.6V9.6a.6.6 0 0 1 .6-.6h2.768a2 2 0 0 0 1.715-.971l2.71-4.517a1.631 1.631 0 0 1 2.961 1.308l-1.022 3.408a.6.6 0 0 0 .574.772h4.575a2 2 0 0 1 1.93 2.526l-1.91 7A2 2 0 0 1 16.473 20Z");
			attr$5(path1, "stroke", "currentColor");
			attr$5(path1, "stroke-width", "1.5");
			attr$5(path1, "stroke-linecap", "round");
			attr$5(path1, "stroke-linejoin", "round");
			attr$5(path1, "d", "M7 20V9");
			attr$5(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$5(svg, "width", "15px");
			attr$5(svg, "height", "15px");
			attr$5(svg, "viewBox", "0 0 24 24");
			attr$5(svg, "fill", svg_fill_value = /*actioned*/ ctx[0] ? "currentColor" : "none");
			attr$5(svg, "stroke-width", "1.5");
			attr$5(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$5(target, svg, anchor);
			append$3(svg, path0);
			append$3(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*actioned*/ 1 && svg_fill_value !== (svg_fill_value = /*actioned*/ ctx[0] ? "currentColor" : "none")) {
				attr$5(svg, "fill", svg_fill_value);
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) {
				detach$5(svg);
			}
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { actioned } = $$props;

	$$self.$$set = $$props => {
		if ('actioned' in $$props) $$invalidate(0, actioned = $$props.actioned);
	};

	return [actioned];
}

class Like extends SvelteComponent$5 {
	constructor(options) {
		super();
		init$5(this, options, instance$5, create_fragment$5, safe_not_equal$5, { actioned: 0 });
	}
}

const format_chat_for_sharing = async (chat) => {
  let messages = await Promise.all(
    chat.map(async (message_pair) => {
      return await Promise.all(
        message_pair.map(async (message, i) => {
          if (message === null)
            return "";
          let speaker_emoji = i === 0 ? "ðŸ˜ƒ" : "ðŸ¤–";
          let html_content = "";
          if (typeof message === "string") {
            const regexPatterns = {
              audio: /<audio.*?src="(\/file=.*?)"/g,
              video: /<video.*?src="(\/file=.*?)"/g,
              image: /<img.*?src="(\/file=.*?)".*?\/>|!\[.*?\]\((\/file=.*?)\)/g
            };
            html_content = message;
            for (let [_, regex] of Object.entries(regexPatterns)) {
              let match;
              while ((match = regex.exec(message)) !== null) {
                const fileUrl = match[1] || match[2];
                const newUrl = await uploadToHuggingFace(fileUrl, "url");
                html_content = html_content.replace(fileUrl, newUrl);
              }
            }
          } else {
            if (!message?.url)
              return "";
            const file_url = await uploadToHuggingFace(message.url, "url");
            if (message.mime_type?.includes("audio")) {
              html_content = `<audio controls src="${file_url}"></audio>`;
            } else if (message.mime_type?.includes("video")) {
              html_content = file_url;
            } else if (message.mime_type?.includes("image")) {
              html_content = `<img src="${file_url}" />`;
            }
          }
          return `${speaker_emoji}: ${html_content}`;
        })
      );
    })
  );
  return messages.map(
    (message_pair) => message_pair.join(
      message_pair[0] !== "" && message_pair[1] !== "" ? "\n" : ""
    )
  ).join("\n");
};

const Copy_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/Copy.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$4,
	append: append$2,
	attr: attr$4,
	check_outros: check_outros$2,
	create_component: create_component$3,
	destroy_component: destroy_component$3,
	detach: detach$4,
	element: element$4,
	group_outros: group_outros$2,
	init: init$4,
	insert: insert$4,
	listen: listen$2,
	mount_component: mount_component$3,
	safe_not_equal: safe_not_equal$4,
	space: space$2,
	transition_in: transition_in$3,
	transition_out: transition_out$3
} = window.__gradio__svelte__internal;
const { onDestroy } = window.__gradio__svelte__internal;
function create_if_block_1$2(ctx) {
	let copy;
	let current;
	copy = new Copy({});

	return {
		c() {
			create_component$3(copy.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(copy, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$3(copy.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(copy.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(copy, detaching);
		}
	};
}

// (52:1) {#if copied}
function create_if_block$2(ctx) {
	let check;
	let current;
	check = new Check({});

	return {
		c() {
			create_component$3(check.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(check, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$3(check.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(check.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(check, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let button;
	let t;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = !/*copied*/ ctx[0] && create_if_block_1$2();
	let if_block1 = /*copied*/ ctx[0] && create_if_block$2();

	return {
		c() {
			button = element$4("button");
			if (if_block0) if_block0.c();
			t = space$2();
			if (if_block1) if_block1.c();
			attr$4(button, "title", "copy");
			attr$4(button, "aria-label", button_aria_label_value = /*copied*/ ctx[0] ? "Copied message" : "Copy message");
			attr$4(button, "class", "svelte-11hlfrc");
		},
		m(target, anchor) {
			insert$4(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append$2(button, t);
			if (if_block1) if_block1.m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen$2(button, "click", /*handle_copy*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!/*copied*/ ctx[0]) {
				if (if_block0) {
					if (dirty & /*copied*/ 1) {
						transition_in$3(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$2();
					if_block0.c();
					transition_in$3(if_block0, 1);
					if_block0.m(button, t);
				}
			} else if (if_block0) {
				group_outros$2();

				transition_out$3(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$2();
			}

			if (/*copied*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*copied*/ 1) {
						transition_in$3(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2();
					if_block1.c();
					transition_in$3(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros$2();

				transition_out$3(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$2();
			}

			if (!current || dirty & /*copied*/ 1 && button_aria_label_value !== (button_aria_label_value = /*copied*/ ctx[0] ? "Copied message" : "Copy message")) {
				attr$4(button, "aria-label", button_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$3(if_block0);
			transition_in$3(if_block1);
			current = true;
		},
		o(local) {
			transition_out$3(if_block0);
			transition_out$3(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$4(button);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let copied = false;
	let { value } = $$props;
	let timer;

	function copy_feedback() {
		$$invalidate(0, copied = true);
		if (timer) clearTimeout(timer);

		timer = setTimeout(
			() => {
				$$invalidate(0, copied = false);
			},
			2000
		);
	}

	async function handle_copy() {
		if ("clipboard" in navigator) {
			await navigator.clipboard.writeText(value);
			copy_feedback();
		} else {
			const textArea = document.createElement("textarea");
			textArea.value = value;
			textArea.style.position = "absolute";
			textArea.style.left = "-999999px";
			document.body.prepend(textArea);
			textArea.select();

			try {
				document.execCommand("copy");
				copy_feedback();
			} catch(error) {
				console.error(error);
			} finally {
				textArea.remove();
			}
		}
	}

	onDestroy(() => {
		if (timer) clearTimeout(timer);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
	};

	return [copied, handle_copy, value];
}

class Copy_1 extends SvelteComponent$4 {
	constructor(options) {
		super();
		init$4(this, options, instance$4, create_fragment$4, safe_not_equal$4, { value: 2 });
	}
}

const LikeDislike_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/LikeDislike.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$3,
	attr: attr$3,
	create_component: create_component$2,
	destroy_component: destroy_component$2,
	detach: detach$3,
	element: element$3,
	init: init$3,
	insert: insert$3,
	listen: listen$1,
	mount_component: mount_component$2,
	run_all: run_all$1,
	safe_not_equal: safe_not_equal$3,
	transition_in: transition_in$2,
	transition_out: transition_out$2
} = window.__gradio__svelte__internal;
function create_fragment$3(ctx) {
	let button;
	let icon;
	let button_title_value;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;
	icon = new /*Icon*/ ctx[3]({ props: { actioned: /*actioned*/ ctx[2] } });

	return {
		c() {
			button = element$3("button");
			create_component$2(icon.$$.fragment);
			attr$3(button, "title", button_title_value = /*action*/ ctx[0] + " message");

			attr$3(button, "aria-label", button_aria_label_value = /*actioned*/ ctx[2]
			? `clicked ${/*action*/ ctx[0]}`
			: /*action*/ ctx[0]);

			attr$3(button, "class", "svelte-3snf3m");
		},
		m(target, anchor) {
			insert$3(target, button, anchor);
			mount_component$2(icon, button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen$1(button, "click", /*click_handler*/ ctx[5]),
					listen$1(button, "keydown", /*keydown_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const icon_changes = {};
			if (dirty & /*actioned*/ 4) icon_changes.actioned = /*actioned*/ ctx[2];
			icon.$set(icon_changes);

			if (!current || dirty & /*action*/ 1 && button_title_value !== (button_title_value = /*action*/ ctx[0] + " message")) {
				attr$3(button, "title", button_title_value);
			}

			if (!current || dirty & /*actioned, action*/ 5 && button_aria_label_value !== (button_aria_label_value = /*actioned*/ ctx[2]
			? `clicked ${/*action*/ ctx[0]}`
			: /*action*/ ctx[0])) {
				attr$3(button, "aria-label", button_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$3(button);
			}

			destroy_component$2(icon);
			mounted = false;
			run_all$1(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { action } = $$props;
	let { handle_action } = $$props;
	let actioned = false;
	let Icon = action === "like" ? Like : Dislike;

	function action_feedback() {
		$$invalidate(2, actioned = true);
	}

	const click_handler = () => {
		action_feedback();
		handle_action();
	};

	const keydown_handler = e => {
		if (e.key === "Enter") {
			action_feedback();
			handle_action();
		}
	};

	$$self.$$set = $$props => {
		if ('action' in $$props) $$invalidate(0, action = $$props.action);
		if ('handle_action' in $$props) $$invalidate(1, handle_action = $$props.handle_action);
	};

	return [
		action,
		handle_action,
		actioned,
		Icon,
		action_feedback,
		click_handler,
		keydown_handler
	];
}

class LikeDislike extends SvelteComponent$3 {
	constructor(options) {
		super();
		init$3(this, options, instance$3, create_fragment$3, safe_not_equal$3, { action: 0, handle_action: 1 });
	}
}

const Pending_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/Pending.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$2,
	attr: attr$2,
	detach: detach$2,
	element: element$2,
	init: init$2,
	insert: insert$2,
	noop: noop$1,
	safe_not_equal: safe_not_equal$2,
	set_style: set_style$1
} = window.__gradio__svelte__internal;
function create_fragment$2(ctx) {
	let div3;

	return {
		c() {
			div3 = element$2("div");

			div3.innerHTML = `<span class="sr-only">Loading content</span> <div class="dot-flashing svelte-1gpwetz"></div>
	Â 
	<div class="dot-flashing svelte-1gpwetz"></div>
	Â 
	<div class="dot-flashing svelte-1gpwetz"></div>`;

			attr$2(div3, "class", "message pending svelte-1gpwetz");
			attr$2(div3, "role", "status");
			attr$2(div3, "aria-label", "Loading response");
			attr$2(div3, "aria-live", "polite");

			set_style$1(div3, "border-radius", /*layout*/ ctx[0] === "bubble"
			? "var(--radius-xxl)"
			: "none");
		},
		m(target, anchor) {
			insert$2(target, div3, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*layout*/ 1) {
				set_style$1(div3, "border-radius", /*layout*/ ctx[0] === "bubble"
				? "var(--radius-xxl)"
				: "none");
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach$2(div3);
			}
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { layout = "bubble" } = $$props;

	$$self.$$set = $$props => {
		if ('layout' in $$props) $$invalidate(0, layout = $$props.layout);
	};

	return [layout];
}

class Pending extends SvelteComponent$2 {
	constructor(options) {
		super();
		init$2(this, options, instance$2, create_fragment$2, safe_not_equal$2, { layout: 0 });
	}
}

const ChatBot_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/ChatBot.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$1,
	action_destroyer,
	append: append$1,
	attr: attr$1,
	binding_callbacks,
	bubble,
	check_outros: check_outros$1,
	create_component: create_component$1,
	destroy_component: destroy_component$1,
	destroy_each,
	detach: detach$1,
	element: element$1,
	empty,
	ensure_array_like,
	group_outros: group_outros$1,
	init: init$1,
	insert: insert$1,
	listen,
	mount_component: mount_component$1,
	noop,
	null_to_empty,
	run_all,
	safe_not_equal: safe_not_equal$1,
	set_data,
	set_style,
	space: space$1,
	src_url_equal,
	text,
	toggle_class,
	transition_in: transition_in$1,
	transition_out: transition_out$1
} = window.__gradio__svelte__internal;const { beforeUpdate, afterUpdate, createEventDispatcher } = window.__gradio__svelte__internal;
function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[37] = list[i];
	child_ctx[39] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i];
	child_ctx[42] = i;
	return child_ctx;
}

// (72:0) {#if show_share_button && value !== null && value.length > 0}
function create_if_block_12(ctx) {
	let div_1;
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[15],
				formatter: format_chat_for_sharing,
				value: /*value*/ ctx[0]
			}
		});

	sharebutton.$on("error", /*error_handler*/ ctx[28]);
	sharebutton.$on("share", /*share_handler*/ ctx[29]);

	return {
		c() {
			div_1 = element$1("div");
			create_component$1(sharebutton.$$.fragment);
			attr$1(div_1, "class", "share-button svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, div_1, anchor);
			mount_component$1(sharebutton, div_1, null);
			current = true;
		},
		p(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty[0] & /*i18n*/ 32768) sharebutton_changes.i18n = /*i18n*/ ctx[15];
			if (dirty[0] & /*value*/ 1) sharebutton_changes.value = /*value*/ ctx[0];
			sharebutton.$set(sharebutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(sharebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(sharebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div_1);
			}

			destroy_component$1(sharebutton);
		}
	};
}

// (92:2) {#if value !== null}
function create_if_block$1(ctx) {
	let t;
	let if_block_anchor;
	let current;
	let each_value = ensure_array_like(/*value*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out$1(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*pending_message*/ ctx[2] && create_if_block_1$1(ctx);

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space$1();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert$1(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert$1(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value, layout, avatar_images, bubble_full_width, show_copy_button, handle_like, likeable, render_markdown, rtl, selectable, handle_select, latex_delimiters, sanitize_html, line_breaks, scroll, root, proxy_url*/ 1933275) {
				each_value = ensure_array_like(/*value*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in$1(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in$1(each_blocks[i], 1);
						each_blocks[i].m(t.parentNode, t);
					}
				}

				group_outros$1();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros$1();
			}

			if (/*pending_message*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*pending_message*/ 4) {
						transition_in$1(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in$1(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros$1();

				transition_out$1(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in$1(each_blocks[i]);
			}

			transition_in$1(if_block);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out$1(each_blocks[i]);
			}

			transition_out$1(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(if_block_anchor);
			}

			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d(detaching);
		}
	};
}

// (95:5) {#if message !== null}
function create_if_block_2(ctx) {
	let div1;
	let t0;
	let div0;
	let button;
	let show_if;
	let show_if_1;
	let show_if_2;
	let current_block_type_index;
	let if_block1;
	let button_dir_value;
	let button_aria_label_value;
	let t1;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*avatar_images*/ ctx[8][/*j*/ ctx[42]] !== null && create_if_block_11(ctx);

	const if_block_creators = [
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*value*/ 1) show_if = null;
		if (dirty[0] & /*value*/ 1) show_if_1 = null;
		if (dirty[0] & /*value*/ 1) show_if_2 = null;
		if (typeof /*message*/ ctx[40] === "string") return 0;
		if (show_if == null) show_if = !!(/*message*/ ctx[40] !== null && /*message*/ ctx[40].file?.mime_type?.includes("audio"));
		if (show_if) return 1;
		if (show_if_1 == null) show_if_1 = !!(/*message*/ ctx[40] !== null && /*message*/ ctx[40].file?.mime_type?.includes("video"));
		if (show_if_1) return 2;
		if (show_if_2 == null) show_if_2 = !!(/*message*/ ctx[40] !== null && /*message*/ ctx[40].file?.mime_type?.includes("image"));
		if (show_if_2) return 3;
		if (/*message*/ ctx[40] !== null && /*message*/ ctx[40].file?.url !== null) return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	function click_handler() {
		return /*click_handler*/ ctx[30](/*i*/ ctx[39], /*j*/ ctx[42], /*message*/ ctx[40]);
	}

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[31](/*i*/ ctx[39], /*j*/ ctx[42], /*message*/ ctx[40], ...args);
	}

	let if_block2 = (/*likeable*/ ctx[4] && /*j*/ ctx[42] !== 0 || /*show_copy_button*/ ctx[7] && /*message*/ ctx[40] && typeof /*message*/ ctx[40] === "string") && create_if_block_3(ctx);

	return {
		c() {
			div1 = element$1("div");
			if (if_block0) if_block0.c();
			t0 = space$1();
			div0 = element$1("div");
			button = element$1("button");
			if (if_block1) if_block1.c();
			t1 = space$1();
			if (if_block2) if_block2.c();
			attr$1(button, "data-testid", /*j*/ ctx[42] == 0 ? "user" : "bot");
			attr$1(button, "dir", button_dir_value = /*rtl*/ ctx[6] ? "rtl" : "ltr");
			attr$1(button, "aria-label", button_aria_label_value = (/*j*/ ctx[42] == 0 ? "user" : "bot") + "'s message:' " + /*message*/ ctx[40]);
			attr$1(button, "class", "svelte-1pjfiar");
			toggle_class(button, "latest", /*i*/ ctx[39] === /*value*/ ctx[0].length - 1);
			toggle_class(button, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			toggle_class(button, "selectable", /*selectable*/ ctx[3]);
			set_style(button, "user-select", `text`);
			set_style(button, "text-align", `left`);
			attr$1(div0, "class", "message " + (/*j*/ ctx[42] == 0 ? 'user' : 'bot') + " svelte-1pjfiar");
			toggle_class(div0, "message-fit", /*layout*/ ctx[16] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			toggle_class(div0, "panel-full-width", /*layout*/ ctx[16] === "panel");
			toggle_class(div0, "message-bubble-border", /*layout*/ ctx[16] === "bubble");
			toggle_class(div0, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			attr$1(div1, "class", div1_class_value = "message-row " + /*layout*/ ctx[16] + " " + (/*j*/ ctx[42] == 0 ? 'user-row' : 'bot-row') + " svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append$1(div1, t0);
			append$1(div1, div0);
			append$1(div0, button);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(button, null);
			}

			append$1(div1, t1);
			if (if_block2) if_block2.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "click", click_handler),
					listen(button, "keydown", keydown_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*avatar_images*/ ctx[8][/*j*/ ctx[42]] !== null) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_11(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros$1();

					transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros$1();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in$1(if_block1, 1);
					if_block1.m(button, null);
				} else {
					if_block1 = null;
				}
			}

			if (!current || dirty[0] & /*rtl*/ 64 && button_dir_value !== (button_dir_value = /*rtl*/ ctx[6] ? "rtl" : "ltr")) {
				attr$1(button, "dir", button_dir_value);
			}

			if (!current || dirty[0] & /*value*/ 1 && button_aria_label_value !== (button_aria_label_value = (/*j*/ ctx[42] == 0 ? "user" : "bot") + "'s message:' " + /*message*/ ctx[40])) {
				attr$1(button, "aria-label", button_aria_label_value);
			}

			if (!current || dirty[0] & /*value*/ 1) {
				toggle_class(button, "latest", /*i*/ ctx[39] === /*value*/ ctx[0].length - 1);
			}

			if (!current || dirty[0] & /*render_markdown*/ 2048) {
				toggle_class(button, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			}

			if (!current || dirty[0] & /*selectable*/ 8) {
				toggle_class(button, "selectable", /*selectable*/ ctx[3]);
			}

			if (!current || dirty[0] & /*layout, bubble_full_width*/ 66560) {
				toggle_class(div0, "message-fit", /*layout*/ ctx[16] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			}

			if (!current || dirty[0] & /*layout*/ 65536) {
				toggle_class(div0, "panel-full-width", /*layout*/ ctx[16] === "panel");
			}

			if (!current || dirty[0] & /*layout*/ 65536) {
				toggle_class(div0, "message-bubble-border", /*layout*/ ctx[16] === "bubble");
			}

			if (!current || dirty[0] & /*render_markdown*/ 2048) {
				toggle_class(div0, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			}

			if (/*likeable*/ ctx[4] && /*j*/ ctx[42] !== 0 || /*show_copy_button*/ ctx[7] && /*message*/ ctx[40] && typeof /*message*/ ctx[40] === "string") {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*likeable, show_copy_button, value*/ 145) {
						transition_in$1(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_3(ctx);
					if_block2.c();
					transition_in$1(if_block2, 1);
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				group_outros$1();

				transition_out$1(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros$1();
			}

			if (!current || dirty[0] & /*layout*/ 65536 && div1_class_value !== (div1_class_value = "message-row " + /*layout*/ ctx[16] + " " + (/*j*/ ctx[42] == 0 ? 'user-row' : 'bot-row') + " svelte-1pjfiar")) {
				attr$1(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block1);
			transition_in$1(if_block2);
			current = true;
		},
		o(local) {
			transition_out$1(if_block1);
			transition_out$1(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div1);
			}

			if (if_block0) if_block0.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:7) {#if avatar_images[j] !== null}
function create_if_block_11(ctx) {
	let div_1;
	let img;
	let img_src_value;

	return {
		c() {
			div_1 = element$1("div");
			img = element$1("img");
			attr$1(img, "class", "avatar-image svelte-1pjfiar");
			if (!src_url_equal(img.src, img_src_value = get_fetchable_url_or_file(/*avatar_images*/ ctx[8][/*j*/ ctx[42]], /*root*/ ctx[13], /*proxy_url*/ ctx[14]))) attr$1(img, "src", img_src_value);
			attr$1(img, "alt", "" + ((/*j*/ ctx[42] == 0 ? 'user' : 'bot') + " avatar"));
			attr$1(div_1, "class", "avatar-container svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, div_1, anchor);
			append$1(div_1, img);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*avatar_images, root, proxy_url*/ 24832 && !src_url_equal(img.src, img_src_value = get_fetchable_url_or_file(/*avatar_images*/ ctx[8][/*j*/ ctx[42]], /*root*/ ctx[13], /*proxy_url*/ ctx[14]))) {
				attr$1(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach$1(div_1);
			}
		}
	};
}

// (175:66) 
function create_if_block_10(ctx) {
	let a;
	let t_value = (/*message*/ ctx[40].file?.orig_name || /*message*/ ctx[40].file?.path) + "";
	let t;
	let a_href_value;
	let a_download_value;

	return {
		c() {
			a = element$1("a");
			t = text(t_value);
			attr$1(a, "data-testid", "chatbot-file");
			attr$1(a, "href", a_href_value = /*message*/ ctx[40].file?.url);
			attr$1(a, "target", "_blank");

			attr$1(a, "download", a_download_value = window.__is_colab__
			? null
			: /*message*/ ctx[40].file?.orig_name || /*message*/ ctx[40].file?.path);

			attr$1(a, "class", "svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, a, anchor);
			append$1(a, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t_value !== (t_value = (/*message*/ ctx[40].file?.orig_name || /*message*/ ctx[40].file?.path) + "")) set_data(t, t_value);

			if (dirty[0] & /*value*/ 1 && a_href_value !== (a_href_value = /*message*/ ctx[40].file?.url)) {
				attr$1(a, "href", a_href_value);
			}

			if (dirty[0] & /*value*/ 1 && a_download_value !== (a_download_value = window.__is_colab__
			? null
			: /*message*/ ctx[40].file?.orig_name || /*message*/ ctx[40].file?.path)) {
				attr$1(a, "download", a_download_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$1(a);
			}
		}
	};
}

// (169:82) 
function create_if_block_9(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	return {
		c() {
			img = element$1("img");
			attr$1(img, "data-testid", "chatbot-image");
			if (!src_url_equal(img.src, img_src_value = /*message*/ ctx[40].file?.url)) attr$1(img, "src", img_src_value);
			attr$1(img, "alt", img_alt_value = /*message*/ ctx[40].alt_text);
			attr$1(img, "class", "svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(img.src, img_src_value = /*message*/ ctx[40].file?.url)) {
				attr$1(img, "src", img_src_value);
			}

			if (dirty[0] & /*value*/ 1 && img_alt_value !== (img_alt_value = /*message*/ ctx[40].alt_text)) {
				attr$1(img, "alt", img_alt_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$1(img);
			}
		}
	};
}

// (156:82) 
function create_if_block_8(ctx) {
	let video;
	let track;
	let video_src_value;
	let video_title_value;
	let mounted;
	let dispose;

	return {
		c() {
			video = element$1("video");
			track = element$1("track");
			attr$1(track, "kind", "captions");
			attr$1(track, "class", "svelte-1pjfiar");
			attr$1(video, "data-testid", "chatbot-video");
			video.controls = true;
			if (!src_url_equal(video.src, video_src_value = /*message*/ ctx[40].file?.url)) attr$1(video, "src", video_src_value);
			attr$1(video, "title", video_title_value = /*message*/ ctx[40].alt_text);
			attr$1(video, "preload", "auto");
			attr$1(video, "class", "svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, video, anchor);
			append$1(video, track);

			if (!mounted) {
				dispose = [
					listen(video, "play", /*play_handler_1*/ ctx[25]),
					listen(video, "pause", /*pause_handler_1*/ ctx[26]),
					listen(video, "ended", /*ended_handler_1*/ ctx[27])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(video.src, video_src_value = /*message*/ ctx[40].file?.url)) {
				attr$1(video, "src", video_src_value);
			}

			if (dirty[0] & /*value*/ 1 && video_title_value !== (video_title_value = /*message*/ ctx[40].alt_text)) {
				attr$1(video, "title", video_title_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$1(video);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (145:82) 
function create_if_block_7(ctx) {
	let audio;
	let audio_src_value;
	let audio_title_value;
	let mounted;
	let dispose;

	return {
		c() {
			audio = element$1("audio");
			attr$1(audio, "data-testid", "chatbot-audio");
			audio.controls = true;
			attr$1(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*message*/ ctx[40].file?.url)) attr$1(audio, "src", audio_src_value);
			attr$1(audio, "title", audio_title_value = /*message*/ ctx[40].alt_text);
			attr$1(audio, "class", "svelte-1pjfiar");
		},
		m(target, anchor) {
			insert$1(target, audio, anchor);

			if (!mounted) {
				dispose = [
					listen(audio, "play", /*play_handler*/ ctx[22]),
					listen(audio, "pause", /*pause_handler*/ ctx[23]),
					listen(audio, "ended", /*ended_handler*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(audio.src, audio_src_value = /*message*/ ctx[40].file?.url)) {
				attr$1(audio, "src", audio_src_value);
			}

			if (dirty[0] & /*value*/ 1 && audio_title_value !== (audio_title_value = /*message*/ ctx[40].alt_text)) {
				attr$1(audio, "title", audio_title_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$1(audio);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (136:9) {#if typeof message === "string"}
function create_if_block_6(ctx) {
	let markdown;
	let current;

	markdown = new MarkdownCode({
			props: {
				message: /*message*/ ctx[40],
				latex_delimiters: /*latex_delimiters*/ ctx[1],
				sanitize_html: /*sanitize_html*/ ctx[9],
				render_markdown: /*render_markdown*/ ctx[11],
				line_breaks: /*line_breaks*/ ctx[12]
			}
		});

	markdown.$on("load", /*scroll*/ ctx[18]);

	return {
		c() {
			create_component$1(markdown.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(markdown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const markdown_changes = {};
			if (dirty[0] & /*value*/ 1) markdown_changes.message = /*message*/ ctx[40];
			if (dirty[0] & /*latex_delimiters*/ 2) markdown_changes.latex_delimiters = /*latex_delimiters*/ ctx[1];
			if (dirty[0] & /*sanitize_html*/ 512) markdown_changes.sanitize_html = /*sanitize_html*/ ctx[9];
			if (dirty[0] & /*render_markdown*/ 2048) markdown_changes.render_markdown = /*render_markdown*/ ctx[11];
			if (dirty[0] & /*line_breaks*/ 4096) markdown_changes.line_breaks = /*line_breaks*/ ctx[12];
			markdown.$set(markdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(markdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(markdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(markdown, detaching);
		}
	};
}

// (189:7) {#if (likeable && j !== 0) || (show_copy_button && message && typeof message === "string")}
function create_if_block_3(ctx) {
	let div_1;
	let t;
	let div_1_class_value;
	let current;
	let if_block0 = /*likeable*/ ctx[4] && /*j*/ ctx[42] == 1 && create_if_block_5(ctx);
	let if_block1 = /*show_copy_button*/ ctx[7] && /*message*/ ctx[40] && typeof /*message*/ ctx[40] === "string" && create_if_block_4(ctx);

	return {
		c() {
			div_1 = element$1("div");
			if (if_block0) if_block0.c();
			t = space$1();
			if (if_block1) if_block1.c();
			attr$1(div_1, "class", div_1_class_value = "message-buttons-" + (/*j*/ ctx[42] == 0 ? 'user' : 'bot') + " message-buttons-" + /*layout*/ ctx[16] + " " + (/*avatar_images*/ ctx[8][/*j*/ ctx[42]] !== null && 'with-avatar') + " svelte-1pjfiar");
			toggle_class(div_1, "message-buttons-fit", /*layout*/ ctx[16] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			toggle_class(div_1, "bubble-buttons-user", /*layout*/ ctx[16] === "bubble");
		},
		m(target, anchor) {
			insert$1(target, div_1, anchor);
			if (if_block0) if_block0.m(div_1, null);
			append$1(div_1, t);
			if (if_block1) if_block1.m(div_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*likeable*/ ctx[4] && /*j*/ ctx[42] == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*likeable*/ 16) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(div_1, t);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			if (/*show_copy_button*/ ctx[7] && /*message*/ ctx[40] && typeof /*message*/ ctx[40] === "string") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*show_copy_button, value*/ 129) {
						transition_in$1(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in$1(if_block1, 1);
					if_block1.m(div_1, null);
				}
			} else if (if_block1) {
				group_outros$1();

				transition_out$1(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$1();
			}

			if (!current || dirty[0] & /*layout, avatar_images*/ 65792 && div_1_class_value !== (div_1_class_value = "message-buttons-" + (/*j*/ ctx[42] == 0 ? 'user' : 'bot') + " message-buttons-" + /*layout*/ ctx[16] + " " + (/*avatar_images*/ ctx[8][/*j*/ ctx[42]] !== null && 'with-avatar') + " svelte-1pjfiar")) {
				attr$1(div_1, "class", div_1_class_value);
			}

			if (!current || dirty[0] & /*layout, avatar_images, layout, bubble_full_width*/ 66816) {
				toggle_class(div_1, "message-buttons-fit", /*layout*/ ctx[16] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			}

			if (!current || dirty[0] & /*layout, avatar_images, layout*/ 65792) {
				toggle_class(div_1, "bubble-buttons-user", /*layout*/ ctx[16] === "bubble");
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (199:9) {#if likeable && j == 1}
function create_if_block_5(ctx) {
	let likedislike0;
	let t;
	let likedislike1;
	let current;

	function func() {
		return /*func*/ ctx[32](/*i*/ ctx[39], /*j*/ ctx[42], /*message*/ ctx[40]);
	}

	likedislike0 = new LikeDislike({
			props: { action: "like", handle_action: func }
		});

	function func_1() {
		return /*func_1*/ ctx[33](/*i*/ ctx[39], /*j*/ ctx[42], /*message*/ ctx[40]);
	}

	likedislike1 = new LikeDislike({
			props: { action: "dislike", handle_action: func_1 }
		});

	return {
		c() {
			create_component$1(likedislike0.$$.fragment);
			t = space$1();
			create_component$1(likedislike1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(likedislike0, target, anchor);
			insert$1(target, t, anchor);
			mount_component$1(likedislike1, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const likedislike0_changes = {};
			if (dirty[0] & /*value*/ 1) likedislike0_changes.handle_action = func;
			likedislike0.$set(likedislike0_changes);
			const likedislike1_changes = {};
			if (dirty[0] & /*value*/ 1) likedislike1_changes.handle_action = func_1;
			likedislike1.$set(likedislike1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(likedislike0.$$.fragment, local);
			transition_in$1(likedislike1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(likedislike0.$$.fragment, local);
			transition_out$1(likedislike1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
			}

			destroy_component$1(likedislike0, detaching);
			destroy_component$1(likedislike1, detaching);
		}
	};
}

// (209:9) {#if show_copy_button && message && typeof message === "string"}
function create_if_block_4(ctx) {
	let copy_1;
	let current;
	copy_1 = new Copy_1({ props: { value: /*message*/ ctx[40] } });

	return {
		c() {
			create_component$1(copy_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(copy_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const copy_1_changes = {};
			if (dirty[0] & /*value*/ 1) copy_1_changes.value = /*message*/ ctx[40];
			copy_1.$set(copy_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(copy_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(copy_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(copy_1, detaching);
		}
	};
}

// (94:4) {#each message_pair as message, j}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*message*/ ctx[40] !== null && create_if_block_2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert$1(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*message*/ ctx[40] !== null) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*value*/ 1) {
						transition_in$1(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in$1(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros$1();

				transition_out$1(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block);
			current = true;
		},
		o(local) {
			transition_out$1(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (93:3) {#each value as message_pair, i}
function create_each_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = ensure_array_like(/*message_pair*/ ctx[37]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out$1(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert$1(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*layout, avatar_images, bubble_full_width, value, show_copy_button, handle_like, likeable, render_markdown, rtl, selectable, handle_select, latex_delimiters, sanitize_html, line_breaks, scroll, root, proxy_url*/ 1933275) {
				each_value_1 = ensure_array_like(/*message_pair*/ ctx[37]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in$1(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in$1(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros$1();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in$1(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out$1(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (218:3) {#if pending_message}
function create_if_block_1$1(ctx) {
	let pending;
	let current;
	pending = new Pending({ props: { layout: /*layout*/ ctx[16] } });

	return {
		c() {
			create_component$1(pending.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(pending, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pending_changes = {};
			if (dirty[0] & /*layout*/ 65536) pending_changes.layout = /*layout*/ ctx[16];
			pending.$set(pending_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(pending.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(pending.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(pending, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let t;
	let div1;
	let div0;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_share_button*/ ctx[5] && /*value*/ ctx[0] !== null && /*value*/ ctx[0].length > 0 && create_if_block_12(ctx);
	let if_block1 = /*value*/ ctx[0] !== null && create_if_block$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space$1();
			div1 = element$1("div");
			div0 = element$1("div");
			if (if_block1) if_block1.c();
			attr$1(div0, "class", "message-wrap svelte-1pjfiar");
			toggle_class(div0, "bubble-gap", /*layout*/ ctx[16] === "bubble");

			attr$1(div1, "class", div1_class_value = "" + (null_to_empty(/*layout*/ ctx[16] === "bubble"
			? "bubble-wrap"
			: "panel-wrap") + " svelte-1pjfiar"));

			attr$1(div1, "role", "log");
			attr$1(div1, "aria-label", "chatbot conversation");
			attr$1(div1, "aria-live", "polite");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert$1(target, t, anchor);
			insert$1(target, div1, anchor);
			append$1(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			/*div1_binding*/ ctx[34](div1);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(copy.call(null, div0));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_share_button*/ ctx[5] && /*value*/ ctx[0] !== null && /*value*/ ctx[0].length > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_share_button, value*/ 33) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			if (/*value*/ ctx[0] !== null) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*value*/ 1) {
						transition_in$1(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in$1(if_block1, 1);
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				group_outros$1();

				transition_out$1(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$1();
			}

			if (!current || dirty[0] & /*layout*/ 65536) {
				toggle_class(div0, "bubble-gap", /*layout*/ ctx[16] === "bubble");
			}

			if (!current || dirty[0] & /*layout*/ 65536 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*layout*/ ctx[16] === "bubble"
			? "bubble-wrap"
			: "panel-wrap") + " svelte-1pjfiar"))) {
				attr$1(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(div1);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			/*div1_binding*/ ctx[34](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { value } = $$props;
	let old_value = null;
	let { latex_delimiters } = $$props;
	let { pending_message = false } = $$props;
	let { selectable = false } = $$props;
	let { likeable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { rtl = false } = $$props;
	let { show_copy_button = false } = $$props;
	let { avatar_images = [null, null] } = $$props;
	let { sanitize_html = true } = $$props;
	let { bubble_full_width = true } = $$props;
	let { render_markdown = true } = $$props;
	let { line_breaks = true } = $$props;
	let { root } = $$props;
	let { proxy_url } = $$props;
	let { i18n } = $$props;
	let { layout = "bubble" } = $$props;
	let div;
	let autoscroll;
	const dispatch = createEventDispatcher();

	beforeUpdate(() => {
		autoscroll = div && div.offsetHeight + div.scrollTop > div.scrollHeight - 100;
	});

	const scroll = () => {
		if (autoscroll) {
			div.scrollTo(0, div.scrollHeight);
		}
	};

	afterUpdate(() => {
		if (autoscroll) {
			scroll();

			div.querySelectorAll("img").forEach(n => {
				n.addEventListener("load", () => {
					scroll();
				});
			});
		}
	});

	function handle_select(i, j, message) {
		dispatch("select", { index: [i, j], value: message });
	}

	function handle_like(i, j, message, liked) {
		dispatch("like", { index: [i, j], value: message, liked });
	}

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	function share_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = (i, j, message) => handle_select(i, j, message);

	const keydown_handler = (i, j, message, e) => {
		if (e.key === "Enter") {
			handle_select(i, j, message);
		}
	};

	const func = (i, j, message) => handle_like(i, j, message, true);
	const func_1 = (i, j, message) => handle_like(i, j, message, false);

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			div = $$value;
			$$invalidate(17, div);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('latex_delimiters' in $$props) $$invalidate(1, latex_delimiters = $$props.latex_delimiters);
		if ('pending_message' in $$props) $$invalidate(2, pending_message = $$props.pending_message);
		if ('selectable' in $$props) $$invalidate(3, selectable = $$props.selectable);
		if ('likeable' in $$props) $$invalidate(4, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(5, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(6, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(7, show_copy_button = $$props.show_copy_button);
		if ('avatar_images' in $$props) $$invalidate(8, avatar_images = $$props.avatar_images);
		if ('sanitize_html' in $$props) $$invalidate(9, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(10, bubble_full_width = $$props.bubble_full_width);
		if ('render_markdown' in $$props) $$invalidate(11, render_markdown = $$props.render_markdown);
		if ('line_breaks' in $$props) $$invalidate(12, line_breaks = $$props.line_breaks);
		if ('root' in $$props) $$invalidate(13, root = $$props.root);
		if ('proxy_url' in $$props) $$invalidate(14, proxy_url = $$props.proxy_url);
		if ('i18n' in $$props) $$invalidate(15, i18n = $$props.i18n);
		if ('layout' in $$props) $$invalidate(16, layout = $$props.layout);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, old_value*/ 2097153) {
			{
				if (!dequal(value, old_value)) {
					$$invalidate(21, old_value = value);
					dispatch("change");
				}
			}
		}
	};

	return [
		value,
		latex_delimiters,
		pending_message,
		selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		avatar_images,
		sanitize_html,
		bubble_full_width,
		render_markdown,
		line_breaks,
		root,
		proxy_url,
		i18n,
		layout,
		div,
		scroll,
		handle_select,
		handle_like,
		old_value,
		play_handler,
		pause_handler,
		ended_handler,
		play_handler_1,
		pause_handler_1,
		ended_handler_1,
		error_handler,
		share_handler,
		click_handler,
		keydown_handler,
		func,
		func_1,
		div1_binding
	];
}

class ChatBot extends SvelteComponent$1 {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal$1,
			{
				value: 0,
				latex_delimiters: 1,
				pending_message: 2,
				selectable: 3,
				likeable: 4,
				show_share_button: 5,
				rtl: 6,
				show_copy_button: 7,
				avatar_images: 8,
				sanitize_html: 9,
				bubble_full_width: 10,
				render_markdown: 11,
				line_breaks: 12,
				root: 13,
				proxy_url: 14,
				i18n: 15,
				layout: 16
			},
			null,
			[-1, -1]
		);
	}
}

const ChatBot$1 = ChatBot;

const Index_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/Index.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	append,
	assign,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} = window.__gradio__svelte__internal;
function create_if_block_1(ctx) {
	let statustracker;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[21].autoscroll
		},
		{ i18n: /*gradio*/ ctx[21].i18n },
		/*loading_status*/ ctx[23],
		{
			show_progress: /*loading_status*/ ctx[23].show_progress === "hidden"
			? "hidden"
			: "minimal"
		}
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({ props: statustracker_props });

	return {
		c() {
			create_component(statustracker.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 10485760)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 2097152 && {
						autoscroll: /*gradio*/ ctx[21].autoscroll
					},
					dirty[0] & /*gradio*/ 2097152 && { i18n: /*gradio*/ ctx[21].i18n },
					dirty[0] & /*loading_status*/ 8388608 && get_spread_object(/*loading_status*/ ctx[23]),
					dirty[0] & /*loading_status*/ 8388608 && {
						show_progress: /*loading_status*/ ctx[23].show_progress === "hidden"
						? "hidden"
						: "minimal"
					}
				])
			: {};

			statustracker.$set(statustracker_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(statustracker, detaching);
		}
	};
}

// (78:2) {#if show_label}
function create_if_block(ctx) {
	let blocklabel;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[7],
				Icon: Chat,
				float: false,
				label: /*label*/ ctx[6] || "Chatbot"
			}
		});

	return {
		c() {
			create_component(blocklabel.$$.fragment);
		},
		m(target, anchor) {
			mount_component(blocklabel, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 128) blocklabel_changes.show_label = /*show_label*/ ctx[7];
			if (dirty[0] & /*label*/ 64) blocklabel_changes.label = /*label*/ ctx[6] || "Chatbot";
			blocklabel.$set(blocklabel_changes);
		},
		i(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(blocklabel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(blocklabel, detaching);
		}
	};
}

// (57:0) <Block  {elem_id}  {elem_classes}  {visible}  padding={false}  {scale}  {min_width}  {height}  allow_overflow={false} >
function create_default_slot(ctx) {
	let t0;
	let div;
	let t1;
	let chatbot;
	let current;
	let if_block0 = /*loading_status*/ ctx[23] && create_if_block_1(ctx);
	let if_block1 = /*show_label*/ ctx[7] && create_if_block(ctx);

	chatbot = new ChatBot$1({
			props: {
				i18n: /*gradio*/ ctx[21].i18n,
				selectable: /*_selectable*/ ctx[10],
				likeable: /*likeable*/ ctx[11],
				show_share_button: /*show_share_button*/ ctx[12],
				value: /*_value*/ ctx[25],
				latex_delimiters: /*latex_delimiters*/ ctx[20],
				render_markdown: /*render_markdown*/ ctx[18],
				pending_message: /*loading_status*/ ctx[23]?.status === "pending",
				rtl: /*rtl*/ ctx[13],
				show_copy_button: /*show_copy_button*/ ctx[14],
				avatar_images: /*avatar_images*/ ctx[22],
				sanitize_html: /*sanitize_html*/ ctx[15],
				bubble_full_width: /*bubble_full_width*/ ctx[16],
				line_breaks: /*line_breaks*/ ctx[19],
				layout: /*layout*/ ctx[17],
				proxy_url: /*proxy_url*/ ctx[9],
				root: /*root*/ ctx[8]
			}
		});

	chatbot.$on("change", /*change_handler*/ ctx[26]);
	chatbot.$on("select", /*select_handler*/ ctx[27]);
	chatbot.$on("like", /*like_handler*/ ctx[28]);
	chatbot.$on("share", /*share_handler*/ ctx[29]);
	chatbot.$on("error", /*error_handler*/ ctx[30]);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			create_component(chatbot.$$.fragment);
			attr(div, "class", "wrapper svelte-nab2ao");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			mount_component(chatbot, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*loading_status*/ ctx[23]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*loading_status*/ 8388608) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*show_label*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*show_label*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const chatbot_changes = {};
			if (dirty[0] & /*gradio*/ 2097152) chatbot_changes.i18n = /*gradio*/ ctx[21].i18n;
			if (dirty[0] & /*_selectable*/ 1024) chatbot_changes.selectable = /*_selectable*/ ctx[10];
			if (dirty[0] & /*likeable*/ 2048) chatbot_changes.likeable = /*likeable*/ ctx[11];
			if (dirty[0] & /*show_share_button*/ 4096) chatbot_changes.show_share_button = /*show_share_button*/ ctx[12];
			if (dirty[0] & /*_value*/ 33554432) chatbot_changes.value = /*_value*/ ctx[25];
			if (dirty[0] & /*latex_delimiters*/ 1048576) chatbot_changes.latex_delimiters = /*latex_delimiters*/ ctx[20];
			if (dirty[0] & /*render_markdown*/ 262144) chatbot_changes.render_markdown = /*render_markdown*/ ctx[18];
			if (dirty[0] & /*loading_status*/ 8388608) chatbot_changes.pending_message = /*loading_status*/ ctx[23]?.status === "pending";
			if (dirty[0] & /*rtl*/ 8192) chatbot_changes.rtl = /*rtl*/ ctx[13];
			if (dirty[0] & /*show_copy_button*/ 16384) chatbot_changes.show_copy_button = /*show_copy_button*/ ctx[14];
			if (dirty[0] & /*avatar_images*/ 4194304) chatbot_changes.avatar_images = /*avatar_images*/ ctx[22];
			if (dirty[0] & /*sanitize_html*/ 32768) chatbot_changes.sanitize_html = /*sanitize_html*/ ctx[15];
			if (dirty[0] & /*bubble_full_width*/ 65536) chatbot_changes.bubble_full_width = /*bubble_full_width*/ ctx[16];
			if (dirty[0] & /*line_breaks*/ 524288) chatbot_changes.line_breaks = /*line_breaks*/ ctx[19];
			if (dirty[0] & /*layout*/ 131072) chatbot_changes.layout = /*layout*/ ctx[17];
			if (dirty[0] & /*proxy_url*/ 512) chatbot_changes.proxy_url = /*proxy_url*/ ctx[9];
			if (dirty[0] & /*root*/ 256) chatbot_changes.root = /*root*/ ctx[8];
			chatbot.$set(chatbot_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(chatbot.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(chatbot.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(div);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			destroy_component(chatbot);
		}
	};
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				elem_id: /*elem_id*/ ctx[0],
				elem_classes: /*elem_classes*/ ctx[1],
				visible: /*visible*/ ctx[2],
				padding: false,
				scale: /*scale*/ ctx[4],
				min_width: /*min_width*/ ctx[5],
				height: /*height*/ ctx[24],
				allow_overflow: false,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};
			if (dirty[0] & /*elem_id*/ 1) block_changes.elem_id = /*elem_id*/ ctx[0];
			if (dirty[0] & /*elem_classes*/ 2) block_changes.elem_classes = /*elem_classes*/ ctx[1];
			if (dirty[0] & /*visible*/ 4) block_changes.visible = /*visible*/ ctx[2];
			if (dirty[0] & /*scale*/ 16) block_changes.scale = /*scale*/ ctx[4];
			if (dirty[0] & /*min_width*/ 32) block_changes.min_width = /*min_width*/ ctx[5];
			if (dirty[0] & /*height*/ 16777216) block_changes.height = /*height*/ ctx[24];

			if (dirty[0] & /*gradio, _selectable, likeable, show_share_button, _value, latex_delimiters, render_markdown, loading_status, rtl, show_copy_button, avatar_images, sanitize_html, bubble_full_width, line_breaks, layout, proxy_url, root, value, show_label, label*/ 50331592 | dirty[1] & /*$$scope*/ 4) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = [] } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { label } = $$props;
	let { show_label = true } = $$props;
	let { root } = $$props;
	let { proxy_url } = $$props;
	let { _selectable = false } = $$props;
	let { likeable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { rtl = false } = $$props;
	let { show_copy_button = false } = $$props;
	let { sanitize_html = true } = $$props;
	let { bubble_full_width = true } = $$props;
	let { layout = "bubble" } = $$props;
	let { render_markdown = true } = $$props;
	let { line_breaks = true } = $$props;
	let { latex_delimiters } = $$props;
	let { gradio } = $$props;
	let { avatar_images = [null, null] } = $$props;
	let _value;
	const redirect_src_url = src => src.replace('src="/file', `src="${root}file`);

	function normalize_messages(message) {
		if (message === null) {
			return message;
		}

		return {
			file: normalise_file(message?.file, root, proxy_url),
			alt_text: message?.alt_text
		};
	}

	let { loading_status = undefined } = $$props;
	let { height = 400 } = $$props;
	const change_handler = () => gradio.dispatch("change", value);
	const select_handler = e => gradio.dispatch("select", e.detail);
	const like_handler = e => gradio.dispatch("like", e.detail);
	const share_handler = e => gradio.dispatch("share", e.detail);
	const error_handler = e => gradio.dispatch("error", e.detail);

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(0, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(1, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(2, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(5, min_width = $$props.min_width);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(7, show_label = $$props.show_label);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('proxy_url' in $$props) $$invalidate(9, proxy_url = $$props.proxy_url);
		if ('_selectable' in $$props) $$invalidate(10, _selectable = $$props._selectable);
		if ('likeable' in $$props) $$invalidate(11, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(12, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(13, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(14, show_copy_button = $$props.show_copy_button);
		if ('sanitize_html' in $$props) $$invalidate(15, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(16, bubble_full_width = $$props.bubble_full_width);
		if ('layout' in $$props) $$invalidate(17, layout = $$props.layout);
		if ('render_markdown' in $$props) $$invalidate(18, render_markdown = $$props.render_markdown);
		if ('line_breaks' in $$props) $$invalidate(19, line_breaks = $$props.line_breaks);
		if ('latex_delimiters' in $$props) $$invalidate(20, latex_delimiters = $$props.latex_delimiters);
		if ('gradio' in $$props) $$invalidate(21, gradio = $$props.gradio);
		if ('avatar_images' in $$props) $$invalidate(22, avatar_images = $$props.avatar_images);
		if ('loading_status' in $$props) $$invalidate(23, loading_status = $$props.loading_status);
		if ('height' in $$props) $$invalidate(24, height = $$props.height);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 8) {
			$$invalidate(25, _value = value
			? value.map(([user_msg, bot_msg]) => [
					typeof user_msg === "string"
					? redirect_src_url(user_msg)
					: normalize_messages(user_msg),
					typeof bot_msg === "string"
					? redirect_src_url(bot_msg)
					: normalize_messages(bot_msg)
				])
			: []);
		}
	};

	return [
		elem_id,
		elem_classes,
		visible,
		value,
		scale,
		min_width,
		label,
		show_label,
		root,
		proxy_url,
		_selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		sanitize_html,
		bubble_full_width,
		layout,
		render_markdown,
		line_breaks,
		latex_delimiters,
		gradio,
		avatar_images,
		loading_status,
		height,
		_value,
		change_handler,
		select_handler,
		like_handler,
		share_handler,
		error_handler
	];
}

class Index extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				elem_id: 0,
				elem_classes: 1,
				visible: 2,
				value: 3,
				scale: 4,
				min_width: 5,
				label: 6,
				show_label: 7,
				root: 8,
				proxy_url: 9,
				_selectable: 10,
				likeable: 11,
				show_share_button: 12,
				rtl: 13,
				show_copy_button: 14,
				sanitize_html: 15,
				bubble_full_width: 16,
				layout: 17,
				render_markdown: 18,
				line_breaks: 19,
				latex_delimiters: 20,
				gradio: 21,
				avatar_images: 22,
				loading_status: 23,
				height: 24
			},
			null,
			[-1, -1]
		);
	}
}

export { ChatBot$1 as BaseChatBot, Index as default };
//# sourceMappingURL=Index-33b978ea.js.map
