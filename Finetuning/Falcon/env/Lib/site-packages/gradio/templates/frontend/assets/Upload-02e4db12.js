import { p as prepare_files, u as upload } from './index-5550136d.js';
import './Index-2cec2c56.js';
/* empty css                                                     */
/* home/runner/work/gradio/gradio/js/upload/src/UploadProgress.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$1,
	append: append$1,
	attr: attr$1,
	detach: detach$1,
	element: element$1,
	init: init$1,
	insert: insert$1,
	noop,
	safe_not_equal: safe_not_equal$1,
	set_data,
	set_style: set_style$1,
	space: space$1,
	text,
	toggle_class: toggle_class$1
} = window.__gradio__svelte__internal;const { onMount, createEventDispatcher: createEventDispatcher$1 } = window.__gradio__svelte__internal;
function create_if_block$1(ctx) {
	let div1;
	let span0;
	let div0;
	let progress_1;
	let t0_value = getProgress(/*current_file_upload*/ ctx[2]) + "";
	let t0;
	let progress_1_value_value;
	let t1;
	let span1;
	let t2_value = /*current_file_upload*/ ctx[2].orig_name + "";
	let t2;

	return {
		c() {
			div1 = element$1("div");
			span0 = element$1("span");
			div0 = element$1("div");
			progress_1 = element$1("progress");
			t0 = text(t0_value);
			t1 = space$1();
			span1 = element$1("span");
			t2 = text(t2_value);
			set_style$1(progress_1, "visibility", "hidden");
			set_style$1(progress_1, "height", "0");
			set_style$1(progress_1, "width", "0");
			progress_1.value = progress_1_value_value = getProgress(/*current_file_upload*/ ctx[2]);
			attr$1(progress_1, "max", "100");
			attr$1(progress_1, "class", "svelte-lx0x25");
			attr$1(div0, "class", "progress-bar svelte-lx0x25");
			attr$1(span1, "class", "file-name svelte-lx0x25");
			attr$1(div1, "class", "file svelte-lx0x25");
		},
		m(target, anchor) {
			insert$1(target, div1, anchor);
			append$1(div1, span0);
			append$1(span0, div0);
			append$1(div0, progress_1);
			append$1(progress_1, t0);
			append$1(div1, t1);
			append$1(div1, span1);
			append$1(span1, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*current_file_upload*/ 4 && t0_value !== (t0_value = getProgress(/*current_file_upload*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (dirty & /*current_file_upload*/ 4 && progress_1_value_value !== (progress_1_value_value = getProgress(/*current_file_upload*/ ctx[2]))) {
				progress_1.value = progress_1_value_value;
			}

			if (dirty & /*current_file_upload*/ 4 && t2_value !== (t2_value = /*current_file_upload*/ ctx[2].orig_name + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach$1(div1);
			}
		}
	};
}

function create_fragment$1(ctx) {
	let div;
	let span;
	let t0;
	let t1_value = /*files_with_progress*/ ctx[0].length + "";
	let t1;
	let t2;

	let t3_value = (/*files_with_progress*/ ctx[0].length > 1
	? "files"
	: "file") + "";

	let t3;
	let t4;
	let t5;
	let if_block = /*current_file_upload*/ ctx[2] && create_if_block$1(ctx);

	return {
		c() {
			div = element$1("div");
			span = element$1("span");
			t0 = text("Uploading ");
			t1 = text(t1_value);
			t2 = space$1();
			t3 = text(t3_value);
			t4 = text("...");
			t5 = space$1();
			if (if_block) if_block.c();
			attr$1(span, "class", "uploading svelte-lx0x25");
			attr$1(div, "class", "wrap svelte-lx0x25");
			toggle_class$1(div, "progress", /*progress*/ ctx[1]);
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			append$1(div, span);
			append$1(span, t0);
			append$1(span, t1);
			append$1(span, t2);
			append$1(span, t3);
			append$1(span, t4);
			append$1(div, t5);
			if (if_block) if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*files_with_progress*/ 1 && t1_value !== (t1_value = /*files_with_progress*/ ctx[0].length + "")) set_data(t1, t1_value);

			if (dirty & /*files_with_progress*/ 1 && t3_value !== (t3_value = (/*files_with_progress*/ ctx[0].length > 1
			? "files"
			: "file") + "")) set_data(t3, t3_value);

			if (/*current_file_upload*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*progress*/ 2) {
				toggle_class$1(div, "progress", /*progress*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			if (if_block) if_block.d();
		}
	};
}

function getProgress(file) {
	return file.progress * 100 / (file.size || 0) || 0;
}

function calculateTotalProgress(files) {
	let totalProgress = 0;

	files.forEach(file => {
		totalProgress += getProgress(file);
	});

	document.documentElement.style.setProperty("--upload-progress-width", (totalProgress / files.length).toFixed(2) + "%");
	return totalProgress / files.length;
}

function instance$1($$self, $$props, $$invalidate) {
	let { upload_id } = $$props;
	let { root } = $$props;
	let { files } = $$props;
	let event_source;
	let progress = false;
	let current_file_upload;

	let files_with_progress = files.map(file => {
		return { ...file, progress: 0 };
	});

	const dispatch = createEventDispatcher$1();

	function handleProgress(filename, chunk_size) {
		// Find the corresponding file in the array and update its progress
		$$invalidate(0, files_with_progress = files_with_progress.map(file => {
			if (file.orig_name === filename) {
				file.progress += chunk_size;
			}

			return file;
		}));
	}

	onMount(() => {
		event_source = new EventSource(`${root}/upload_progress?upload_id=${upload_id}`);

		// Event listener for progress updates
		event_source.onmessage = async function (event) {
			const _data = JSON.parse(event.data);
			if (!progress) $$invalidate(1, progress = true);

			if (_data.msg === "done") {
				event_source.close();
				dispatch("done");
			} else {
				$$invalidate(2, current_file_upload = _data);
				handleProgress(_data.orig_name, _data.chunk_size);
			}
		};
	});

	$$self.$$set = $$props => {
		if ('upload_id' in $$props) $$invalidate(3, upload_id = $$props.upload_id);
		if ('root' in $$props) $$invalidate(4, root = $$props.root);
		if ('files' in $$props) $$invalidate(5, files = $$props.files);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*files_with_progress*/ 1) {
			calculateTotalProgress(files_with_progress);
		}
	};

	return [files_with_progress, progress, current_file_upload, upload_id, root, files];
}

class UploadProgress extends SvelteComponent$1 {
	constructor(options) {
		super();
		init$1(this, options, instance$1, create_fragment$1, safe_not_equal$1, { upload_id: 3, root: 4, files: 5 });
	}
}

/* home/runner/work/gradio/gradio/js/upload/src/Upload.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	empty,
	get_all_dirty_from_scope,
	get_slot_changes,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	prevent_default,
	run_all,
	safe_not_equal,
	set_style,
	space,
	stop_propagation,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} = window.__gradio__svelte__internal;
const { createEventDispatcher, tick, getContext } = window.__gradio__svelte__internal;
function create_else_block(ctx) {
	let button;
	let t;
	let input;
	let input_multiple_value;
	let input_webkitdirectory_value;
	let input_mozdirectory_value;
	let button_tabindex_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			button = element("button");
			if (default_slot) default_slot.c();
			t = space();
			input = element("input");
			attr(input, "aria-label", "file upload");
			attr(input, "type", "file");
			attr(input, "accept", /*filetype*/ ctx[1]);
			input.multiple = input_multiple_value = /*file_count*/ ctx[5] === "multiple" || undefined;
			attr(input, "webkitdirectory", input_webkitdirectory_value = /*file_count*/ ctx[5] === "directory" || undefined);
			attr(input, "mozdirectory", input_mozdirectory_value = /*file_count*/ ctx[5] === "directory" || undefined);
			attr(input, "class", "svelte-jqnyug");
			attr(button, "tabindex", button_tabindex_value = /*hidden*/ ctx[7] ? -1 : 0);
			attr(button, "class", "svelte-jqnyug");
			toggle_class(button, "hidden", /*hidden*/ ctx[7]);
			toggle_class(button, "center", /*center*/ ctx[3]);
			toggle_class(button, "boundedheight", /*boundedheight*/ ctx[2]);
			toggle_class(button, "flex", /*flex*/ ctx[4]);
			set_style(button, "height", /*include_sources*/ ctx[8] ? "calc(100% - 40px" : "100%");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append(button, t);
			append(button, input);
			/*input_binding*/ ctx[29](input);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", /*load_files_from_upload*/ ctx[14]),
					listen(button, "drag", stop_propagation(prevent_default(/*drag_handler*/ ctx[22]))),
					listen(button, "dragstart", stop_propagation(prevent_default(/*dragstart_handler*/ ctx[23]))),
					listen(button, "dragend", stop_propagation(prevent_default(/*dragend_handler*/ ctx[24]))),
					listen(button, "dragover", stop_propagation(prevent_default(/*dragover_handler*/ ctx[25]))),
					listen(button, "dragenter", stop_propagation(prevent_default(/*dragenter_handler*/ ctx[26]))),
					listen(button, "dragleave", stop_propagation(prevent_default(/*dragleave_handler*/ ctx[27]))),
					listen(button, "drop", stop_propagation(prevent_default(/*drop_handler*/ ctx[28]))),
					listen(button, "click", /*open_file_upload*/ ctx[9]),
					listen(button, "drop", /*loadFilesFromDrop*/ ctx[15]),
					listen(button, "dragenter", /*updateDragging*/ ctx[13]),
					listen(button, "dragleave", /*updateDragging*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*filetype*/ 2) {
				attr(input, "accept", /*filetype*/ ctx[1]);
			}

			if (!current || dirty[0] & /*file_count*/ 32 && input_multiple_value !== (input_multiple_value = /*file_count*/ ctx[5] === "multiple" || undefined)) {
				input.multiple = input_multiple_value;
			}

			if (!current || dirty[0] & /*file_count*/ 32 && input_webkitdirectory_value !== (input_webkitdirectory_value = /*file_count*/ ctx[5] === "directory" || undefined)) {
				attr(input, "webkitdirectory", input_webkitdirectory_value);
			}

			if (!current || dirty[0] & /*file_count*/ 32 && input_mozdirectory_value !== (input_mozdirectory_value = /*file_count*/ ctx[5] === "directory" || undefined)) {
				attr(input, "mozdirectory", input_mozdirectory_value);
			}

			if (!current || dirty[0] & /*hidden*/ 128 && button_tabindex_value !== (button_tabindex_value = /*hidden*/ ctx[7] ? -1 : 0)) {
				attr(button, "tabindex", button_tabindex_value);
			}

			if (!current || dirty[0] & /*hidden*/ 128) {
				toggle_class(button, "hidden", /*hidden*/ ctx[7]);
			}

			if (!current || dirty[0] & /*center*/ 8) {
				toggle_class(button, "center", /*center*/ ctx[3]);
			}

			if (!current || dirty[0] & /*boundedheight*/ 4) {
				toggle_class(button, "boundedheight", /*boundedheight*/ ctx[2]);
			}

			if (!current || dirty[0] & /*flex*/ 16) {
				toggle_class(button, "flex", /*flex*/ ctx[4]);
			}

			if (dirty[0] & /*include_sources*/ 256) {
				set_style(button, "height", /*include_sources*/ ctx[8] ? "calc(100% - 40px" : "100%");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (default_slot) default_slot.d(detaching);
			/*input_binding*/ ctx[29](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (91:0) {#if uploading}
function create_if_block(ctx) {
	let uploadprogress;
	let current;

	uploadprogress = new UploadProgress({
			props: {
				root: /*root*/ ctx[6],
				upload_id: /*upload_id*/ ctx[10],
				files: /*file_data*/ ctx[11]
			}
		});

	return {
		c() {
			create_component(uploadprogress.$$.fragment);
		},
		m(target, anchor) {
			mount_component(uploadprogress, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const uploadprogress_changes = {};
			if (dirty[0] & /*root*/ 64) uploadprogress_changes.root = /*root*/ ctx[6];
			if (dirty[0] & /*upload_id*/ 1024) uploadprogress_changes.upload_id = /*upload_id*/ ctx[10];
			if (dirty[0] & /*file_data*/ 2048) uploadprogress_changes.files = /*file_data*/ ctx[11];
			uploadprogress.$set(uploadprogress_changes);
		},
		i(local) {
			if (current) return;
			transition_in(uploadprogress.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(uploadprogress.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(uploadprogress, detaching);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*uploading*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function is_valid_mimetype(file_accept, mime_type) {
	if (!file_accept) {
		return true;
	}

	if (file_accept === "*") {
		return true;
	}

	if (file_accept.endsWith("/*")) {
		return mime_type.startsWith(file_accept.slice(0, -1));
	}

	return file_accept === mime_type;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { filetype = null } = $$props;
	let { dragging = false } = $$props;
	let { boundedheight = true } = $$props;
	let { center = true } = $$props;
	let { flex = true } = $$props;
	let { file_count = "single" } = $$props;
	let { disable_click = false } = $$props;
	let { root } = $$props;
	let { hidden = false } = $$props;
	let { format = "file" } = $$props;
	let { include_sources = false } = $$props;
	let { uploading = false } = $$props;
	let upload_id;
	let file_data;

	// Needed for wasm support
	const upload_fn = getContext("upload_files");

	let hidden_upload;
	const dispatch = createEventDispatcher();

	function updateDragging() {
		$$invalidate(16, dragging = !dragging);
	}

	function open_file_upload() {
		if (disable_click) return;
		$$invalidate(12, hidden_upload.value = "", hidden_upload);
		hidden_upload.click();
	}

	async function handle_upload(file_data) {
		await tick();
		$$invalidate(10, upload_id = Math.random().toString(36).substring(2, 15));
		$$invalidate(0, uploading = true);
		const _file_data = await upload(file_data, root, upload_id, upload_fn);
		dispatch("load", file_count === "single" ? _file_data?.[0] : _file_data);
		$$invalidate(0, uploading = false);
		return _file_data || [];
	}

	async function load_files(files) {
		if (!files.length) {
			return;
		}

		let _files = files.map(f => new File([f], f.name));
		$$invalidate(11, file_data = await prepare_files(_files));
		return await handle_upload(file_data);
	}

	async function load_files_from_upload(e) {
		const target = e.target;
		if (!target.files) return;

		if (format != "blob") {
			await load_files(Array.from(target.files));
		} else {
			if (file_count === "single") {
				dispatch("load", target.files[0]);
				return;
			}

			dispatch("load", target.files);
		}
	}

	async function loadFilesFromDrop(e) {
		$$invalidate(16, dragging = false);
		if (!e.dataTransfer?.files) return;

		const files_to_load = Array.from(e.dataTransfer.files).filter(f => {
			if (filetype?.split(",").some(m => is_valid_mimetype(m, f.type))) {
				return true;
			}

			dispatch("error", `Invalid file type only ${filetype} allowed.`);
			return false;
		});

		await load_files(files_to_load);
	}

	function drag_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragstart_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragend_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function drop_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			hidden_upload = $$value;
			$$invalidate(12, hidden_upload);
		});
	}

	$$self.$$set = $$props => {
		if ('filetype' in $$props) $$invalidate(1, filetype = $$props.filetype);
		if ('dragging' in $$props) $$invalidate(16, dragging = $$props.dragging);
		if ('boundedheight' in $$props) $$invalidate(2, boundedheight = $$props.boundedheight);
		if ('center' in $$props) $$invalidate(3, center = $$props.center);
		if ('flex' in $$props) $$invalidate(4, flex = $$props.flex);
		if ('file_count' in $$props) $$invalidate(5, file_count = $$props.file_count);
		if ('disable_click' in $$props) $$invalidate(17, disable_click = $$props.disable_click);
		if ('root' in $$props) $$invalidate(6, root = $$props.root);
		if ('hidden' in $$props) $$invalidate(7, hidden = $$props.hidden);
		if ('format' in $$props) $$invalidate(18, format = $$props.format);
		if ('include_sources' in $$props) $$invalidate(8, include_sources = $$props.include_sources);
		if ('uploading' in $$props) $$invalidate(0, uploading = $$props.uploading);
		if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	return [
		uploading,
		filetype,
		boundedheight,
		center,
		flex,
		file_count,
		root,
		hidden,
		include_sources,
		open_file_upload,
		upload_id,
		file_data,
		hidden_upload,
		updateDragging,
		load_files_from_upload,
		loadFilesFromDrop,
		dragging,
		disable_click,
		format,
		load_files,
		$$scope,
		slots,
		drag_handler,
		dragstart_handler,
		dragend_handler,
		dragover_handler,
		dragenter_handler,
		dragleave_handler,
		drop_handler,
		input_binding
	];
}

class Upload extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				filetype: 1,
				dragging: 16,
				boundedheight: 2,
				center: 3,
				flex: 4,
				file_count: 5,
				disable_click: 17,
				root: 6,
				hidden: 7,
				format: 18,
				include_sources: 8,
				uploading: 0,
				open_file_upload: 9,
				load_files: 19
			},
			null,
			[-1, -1]
		);
	}

	get open_file_upload() {
		return this.$$.ctx[9];
	}

	get load_files() {
		return this.$$.ctx[19];
	}
}

export { Upload as U };
//# sourceMappingURL=Upload-02e4db12.js.map
