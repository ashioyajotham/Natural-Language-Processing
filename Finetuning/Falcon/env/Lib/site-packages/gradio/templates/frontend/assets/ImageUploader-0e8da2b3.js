import './Button-05bf7cea.js';
import { u as uploadToHuggingFace } from './utils-8f25e669.js';
import { B as BlockLabel } from './BlockLabel-09bb0248.js';
import { I as IconButton } from './IconButton-fb69b8dd.js';
import { E as Empty } from './Empty-2eeff83e.js';
import { S as ShareButton } from './ShareButton-b044e1b5.js';
import { D as Download } from './Download-ea83bae3.js';
import './Index-2cec2c56.js';
import { I as Image } from './Image-6cbf81d1.js';
import { n as normalise_file } from './index-5550136d.js';
import { U as Upload$1 } from './Upload-8f4bfd80.js';
import { D as DropdownArrow } from './DropdownArrow-ebaf45e0.js';
import { U as Upload } from './Upload-02e4db12.js';
/* empty css                                                     */import { C as Clear } from './Clear-9760deed.js';

/* home/runner/work/gradio/gradio/js/icons/src/Camera.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$9,
	append: append$7,
	attr: attr$9,
	detach: detach$9,
	init: init$9,
	insert: insert$9,
	noop: noop$7,
	safe_not_equal: safe_not_equal$9,
	svg_element: svg_element$4
} = window.__gradio__svelte__internal;
function create_fragment$9(ctx) {
	let svg;
	let path;
	let circle;

	return {
		c() {
			svg = svg_element$4("svg");
			path = svg_element$4("path");
			circle = svg_element$4("circle");
			attr$9(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
			attr$9(circle, "cx", "12");
			attr$9(circle, "cy", "13");
			attr$9(circle, "r", "4");
			attr$9(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$9(svg, "width", "100%");
			attr$9(svg, "height", "100%");
			attr$9(svg, "viewBox", "0 0 24 24");
			attr$9(svg, "fill", "none");
			attr$9(svg, "stroke", "currentColor");
			attr$9(svg, "stroke-width", "1.5");
			attr$9(svg, "stroke-linecap", "round");
			attr$9(svg, "stroke-linejoin", "round");
			attr$9(svg, "class", "feather feather-camera");
		},
		m(target, anchor) {
			insert$9(target, svg, anchor);
			append$7(svg, path);
			append$7(svg, circle);
		},
		p: noop$7,
		i: noop$7,
		o: noop$7,
		d(detaching) {
			if (detaching) {
				detach$9(svg);
			}
		}
	};
}

class Camera extends SvelteComponent$9 {
	constructor(options) {
		super();
		init$9(this, options, null, create_fragment$9, safe_not_equal$9, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Circle.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$8,
	append: append$6,
	attr: attr$8,
	detach: detach$8,
	init: init$8,
	insert: insert$8,
	noop: noop$6,
	safe_not_equal: safe_not_equal$8,
	svg_element: svg_element$3
} = window.__gradio__svelte__internal;
function create_fragment$8(ctx) {
	let svg;
	let circle;

	return {
		c() {
			svg = svg_element$3("svg");
			circle = svg_element$3("circle");
			attr$8(circle, "cx", "12");
			attr$8(circle, "cy", "12");
			attr$8(circle, "r", "10");
			attr$8(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$8(svg, "width", "100%");
			attr$8(svg, "height", "100%");
			attr$8(svg, "viewBox", "0 0 24 24");
			attr$8(svg, "fill", "red");
			attr$8(svg, "stroke", "red");
			attr$8(svg, "stroke-width", "1.5");
			attr$8(svg, "stroke-linecap", "round");
			attr$8(svg, "stroke-linejoin", "round");
			attr$8(svg, "class", "feather feather-circle");
		},
		m(target, anchor) {
			insert$8(target, svg, anchor);
			append$6(svg, circle);
		},
		p: noop$6,
		i: noop$6,
		o: noop$6,
		d(detaching) {
			if (detaching) {
				detach$8(svg);
			}
		}
	};
}

class Circle extends SvelteComponent$8 {
	constructor(options) {
		super();
		init$8(this, options, null, create_fragment$8, safe_not_equal$8, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/ImagePaste.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$7,
	append: append$5,
	attr: attr$7,
	detach: detach$7,
	init: init$7,
	insert: insert$7,
	noop: noop$5,
	safe_not_equal: safe_not_equal$7,
	svg_element: svg_element$2
} = window.__gradio__svelte__internal;
function create_fragment$7(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element$2("svg");
			path = svg_element$2("path");
			attr$7(path, "fill", "currentColor");
			attr$7(path, "d", "M13.75 2a2.25 2.25 0 0 1 2.236 2.002V4h1.764A2.25 2.25 0 0 1 20 6.25V11h-1.5V6.25a.75.75 0 0 0-.75-.75h-2.129c-.404.603-1.091 1-1.871 1h-3.5c-.78 0-1.467-.397-1.871-1H6.25a.75.75 0 0 0-.75.75v13.5c0 .414.336.75.75.75h4.78a3.99 3.99 0 0 0 .505 1.5H6.25A2.25 2.25 0 0 1 4 19.75V6.25A2.25 2.25 0 0 1 6.25 4h1.764a2.25 2.25 0 0 1 2.236-2h3.5Zm2.245 2.096L16 4.25c0-.052-.002-.103-.005-.154ZM13.75 3.5h-3.5a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5ZM15 12a3 3 0 0 0-3 3v5c0 .556.151 1.077.415 1.524l3.494-3.494a2.25 2.25 0 0 1 3.182 0l3.494 3.494c.264-.447.415-.968.415-1.524v-5a3 3 0 0 0-3-3h-5Zm0 11a2.985 2.985 0 0 1-1.524-.415l3.494-3.494a.75.75 0 0 1 1.06 0l3.494 3.494A2.985 2.985 0 0 1 20 23h-5Zm5-7a1 1 0 1 1 0-2a1 1 0 0 1 0 2Z");
			attr$7(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$7(svg, "width", "100%");
			attr$7(svg, "height", "100%");
			attr$7(svg, "viewBox", "0 0 24 24");
		},
		m(target, anchor) {
			insert$7(target, svg, anchor);
			append$5(svg, path);
		},
		p: noop$5,
		i: noop$5,
		o: noop$5,
		d(detaching) {
			if (detaching) {
				detach$7(svg);
			}
		}
	};
}

class ImagePaste extends SvelteComponent$7 {
	constructor(options) {
		super();
		init$7(this, options, null, create_fragment$7, safe_not_equal$7, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Square.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$6,
	append: append$4,
	attr: attr$6,
	detach: detach$6,
	init: init$6,
	insert: insert$6,
	noop: noop$4,
	safe_not_equal: safe_not_equal$6,
	svg_element: svg_element$1
} = window.__gradio__svelte__internal;
function create_fragment$6(ctx) {
	let svg;
	let rect;

	return {
		c() {
			svg = svg_element$1("svg");
			rect = svg_element$1("rect");
			attr$6(rect, "x", "3");
			attr$6(rect, "y", "3");
			attr$6(rect, "width", "18");
			attr$6(rect, "height", "18");
			attr$6(rect, "rx", "2");
			attr$6(rect, "ry", "2");
			attr$6(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$6(svg, "width", "100%");
			attr$6(svg, "height", "100%");
			attr$6(svg, "viewBox", "0 0 24 24");
			attr$6(svg, "fill", "red");
			attr$6(svg, "stroke", "red");
			attr$6(svg, "stroke-width", "1.5");
			attr$6(svg, "stroke-linecap", "round");
			attr$6(svg, "stroke-linejoin", "round");
			attr$6(svg, "class", "feather feather-square");
		},
		m(target, anchor) {
			insert$6(target, svg, anchor);
			append$4(svg, rect);
		},
		p: noop$4,
		i: noop$4,
		o: noop$4,
		d(detaching) {
			if (detaching) {
				detach$6(svg);
			}
		}
	};
}

class Square extends SvelteComponent$6 {
	constructor(options) {
		super();
		init$6(this, options, null, create_fragment$6, safe_not_equal$6, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Webcam.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$5,
	append: append$3,
	attr: attr$5,
	detach: detach$5,
	init: init$5,
	insert: insert$5,
	noop: noop$3,
	safe_not_equal: safe_not_equal$5,
	svg_element
} = window.__gradio__svelte__internal;
function create_fragment$5(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr$5(path0, "fill", "currentColor");
			attr$5(path0, "d", "M12 2c-4.963 0-9 4.038-9 9c0 3.328 1.82 6.232 4.513 7.79l-2.067 1.378A1 1 0 0 0 6 22h12a1 1 0 0 0 .555-1.832l-2.067-1.378C19.18 17.232 21 14.328 21 11c0-4.962-4.037-9-9-9zm0 16c-3.859 0-7-3.141-7-7c0-3.86 3.141-7 7-7s7 3.14 7 7c0 3.859-3.141 7-7 7z");
			attr$5(path1, "fill", "currentColor");
			attr$5(path1, "d", "M12 6c-2.757 0-5 2.243-5 5s2.243 5 5 5s5-2.243 5-5s-2.243-5-5-5zm0 8c-1.654 0-3-1.346-3-3s1.346-3 3-3s3 1.346 3 3s-1.346 3-3 3z");
			attr$5(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$5(svg, "width", "100%");
			attr$5(svg, "height", "100%");
			attr$5(svg, "viewBox", "0 0 24 24");
		},
		m(target, anchor) {
			insert$5(target, svg, anchor);
			append$3(svg, path0);
			append$3(svg, path1);
		},
		p: noop$3,
		i: noop$3,
		o: noop$3,
		d(detaching) {
			if (detaching) {
				detach$5(svg);
			}
		}
	};
}

let Webcam$2 = class Webcam extends SvelteComponent$5 {
	constructor(options) {
		super();
		init$5(this, options, null, create_fragment$5, safe_not_equal$5, {});
	}
};

/* home/runner/work/gradio/gradio/js/atoms/src/Toolbar.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$4,
	attr: attr$4,
	create_slot: create_slot$1,
	detach: detach$4,
	element: element$4,
	get_all_dirty_from_scope: get_all_dirty_from_scope$1,
	get_slot_changes: get_slot_changes$1,
	init: init$4,
	insert: insert$4,
	safe_not_equal: safe_not_equal$4,
	toggle_class: toggle_class$3,
	transition_in: transition_in$4,
	transition_out: transition_out$4,
	update_slot_base: update_slot_base$1
} = window.__gradio__svelte__internal;
function create_fragment$4(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot$1(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = element$4("div");
			if (default_slot) default_slot.c();
			attr$4(div, "class", "svelte-1geikgz");
			toggle_class$3(div, "show_border", /*show_border*/ ctx[0]);
		},
		m(target, anchor) {
			insert$4(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base$1(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope$1(/*$$scope*/ ctx[1])
						: get_slot_changes$1(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*show_border*/ 1) {
				toggle_class$3(div, "show_border", /*show_border*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in$4(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out$4(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$4(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { show_border = false } = $$props;

	$$self.$$set = $$props => {
		if ('show_border' in $$props) $$invalidate(0, show_border = $$props.show_border);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [show_border, $$scope, slots];
}

class Toolbar extends SvelteComponent$4 {
	constructor(options) {
		super();
		init$4(this, options, instance$4, create_fragment$4, safe_not_equal$4, { show_border: 0 });
	}
}

const get_coordinates_of_clicked_image = (evt) => {
  let image = evt.currentTarget;
  const imageRect = image.getBoundingClientRect();
  const xScale = image.naturalWidth / imageRect.width;
  const yScale = image.naturalHeight / imageRect.height;
  if (xScale > yScale) {
    const displayed_height = image.naturalHeight / xScale;
    const y_offset = (imageRect.height - displayed_height) / 2;
    var x = Math.round((evt.clientX - imageRect.left) * xScale);
    var y = Math.round((evt.clientY - imageRect.top - y_offset) * xScale);
  } else {
    const displayed_width = image.naturalWidth / yScale;
    const x_offset = (imageRect.width - displayed_width) / 2;
    var x = Math.round((evt.clientX - imageRect.left - x_offset) * yScale);
    var y = Math.round((evt.clientY - imageRect.top) * yScale);
  }
  if (x < 0 || x >= image.naturalWidth || y < 0 || y >= image.naturalHeight) {
    return null;
  }
  return [x, y];
};

const ImagePreview_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/image/shared/ImagePreview.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$3,
	append: append$2,
	attr: attr$3,
	bubble: bubble$1,
	check_outros: check_outros$2,
	create_component: create_component$3,
	destroy_component: destroy_component$3,
	detach: detach$3,
	element: element$3,
	empty: empty$2,
	group_outros: group_outros$2,
	init: init$3,
	insert: insert$3,
	listen: listen$2,
	mount_component: mount_component$3,
	safe_not_equal: safe_not_equal$3,
	space: space$2,
	src_url_equal: src_url_equal$1,
	toggle_class: toggle_class$2,
	transition_in: transition_in$3,
	transition_out: transition_out$3
} = window.__gradio__svelte__internal;
const { createEventDispatcher: createEventDispatcher$3 } = window.__gradio__svelte__internal;
function create_else_block$1(ctx) {
	let div;
	let t0;
	let t1;
	let button;
	let img;
	let img_src_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_download_button*/ ctx[3] && create_if_block_2$2(ctx);
	let if_block1 = /*show_share_button*/ ctx[5] && create_if_block_1$2(ctx);

	return {
		c() {
			div = element$3("div");
			if (if_block0) if_block0.c();
			t0 = space$2();
			if (if_block1) if_block1.c();
			t1 = space$2();
			button = element$3("button");
			img = element$3("img");
			attr$3(div, "class", "icon-buttons svelte-1ucs3qg");
			if (!src_url_equal$1(img.src, img_src_value = /*value*/ ctx[0].url)) attr$3(img, "src", img_src_value);
			attr$3(img, "alt", "");
			attr$3(img, "loading", "lazy");
			attr$3(img, "class", "svelte-1ucs3qg");
			toggle_class$2(img, "selectable", /*selectable*/ ctx[4]);
			attr$3(button, "class", "svelte-1ucs3qg");
		},
		m(target, anchor) {
			insert$3(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append$2(div, t0);
			if (if_block1) if_block1.m(div, null);
			insert$3(target, t1, anchor);
			insert$3(target, button, anchor);
			append$2(button, img);
			current = true;

			if (!mounted) {
				dispose = listen$2(button, "click", /*handle_click*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_download_button*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*show_download_button*/ 8) {
						transition_in$3(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in$3(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros$2();

				transition_out$3(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$2();
			}

			if (/*show_share_button*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*show_share_button*/ 32) {
						transition_in$3(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in$3(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros$2();

				transition_out$3(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$2();
			}

			if (!current || dirty & /*value*/ 1 && !src_url_equal$1(img.src, img_src_value = /*value*/ ctx[0].url)) {
				attr$3(img, "src", img_src_value);
			}

			if (!current || dirty & /*selectable*/ 16) {
				toggle_class$2(img, "selectable", /*selectable*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in$3(if_block0);
			transition_in$3(if_block1);
			current = true;
		},
		o(local) {
			transition_out$3(if_block0);
			transition_out$3(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$3(div);
				detach$3(t1);
				detach$3(button);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (25:0) {#if value === null || !value.url}
function create_if_block$2(ctx) {
	let empty_1;
	let current;

	empty_1 = new Empty({
			props: {
				unpadded_box: true,
				size: "large",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component$3(empty_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(empty_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const empty_1_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				empty_1_changes.$$scope = { dirty, ctx };
			}

			empty_1.$set(empty_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$3(empty_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(empty_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(empty_1, detaching);
		}
	};
}

// (29:2) {#if show_download_button}
function create_if_block_2$2(ctx) {
	let a;
	let iconbutton;
	let a_href_value;
	let a_download_value;
	let current;

	iconbutton = new IconButton({
			props: {
				Icon: Download,
				label: /*i18n*/ ctx[6]("common.download")
			}
		});

	return {
		c() {
			a = element$3("a");
			create_component$3(iconbutton.$$.fragment);
			attr$3(a, "href", a_href_value = /*value*/ ctx[0].url);
			attr$3(a, "target", window.__is_colab__ ? "_blank" : null);
			attr$3(a, "download", a_download_value = /*value*/ ctx[0].orig_name || "image");
		},
		m(target, anchor) {
			insert$3(target, a, anchor);
			mount_component$3(iconbutton, a, null);
			current = true;
		},
		p(ctx, dirty) {
			const iconbutton_changes = {};
			if (dirty & /*i18n*/ 64) iconbutton_changes.label = /*i18n*/ ctx[6]("common.download");
			iconbutton.$set(iconbutton_changes);

			if (!current || dirty & /*value*/ 1 && a_href_value !== (a_href_value = /*value*/ ctx[0].url)) {
				attr$3(a, "href", a_href_value);
			}

			if (!current || dirty & /*value*/ 1 && a_download_value !== (a_download_value = /*value*/ ctx[0].orig_name || "image")) {
				attr$3(a, "download", a_download_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$3(iconbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(iconbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$3(a);
			}

			destroy_component$3(iconbutton);
		}
	};
}

// (38:2) {#if show_share_button}
function create_if_block_1$2(ctx) {
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[6],
				formatter: /*func*/ ctx[8],
				value: /*value*/ ctx[0]
			}
		});

	sharebutton.$on("share", /*share_handler*/ ctx[9]);
	sharebutton.$on("error", /*error_handler*/ ctx[10]);

	return {
		c() {
			create_component$3(sharebutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(sharebutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty & /*i18n*/ 64) sharebutton_changes.i18n = /*i18n*/ ctx[6];
			if (dirty & /*value*/ 1) sharebutton_changes.value = /*value*/ ctx[0];
			sharebutton.$set(sharebutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$3(sharebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(sharebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(sharebutton, detaching);
		}
	};
}

// (26:1) <Empty unpadded_box={true} size="large">
function create_default_slot$1(ctx) {
	let image;
	let current;
	image = new Image({});

	return {
		c() {
			create_component$3(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(image, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$3(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(image, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[2],
				Icon: Image,
				label: /*label*/ ctx[1] || /*i18n*/ ctx[6]("image.image")
			}
		});

	const if_block_creators = [create_if_block$2, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[0] === null || !/*value*/ ctx[0].url) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component$3(blocklabel.$$.fragment);
			t = space$2();
			if_block.c();
			if_block_anchor = empty$2();
		},
		m(target, anchor) {
			mount_component$3(blocklabel, target, anchor);
			insert$3(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert$3(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const blocklabel_changes = {};
			if (dirty & /*show_label*/ 4) blocklabel_changes.show_label = /*show_label*/ ctx[2];
			if (dirty & /*label, i18n*/ 66) blocklabel_changes.label = /*label*/ ctx[1] || /*i18n*/ ctx[6]("image.image");
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$2();

				transition_out$3(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$2();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in$3(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$3(blocklabel.$$.fragment, local);
			transition_in$3(if_block);
			current = true;
		},
		o(local) {
			transition_out$3(blocklabel.$$.fragment, local);
			transition_out$3(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$3(t);
				detach$3(if_block_anchor);
			}

			destroy_component$3(blocklabel, detaching);
			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { value } = $$props;
	let { label = undefined } = $$props;
	let { show_label } = $$props;
	let { show_download_button = true } = $$props;
	let { selectable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { i18n } = $$props;
	const dispatch = createEventDispatcher$3();

	const handle_click = evt => {
		let coordinates = get_coordinates_of_clicked_image(evt);

		if (coordinates) {
			dispatch("select", { index: coordinates, value: null });
		}
	};

	const func = async value => {
		if (!value) return "";
		let url = await uploadToHuggingFace(value, "base64");
		return `<img src="${url}" />`;
	};

	function share_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	function error_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
		if ('show_download_button' in $$props) $$invalidate(3, show_download_button = $$props.show_download_button);
		if ('selectable' in $$props) $$invalidate(4, selectable = $$props.selectable);
		if ('show_share_button' in $$props) $$invalidate(5, show_share_button = $$props.show_share_button);
		if ('i18n' in $$props) $$invalidate(6, i18n = $$props.i18n);
	};

	return [
		value,
		label,
		show_label,
		show_download_button,
		selectable,
		show_share_button,
		i18n,
		handle_click,
		func,
		share_handler,
		error_handler
	];
}

class ImagePreview extends SvelteComponent$3 {
	constructor(options) {
		super();

		init$3(this, options, instance$3, create_fragment$3, safe_not_equal$3, {
			value: 0,
			label: 1,
			show_label: 2,
			show_download_button: 3,
			selectable: 4,
			show_share_button: 5,
			i18n: 6
		});
	}
}

const StaticImage = ImagePreview;

const Webcam_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/image/shared/Webcam.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$2,
	action_destroyer,
	append: append$1,
	attr: attr$2,
	binding_callbacks: binding_callbacks$1,
	check_outros: check_outros$1,
	create_component: create_component$2,
	destroy_component: destroy_component$2,
	destroy_each: destroy_each$1,
	detach: detach$2,
	element: element$2,
	empty: empty$1,
	ensure_array_like: ensure_array_like$1,
	group_outros: group_outros$1,
	init: init$2,
	insert: insert$2,
	is_function,
	listen: listen$1,
	mount_component: mount_component$2,
	noop: noop$2,
	run_all,
	safe_not_equal: safe_not_equal$2,
	set_data,
	space: space$1,
	stop_propagation,
	text,
	toggle_class: toggle_class$1,
	transition_in: transition_in$2,
	transition_out: transition_out$2
} = window.__gradio__svelte__internal;
const { createEventDispatcher: createEventDispatcher$2, onMount, tick: tick$1 } = window.__gradio__svelte__internal;
function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	return child_ctx;
}

// (148:1) {#if !streaming}
function create_if_block$1(ctx) {
	let div;
	let button;
	let current_block_type_index;
	let if_block0;
	let button_aria_label_value;
	let t;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_3$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[1] === "video") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = !/*recording*/ ctx[5] && create_if_block_1$1(ctx);

	return {
		c() {
			div = element$2("div");
			button = element$2("button");
			if_block0.c();
			t = space$1();
			if (if_block1) if_block1.c();

			attr$2(button, "aria-label", button_aria_label_value = /*mode*/ ctx[1] === "image"
			? "capture photo"
			: "start recording");

			attr$2(button, "class", "svelte-5ln13g");
			attr$2(div, "class", "button-wrap svelte-5ln13g");
			toggle_class$1(div, "capture", !/*recording*/ ctx[5]);
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			append$1(div, button);
			if_blocks[current_block_type_index].m(button, null);
			append$1(div, t);
			if (if_block1) if_block1.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen$1(button, "click", function () {
					if (is_function(/*mode*/ ctx[1] === "image"
					? /*take_picture*/ ctx[8]
					: /*take_recording*/ ctx[9])) (/*mode*/ ctx[1] === "image"
					? /*take_picture*/ ctx[8]
					: /*take_recording*/ ctx[9]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$1();

				transition_out$2(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$1();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in$2(if_block0, 1);
				if_block0.m(button, null);
			}

			if (!current || dirty & /*mode*/ 2 && button_aria_label_value !== (button_aria_label_value = /*mode*/ ctx[1] === "image"
			? "capture photo"
			: "start recording")) {
				attr$2(button, "aria-label", button_aria_label_value);
			}

			if (!/*recording*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*recording*/ 32) {
						transition_in$2(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in$2(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros$1();

				transition_out$2(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$1();
			}

			if (!current || dirty & /*recording*/ 32) {
				toggle_class$1(div, "capture", !/*recording*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(if_block0);
			transition_in$2(if_block1);
			current = true;
		},
		o(local) {
			transition_out$2(if_block0);
			transition_out$2(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (164:4) {:else}
function create_else_block_1(ctx) {
	let div;
	let camera;
	let current;
	camera = new Camera({});

	return {
		c() {
			div = element$2("div");
			create_component$2(camera.$$.fragment);
			attr$2(div, "class", "icon svelte-5ln13g");
			attr$2(div, "title", "capture photo");
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			mount_component$2(camera, div, null);
			current = true;
		},
		p: noop$2,
		i(local) {
			if (current) return;
			transition_in$2(camera.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(camera.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			destroy_component$2(camera);
		}
	};
}

// (154:4) {#if mode === "video"}
function create_if_block_3$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_4$1, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*recording*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert$2(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros$1();

				transition_out$2(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$1();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in$2(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(if_block);
			current = true;
		},
		o(local) {
			transition_out$2(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (159:5) {:else}
function create_else_block(ctx) {
	let div;
	let circle;
	let current;
	circle = new Circle({});

	return {
		c() {
			div = element$2("div");
			create_component$2(circle.$$.fragment);
			attr$2(div, "class", "icon svelte-5ln13g");
			attr$2(div, "title", "start recording");
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			mount_component$2(circle, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$2(circle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(circle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			destroy_component$2(circle);
		}
	};
}

// (155:5) {#if recording}
function create_if_block_4$1(ctx) {
	let div;
	let square;
	let current;
	square = new Square({});

	return {
		c() {
			div = element$2("div");
			create_component$2(square.$$.fragment);
			attr$2(div, "class", "icon svelte-5ln13g");
			attr$2(div, "title", "stop recording");
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			mount_component$2(square, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$2(square.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(square.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			destroy_component$2(square);
		}
	};
}

// (171:3) {#if !recording}
function create_if_block_1$1(ctx) {
	let button;
	let div;
	let dropdownarrow;
	let t;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;
	dropdownarrow = new DropdownArrow({});
	let if_block = /*options_open*/ ctx[7] && create_if_block_2$1(ctx);

	return {
		c() {
			button = element$2("button");
			div = element$2("div");
			create_component$2(dropdownarrow.$$.fragment);
			t = space$1();
			if (if_block) if_block.c();
			attr$2(div, "class", "icon svelte-5ln13g");
			attr$2(div, "title", "select video source");

			attr$2(button, "aria-label", button_aria_label_value = /*mode*/ ctx[1] === "image"
			? "capture photo"
			: "start recording");

			attr$2(button, "class", "svelte-5ln13g");
		},
		m(target, anchor) {
			insert$2(target, button, anchor);
			append$1(button, div);
			mount_component$2(dropdownarrow, div, null);
			append$1(button, t);
			if (if_block) if_block.m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen$1(button, "click", /*select_source*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*options_open*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*options_open*/ 128) {
						transition_in$2(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					transition_in$2(if_block, 1);
					if_block.m(button, null);
				}
			} else if (if_block) {
				group_outros$1();

				transition_out$2(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros$1();
			}

			if (!current || dirty & /*mode*/ 2 && button_aria_label_value !== (button_aria_label_value = /*mode*/ ctx[1] === "image"
			? "capture photo"
			: "start recording")) {
				attr$2(button, "aria-label", button_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(dropdownarrow.$$.fragment, local);
			transition_in$2(if_block);
			current = true;
		},
		o(local) {
			transition_out$2(dropdownarrow.$$.fragment, local);
			transition_out$2(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(button);
			}

			destroy_component$2(dropdownarrow);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (180:5) {#if options_open}
function create_if_block_2$1(ctx) {
	let div;
	let span;
	let dropdownarrow;
	let t;
	let current;
	let mounted;
	let dispose;
	dropdownarrow = new DropdownArrow({});
	let each_value = ensure_array_like$1(/*video_sources*/ ctx[6]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			div = element$2("div");
			span = element$2("span");
			create_component$2(dropdownarrow.$$.fragment);
			t = space$1();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr$2(span, "class", "inset-icon svelte-5ln13g");
			attr$2(div, "class", "select-wrap svelte-5ln13g");
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			append$1(div, span);
			mount_component$2(dropdownarrow, span, null);
			append$1(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen$1(span, "click", stop_propagation(/*click_handler*/ ctx[17])),
					action_destroyer(click_outside.call(null, div, /*handle_click_outside*/ ctx[12]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*selectVideoSource, video_sources*/ 2112) {
				each_value = ensure_array_like$1(/*video_sources*/ ctx[6]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(dropdownarrow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(dropdownarrow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			destroy_component$2(dropdownarrow);
			destroy_each$1(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (190:7) {#each video_sources as source}
function create_each_block$1(ctx) {
	let div;
	let t0_value = /*source*/ ctx[27].label + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[18](/*source*/ ctx[27]);
	}

	return {
		c() {
			div = element$2("div");
			t0 = text(t0_value);
			t1 = space$1();
			attr$2(div, "class", "svelte-5ln13g");
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			append$1(div, t0);
			append$1(div, t1);

			if (!mounted) {
				dispose = listen$1(div, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*video_sources*/ 64 && t0_value !== (t0_value = /*source*/ ctx[27].label + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let video;
	let t;
	let current;
	let if_block = !/*streaming*/ ctx[0] && create_if_block$1(ctx);

	return {
		c() {
			div = element$2("div");
			video = element$2("video");
			t = space$1();
			if (if_block) if_block.c();
			attr$2(video, "class", "svelte-5ln13g");
			toggle_class$1(video, "flip", /*mirror_webcam*/ ctx[2]);
			attr$2(div, "class", "wrap svelte-5ln13g");
		},
		m(target, anchor) {
			insert$2(target, div, anchor);
			append$1(div, video);
			/*video_binding*/ ctx[16](video);
			append$1(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*mirror_webcam*/ 4) {
				toggle_class$1(video, "flip", /*mirror_webcam*/ ctx[2]);
			}

			if (!/*streaming*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*streaming*/ 1) {
						transition_in$2(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in$2(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros$1();

				transition_out$2(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(if_block);
			current = true;
		},
		o(local) {
			transition_out$2(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$2(div);
			}

			/*video_binding*/ ctx[16](null);
			if (if_block) if_block.d();
		}
	};
}

function click_outside(node, cb) {
	const handle_click = event => {
		if (node && !node.contains(event.target) && !event.defaultPrevented) {
			cb(event);
		}
	};

	document.addEventListener("click", handle_click, true);

	return {
		destroy() {
			document.removeEventListener("click", handle_click, true);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let video_source;
	let canvas;
	let { streaming = false } = $$props;
	let { pending = false } = $$props;
	let { mode = "image" } = $$props;
	let { mirror_webcam } = $$props;
	let { include_audio } = $$props;
	let { i18n } = $$props;
	const dispatch = createEventDispatcher$2();
	onMount(() => canvas = document.createElement("canvas"));

	const size = {
		width: { ideal: 1920 },
		height: { ideal: 1440 }
	};

	async function access_webcam(device_id) {
		if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
			dispatch("error", i18n("image.no_webcam_support"));
			return;
		}

		try {
			stream = await navigator.mediaDevices.getUserMedia({
				video: device_id
				? { deviceId: { exact: device_id }, ...size }
				: size,
				audio: include_audio
			});

			$$invalidate(4, video_source.srcObject = stream, video_source);
			$$invalidate(4, video_source.muted = true, video_source);
			video_source.play();
		} catch(err) {
			if (err instanceof DOMException && err.name == "NotAllowedError") {
				dispatch("error", i18n("image.allow_webcam_access"));
			} else {
				throw err;
			}
		}
	}

	function take_picture() {
		var context = canvas.getContext("2d");

		if (video_source.videoWidth && video_source.videoHeight) {
			canvas.width = video_source.videoWidth;
			canvas.height = video_source.videoHeight;
			context.drawImage(video_source, 0, 0, video_source.videoWidth, video_source.videoHeight);

			if (mirror_webcam) {
				context.scale(-1, 1);
				context.drawImage(video_source, -video_source.videoWidth, 0);
			}

			canvas.toBlob(
				blob => {
					dispatch(streaming ? "stream" : "capture", blob);
				},
				"image/png",
				0.8
			);
		}
	}

	let recording = false;
	let recorded_blobs = [];
	let stream;
	let mimeType;
	let media_recorder;

	function take_recording() {
		if (recording) {
			media_recorder.stop();
			let video_blob = new Blob(recorded_blobs, { type: mimeType });
			let ReaderObj = new FileReader();

			ReaderObj.onload = function (e) {
				if (e.target) {
					dispatch("capture", {
						//@ts-ignore
						data: e.target.result,
						name: "sample." + mimeType.substring(6),
						is_example: false,
						is_file: false
					});

					dispatch("stop_recording");
				}
			};

			ReaderObj.readAsDataURL(video_blob);
		} else {
			dispatch("start_recording");
			recorded_blobs = [];
			let validMimeTypes = ["video/webm", "video/mp4"];

			for (let validMimeType of validMimeTypes) {
				if (MediaRecorder.isTypeSupported(validMimeType)) {
					mimeType = validMimeType;
					break;
				}
			}

			if (mimeType === null) {
				console.error("No supported MediaRecorder mimeType");
				return;
			}

			media_recorder = new MediaRecorder(stream, { mimeType });

			media_recorder.addEventListener("dataavailable", function (e) {
				recorded_blobs.push(e.data);
			});

			media_recorder.start(200);
		}

		$$invalidate(5, recording = !recording);
	}

	access_webcam();

	if (streaming && mode === "image") {
		window.setInterval(
			() => {
				if (video_source && !pending) {
					take_picture();
				}
			},
			500
		);
	}

	async function select_source() {
		const devices = await navigator.mediaDevices.enumerateDevices();
		$$invalidate(6, video_sources = devices.filter(device => device.kind === "videoinput"));
		$$invalidate(7, options_open = true);
	}

	let video_sources = [];

	async function selectVideoSource(device_id) {
		await access_webcam(device_id);
		$$invalidate(7, options_open = false);
	}

	let options_open = false;

	function handle_click_outside(event) {
		event.preventDefault();
		event.stopPropagation();
		$$invalidate(7, options_open = false);
	}

	function video_binding($$value) {
		binding_callbacks$1[$$value ? 'unshift' : 'push'](() => {
			video_source = $$value;
			$$invalidate(4, video_source);
		});
	}

	const click_handler = () => $$invalidate(7, options_open = false);
	const click_handler_1 = source => selectVideoSource(source.deviceId);

	$$self.$$set = $$props => {
		if ('streaming' in $$props) $$invalidate(0, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(13, pending = $$props.pending);
		if ('mode' in $$props) $$invalidate(1, mode = $$props.mode);
		if ('mirror_webcam' in $$props) $$invalidate(2, mirror_webcam = $$props.mirror_webcam);
		if ('include_audio' in $$props) $$invalidate(14, include_audio = $$props.include_audio);
		if ('i18n' in $$props) $$invalidate(15, i18n = $$props.i18n);
	};

	return [
		streaming,
		mode,
		mirror_webcam,
		click_outside,
		video_source,
		recording,
		video_sources,
		options_open,
		take_picture,
		take_recording,
		select_source,
		selectVideoSource,
		handle_click_outside,
		pending,
		include_audio,
		i18n,
		video_binding,
		click_handler,
		click_handler_1
	];
}

class Webcam extends SvelteComponent$2 {
	constructor(options) {
		super();

		init$2(this, options, instance$2, create_fragment$2, safe_not_equal$2, {
			streaming: 0,
			pending: 13,
			mode: 1,
			mirror_webcam: 2,
			include_audio: 14,
			i18n: 15,
			click_outside: 3
		});
	}

	get click_outside() {
		return click_outside;
	}
}

const Webcam$1 = Webcam;

const ClearImage_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/image/shared/ClearImage.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$1,
	attr: attr$1,
	create_component: create_component$1,
	destroy_component: destroy_component$1,
	detach: detach$1,
	element: element$1,
	init: init$1,
	insert: insert$1,
	mount_component: mount_component$1,
	noop: noop$1,
	safe_not_equal: safe_not_equal$1,
	transition_in: transition_in$1,
	transition_out: transition_out$1
} = window.__gradio__svelte__internal;
const { createEventDispatcher: createEventDispatcher$1 } = window.__gradio__svelte__internal;
function create_fragment$1(ctx) {
	let div;
	let iconbutton;
	let current;

	iconbutton = new IconButton({
			props: { Icon: Clear, label: "Remove Image" }
		});

	iconbutton.$on("click", /*click_handler*/ ctx[1]);

	return {
		c() {
			div = element$1("div");
			create_component$1(iconbutton.$$.fragment);
			attr$1(div, "class", "svelte-s6ybro");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			mount_component$1(iconbutton, div, null);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in$1(iconbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(iconbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			destroy_component$1(iconbutton);
		}
	};
}

function instance$1($$self) {
	const dispatch = createEventDispatcher$1();

	const click_handler = event => {
		dispatch("remove_image");
		event.stopPropagation();
	};

	return [dispatch, click_handler];
}

class ClearImage extends SvelteComponent$1 {
	constructor(options) {
		super();
		init$1(this, options, instance$1, create_fragment$1, safe_not_equal$1, {});
	}
}

const ImageUploader_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/image/shared/ImageUploader.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	create_slot,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	ensure_array_like,
	get_all_dirty_from_scope,
	get_slot_changes,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	safe_not_equal,
	space,
	src_url_equal,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} = window.__gradio__svelte__internal;
const { createEventDispatcher, tick } = window.__gradio__svelte__internal;
function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[34] = list[i];
	return child_ctx;
}

// (112:1) {#if value?.url}
function create_if_block_4(ctx) {
	let clearimage;
	let current;
	clearimage = new ClearImage({});
	clearimage.$on("remove_image", /*remove_image_handler*/ ctx[22]);

	return {
		c() {
			create_component(clearimage.$$.fragment);
		},
		m(target, anchor) {
			mount_component(clearimage, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(clearimage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(clearimage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(clearimage, detaching);
		}
	};
}

// (132:3) {#if value === null && !active_tool}
function create_if_block_3(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[33], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[33],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[33])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[33], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (121:2) <Upload    hidden={value !== null || active_tool === "webcam"}    bind:this={upload}    bind:uploading    bind:dragging    filetype="image/*"    on:load={handle_upload}    on:error    {root}    disable_click={!sources.includes("upload")}   >
function create_default_slot_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*value*/ ctx[0] === null && !/*active_tool*/ ctx[1] && create_if_block_3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*value*/ ctx[0] === null && !/*active_tool*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*value, active_tool*/ 3) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (149:41) 
function create_if_block_2(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*value*/ ctx[0].url)) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*value*/ ctx[0].alt_text);
			attr(img, "class", "svelte-1or8coj");
			toggle_class(img, "selectable", /*selectable*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "click", /*handle_click*/ ctx[17]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(img.src, img_src_value = /*value*/ ctx[0].url)) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*value*/ 1 && img_alt_value !== (img_alt_value = /*value*/ ctx[0].alt_text)) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty[0] & /*selectable*/ 128) {
				toggle_class(img, "selectable", /*selectable*/ ctx[7]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (136:2) {#if active_tool === "webcam"}
function create_if_block_1(ctx) {
	let webcam;
	let current;

	webcam = new Webcam$1({
			props: {
				mirror_webcam: /*mirror_webcam*/ ctx[6],
				streaming: /*streaming*/ ctx[5],
				mode: "image",
				include_audio: false,
				i18n: /*i18n*/ ctx[9]
			}
		});

	webcam.$on("capture", /*capture_handler*/ ctx[27]);
	webcam.$on("stream", /*stream_handler*/ ctx[28]);
	webcam.$on("error", /*error_handler_1*/ ctx[29]);
	webcam.$on("drag", /*drag_handler*/ ctx[30]);
	webcam.$on("upload", /*upload_handler*/ ctx[31]);

	return {
		c() {
			create_component(webcam.$$.fragment);
		},
		m(target, anchor) {
			mount_component(webcam, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const webcam_changes = {};
			if (dirty[0] & /*mirror_webcam*/ 64) webcam_changes.mirror_webcam = /*mirror_webcam*/ ctx[6];
			if (dirty[0] & /*streaming*/ 32) webcam_changes.streaming = /*streaming*/ ctx[5];
			if (dirty[0] & /*i18n*/ 512) webcam_changes.i18n = /*i18n*/ ctx[9];
			webcam.$set(webcam_changes);
		},
		i(local) {
			if (current) return;
			transition_in(webcam.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(webcam.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(webcam, detaching);
		}
	};
}

// (160:1) {#if sources.length > 1 || sources.includes("clipboard")}
function create_if_block(ctx) {
	let toolbar;
	let current;

	toolbar = new Toolbar({
			props: {
				show_border: !/*value*/ ctx[0]?.url,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(toolbar.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbar_changes = {};
			if (dirty[0] & /*value*/ 1) toolbar_changes.show_border = !/*value*/ ctx[0]?.url;

			if (dirty[0] & /*sources_list*/ 8192 | dirty[1] & /*$$scope*/ 4) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbar, detaching);
		}
	};
}

// (162:3) {#each sources_list as source}
function create_each_block(ctx) {
	let iconbutton;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[32](/*source*/ ctx[34]);
	}

	iconbutton = new IconButton({
			props: {
				Icon: /*sources_meta*/ ctx[18][/*source*/ ctx[34]].icon,
				size: "large",
				label: "" + (/*source*/ ctx[34] + "-image-toolbar-btn"),
				padded: false
			}
		});

	iconbutton.$on("click", click_handler);

	return {
		c() {
			create_component(iconbutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const iconbutton_changes = {};
			if (dirty[0] & /*sources_list*/ 8192) iconbutton_changes.Icon = /*sources_meta*/ ctx[18][/*source*/ ctx[34]].icon;
			if (dirty[0] & /*sources_list*/ 8192) iconbutton_changes.label = "" + (/*source*/ ctx[34] + "-image-toolbar-btn");
			iconbutton.$set(iconbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconbutton, detaching);
		}
	};
}

// (161:2) <Toolbar show_border={!value?.url}>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(/*sources_list*/ ctx[13]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*sources_meta, sources_list, handle_toolbar*/ 794624) {
				each_value = ensure_array_like(/*sources_list*/ ctx[13]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment(ctx) {
	let blocklabel;
	let t0;
	let div1;
	let t1;
	let div0;
	let upload_1;
	let updating_uploading;
	let updating_dragging;
	let t2;
	let current_block_type_index;
	let if_block1;
	let t3;
	let show_if = /*sources*/ ctx[4].length > 1 || /*sources*/ ctx[4].includes("clipboard");
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[3],
				Icon: Image,
				label: /*label*/ ctx[2] || "Image"
			}
		});

	let if_block0 = /*value*/ ctx[0]?.url && create_if_block_4(ctx);

	function upload_1_uploading_binding(value) {
		/*upload_1_uploading_binding*/ ctx[24](value);
	}

	function upload_1_dragging_binding(value) {
		/*upload_1_dragging_binding*/ ctx[25](value);
	}

	let upload_1_props = {
		hidden: /*value*/ ctx[0] !== null || /*active_tool*/ ctx[1] === "webcam",
		filetype: "image/*",
		root: /*root*/ ctx[8],
		disable_click: !/*sources*/ ctx[4].includes("upload"),
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	if (/*uploading*/ ctx[10] !== void 0) {
		upload_1_props.uploading = /*uploading*/ ctx[10];
	}

	if (/*dragging*/ ctx[11] !== void 0) {
		upload_1_props.dragging = /*dragging*/ ctx[11];
	}

	upload_1 = new Upload({ props: upload_1_props });
	/*upload_1_binding*/ ctx[23](upload_1);
	binding_callbacks.push(() => bind(upload_1, 'uploading', upload_1_uploading_binding));
	binding_callbacks.push(() => bind(upload_1, 'dragging', upload_1_dragging_binding));
	upload_1.$on("load", /*handle_upload*/ ctx[14]);
	upload_1.$on("error", /*error_handler*/ ctx[26]);
	const if_block_creators = [create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*active_tool*/ ctx[1] === "webcam") return 0;
		if (/*value*/ ctx[0] !== null && !/*streaming*/ ctx[5]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block2 = show_if && create_if_block(ctx);

	return {
		c() {
			create_component(blocklabel.$$.fragment);
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			div0 = element("div");
			create_component(upload_1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			attr(div0, "class", "upload-container svelte-1or8coj");
			attr(div1, "data-testid", "image");
			attr(div1, "class", "image-container svelte-1or8coj");
		},
		m(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);
			append(div1, div0);
			mount_component(upload_1, div0, null);
			append(div0, t2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div0, null);
			}

			append(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 8) blocklabel_changes.show_label = /*show_label*/ ctx[3];
			if (dirty[0] & /*label*/ 4) blocklabel_changes.label = /*label*/ ctx[2] || "Image";
			blocklabel.$set(blocklabel_changes);

			if (/*value*/ ctx[0]?.url) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*value*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const upload_1_changes = {};
			if (dirty[0] & /*value, active_tool*/ 3) upload_1_changes.hidden = /*value*/ ctx[0] !== null || /*active_tool*/ ctx[1] === "webcam";
			if (dirty[0] & /*root*/ 256) upload_1_changes.root = /*root*/ ctx[8];
			if (dirty[0] & /*sources*/ 16) upload_1_changes.disable_click = !/*sources*/ ctx[4].includes("upload");

			if (dirty[0] & /*value, active_tool*/ 3 | dirty[1] & /*$$scope*/ 4) {
				upload_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_uploading && dirty[0] & /*uploading*/ 1024) {
				updating_uploading = true;
				upload_1_changes.uploading = /*uploading*/ ctx[10];
				add_flush_callback(() => updating_uploading = false);
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 2048) {
				updating_dragging = true;
				upload_1_changes.dragging = /*dragging*/ ctx[11];
				add_flush_callback(() => updating_dragging = false);
			}

			upload_1.$set(upload_1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div0, null);
				} else {
					if_block1 = null;
				}
			}

			if (dirty[0] & /*sources*/ 16) show_if = /*sources*/ ctx[4].length > 1 || /*sources*/ ctx[4].includes("clipboard");

			if (show_if) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*sources*/ 16) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block0);
			transition_in(upload_1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block0);
			transition_out(upload_1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(div1);
			}

			destroy_component(blocklabel, detaching);
			if (if_block0) if_block0.d();
			/*upload_1_binding*/ ctx[23](null);
			destroy_component(upload_1);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block2) if_block2.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let sources_list;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value } = $$props;
	let { label = undefined } = $$props;
	let { show_label } = $$props;
	let { sources = ["upload", "clipboard", "webcam"] } = $$props;
	let { streaming = false } = $$props;
	let { pending = false } = $$props;
	let { mirror_webcam } = $$props;
	let { selectable = false } = $$props;
	let { root } = $$props;
	let { i18n } = $$props;
	let upload;
	let uploading = false;
	let { active_tool = null } = $$props;

	function handle_upload({ detail }) {
		$$invalidate(0, value = normalise_file(detail, root, null));
		dispatch("upload");
	}

	async function handle_save(img_blob) {
		$$invalidate(20, pending = true);
		const f = await upload.load_files([new File([img_blob], `webcam.png`)]);
		$$invalidate(0, value = f?.[0] || null);
		if (!streaming) $$invalidate(1, active_tool = null);
		await tick();
		dispatch(streaming ? "stream" : "change");
		$$invalidate(20, pending = false);
	}

	const dispatch = createEventDispatcher();
	let dragging = false;

	function handle_click(evt) {
		let coordinates = get_coordinates_of_clicked_image(evt);

		if (coordinates) {
			dispatch("select", { index: coordinates, value: null });
		}
	}

	const sources_meta = {
		upload: {
			icon: Upload$1,
			label: i18n("Upload"),
			order: 0
		},
		webcam: {
			icon: Webcam$2,
			label: i18n("Webcam"),
			order: 1
		},
		clipboard: {
			icon: ImagePaste,
			label: i18n("Paste"),
			order: 2
		}
	};

	async function handle_toolbar(source) {
		switch (source) {
			case "clipboard":
				navigator.clipboard.read().then(async items => {
					for (let i = 0; i < items.length; i++) {
						const type = items[i].types.find(t => t.startsWith("image/"));

						if (type) {
							$$invalidate(0, value = null);

							items[i].getType(type).then(async blob => {
								const f = await upload.load_files([new File([blob], `clipboard.${type.replace("image/", "")}`)]);
								$$invalidate(0, value = f?.[0] || null);
							});

							break;
						}
					}
				});
				break;
			case "webcam":
				$$invalidate(1, active_tool = "webcam");
				break;
			case "upload":
				upload.open_file_upload();
				break;
		}
	}

	const remove_image_handler = () => {
		$$invalidate(0, value = null);
		dispatch("clear");
	};

	function upload_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			upload = $$value;
			$$invalidate(12, upload);
		});
	}

	function upload_1_uploading_binding(value) {
		uploading = value;
		$$invalidate(10, uploading);
	}

	function upload_1_dragging_binding(value) {
		dragging = value;
		$$invalidate(11, dragging);
	}

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	const capture_handler = e => handle_save(e.detail);
	const stream_handler = e => handle_save(e.detail);

	function error_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function drag_handler(event) {
		bubble.call(this, $$self, event);
	}

	const upload_handler = e => handle_save(e.detail);
	const click_handler = source => handle_toolbar(source);

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(3, show_label = $$props.show_label);
		if ('sources' in $$props) $$invalidate(4, sources = $$props.sources);
		if ('streaming' in $$props) $$invalidate(5, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(20, pending = $$props.pending);
		if ('mirror_webcam' in $$props) $$invalidate(6, mirror_webcam = $$props.mirror_webcam);
		if ('selectable' in $$props) $$invalidate(7, selectable = $$props.selectable);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
		if ('active_tool' in $$props) $$invalidate(1, active_tool = $$props.active_tool);
		if ('$$scope' in $$props) $$invalidate(33, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*uploading*/ 1024) {
			if (uploading) $$invalidate(0, value = null);
		}

		if ($$self.$$.dirty[0] & /*value, root*/ 257) {
			value && !value.url && $$invalidate(0, value = normalise_file(value, root, null));
		}

		if ($$self.$$.dirty[0] & /*dragging*/ 2048) {
			dispatch("drag", dragging);
		}

		if ($$self.$$.dirty[0] & /*sources*/ 16) {
			$$invalidate(13, sources_list = sources.sort((a, b) => sources_meta[a].order - sources_meta[b].order));
		}

		if ($$self.$$.dirty[0] & /*sources*/ 16) {
			{
				if (sources.length === 1 && sources[0] === "webcam") {
					$$invalidate(1, active_tool = "webcam");
				}
			}
		}
	};

	return [
		value,
		active_tool,
		label,
		show_label,
		sources,
		streaming,
		mirror_webcam,
		selectable,
		root,
		i18n,
		uploading,
		dragging,
		upload,
		sources_list,
		handle_upload,
		handle_save,
		dispatch,
		handle_click,
		sources_meta,
		handle_toolbar,
		pending,
		slots,
		remove_image_handler,
		upload_1_binding,
		upload_1_uploading_binding,
		upload_1_dragging_binding,
		error_handler,
		capture_handler,
		stream_handler,
		error_handler_1,
		drag_handler,
		upload_handler,
		click_handler,
		$$scope
	];
}

class ImageUploader extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 0,
				label: 2,
				show_label: 3,
				sources: 4,
				streaming: 5,
				pending: 20,
				mirror_webcam: 6,
				selectable: 7,
				root: 8,
				i18n: 9,
				active_tool: 1
			},
			null,
			[-1, -1]
		);
	}
}

const ImageUploader$1 = ImageUploader;

export { ImageUploader$1 as I, StaticImage as S, Toolbar as T, Webcam$1 as W, Webcam$2 as a, ImagePaste as b };
//# sourceMappingURL=ImageUploader-0e8da2b3.js.map
