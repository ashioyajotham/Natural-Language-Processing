import { B as Block } from './Button-05bf7cea.js';
import { u as uploadToHuggingFace } from './utils-8f25e669.js';
import { B as BlockLabel } from './BlockLabel-09bb0248.js';
import { I as IconButton } from './IconButton-fb69b8dd.js';
import { E as Empty } from './Empty-2eeff83e.js';
import { S as ShareButton } from './ShareButton-b044e1b5.js';
import { D as Download } from './Download-ea83bae3.js';
import { S as Static } from './Index-2cec2c56.js';
import { a as Play, P as Pause, T as Trim, S as SelectSource } from './SelectSource-a1604b96.js';
import { U as Undo } from './Undo-6c110254.js';
import { r as resolve_wasm_src } from './file-url-1a9970c0.js';
import { _ as __vitePreload, p as prepare_files, u as upload, n as normalise_file } from './index-5550136d.js';
import { U as Upload } from './Upload-02e4db12.js';
import { M as ModifyUpload } from './ModifyUpload-772201f4.js';
import { U as UploadText } from './UploadText-7206a31c.js';
export { default as BaseExample } from './Example-01f23d62.js';
import './Upload-8f4bfd80.js';
import './svelte/svelte.js';
/* empty css                                                     */import './Clear-9760deed.js';

/* home/runner/work/gradio/gradio/js/icons/src/Backward.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$f,
	append: append$b,
	attr: attr$c,
	detach: detach$f,
	init: init$f,
	insert: insert$f,
	noop: noop$a,
	safe_not_equal: safe_not_equal$f,
	svg_element: svg_element$5
} = window.__gradio__svelte__internal;
function create_fragment$f(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element$5("svg");
			path = svg_element$5("path");
			attr$c(path, "stroke", "currentColor");
			attr$c(path, "stroke-width", "1.5");
			attr$c(path, "stroke-linecap", "round");
			attr$c(path, "stroke-linejoin", "round");
			attr$c(path, "d", "M21.044 5.704a.6.6 0 0 1 .956.483v11.626a.6.6 0 0 1-.956.483l-7.889-5.813a.6.6 0 0 1 0-.966l7.89-5.813ZM10.044 5.704a.6.6 0 0 1 .956.483v11.626a.6.6 0 0 1-.956.483l-7.888-5.813a.6.6 0 0 1 0-.966l7.888-5.813Z");
			attr$c(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$c(svg, "width", "24px");
			attr$c(svg, "height", "24px");
			attr$c(svg, "fill", "currentColor");
			attr$c(svg, "stroke-width", "1.5");
			attr$c(svg, "viewBox", "0 0 24 24");
			attr$c(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$f(target, svg, anchor);
			append$b(svg, path);
		},
		p: noop$a,
		i: noop$a,
		o: noop$a,
		d(detaching) {
			if (detaching) {
				detach$f(svg);
			}
		}
	};
}

class Backward extends SvelteComponent$f {
	constructor(options) {
		super();
		init$f(this, options, null, create_fragment$f, safe_not_equal$f, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Forward.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$e,
	append: append$a,
	attr: attr$b,
	detach: detach$e,
	init: init$e,
	insert: insert$e,
	noop: noop$9,
	safe_not_equal: safe_not_equal$e,
	svg_element: svg_element$4
} = window.__gradio__svelte__internal;
function create_fragment$e(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element$4("svg");
			path = svg_element$4("path");
			attr$b(path, "stroke", "currentColor");
			attr$b(path, "stroke-width", "1.5");
			attr$b(path, "stroke-linecap", "round");
			attr$b(path, "stroke-linejoin", "round");
			attr$b(path, "d", "M2.956 5.704A.6.6 0 0 0 2 6.187v11.626a.6.6 0 0 0 .956.483l7.889-5.813a.6.6 0 0 0 0-.966l-7.89-5.813ZM13.956 5.704a.6.6 0 0 0-.956.483v11.626a.6.6 0 0 0 .956.483l7.889-5.813a.6.6 0 0 0 0-.966l-7.89-5.813Z");
			attr$b(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$b(svg, "width", "24px");
			attr$b(svg, "height", "24px");
			attr$b(svg, "fill", "currentColor");
			attr$b(svg, "stroke-width", "1.5");
			attr$b(svg, "viewBox", "0 0 24 24");
			attr$b(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$e(target, svg, anchor);
			append$a(svg, path);
		},
		p: noop$9,
		i: noop$9,
		o: noop$9,
		d(detaching) {
			if (detaching) {
				detach$e(svg);
			}
		}
	};
}

class Forward extends SvelteComponent$e {
	constructor(options) {
		super();
		init$e(this, options, null, create_fragment$e, safe_not_equal$e, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Music.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$d,
	append: append$9,
	attr: attr$a,
	detach: detach$d,
	init: init$d,
	insert: insert$d,
	noop: noop$8,
	safe_not_equal: safe_not_equal$d,
	svg_element: svg_element$3
} = window.__gradio__svelte__internal;
function create_fragment$d(ctx) {
	let svg;
	let path;
	let circle0;
	let circle1;

	return {
		c() {
			svg = svg_element$3("svg");
			path = svg_element$3("path");
			circle0 = svg_element$3("circle");
			circle1 = svg_element$3("circle");
			attr$a(path, "d", "M9 18V5l12-2v13");
			attr$a(circle0, "cx", "6");
			attr$a(circle0, "cy", "18");
			attr$a(circle0, "r", "3");
			attr$a(circle1, "cx", "18");
			attr$a(circle1, "cy", "16");
			attr$a(circle1, "r", "3");
			attr$a(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$a(svg, "width", "100%");
			attr$a(svg, "height", "100%");
			attr$a(svg, "viewBox", "0 0 24 24");
			attr$a(svg, "fill", "none");
			attr$a(svg, "stroke", "currentColor");
			attr$a(svg, "stroke-width", "1.5");
			attr$a(svg, "stroke-linecap", "round");
			attr$a(svg, "stroke-linejoin", "round");
			attr$a(svg, "class", "feather feather-music");
		},
		m(target, anchor) {
			insert$d(target, svg, anchor);
			append$9(svg, path);
			append$9(svg, circle0);
			append$9(svg, circle1);
		},
		p: noop$8,
		i: noop$8,
		o: noop$8,
		d(detaching) {
			if (detaching) {
				detach$d(svg);
			}
		}
	};
}

class Music extends SvelteComponent$d {
	constructor(options) {
		super();
		init$d(this, options, null, create_fragment$d, safe_not_equal$d, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/VolumeLow.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$c,
	append: append$8,
	attr: attr$9,
	detach: detach$c,
	init: init$c,
	insert: insert$c,
	noop: noop$7,
	safe_not_equal: safe_not_equal$c,
	svg_element: svg_element$2,
	text: text$7
} = window.__gradio__svelte__internal;
function create_fragment$c(ctx) {
	let svg;
	let title;
	let t;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element$2("svg");
			title = svg_element$2("title");
			t = text$7("Low volume");
			path0 = svg_element$2("path");
			path1 = svg_element$2("path");
			attr$9(path0, "d", "M19.5 7.5C19.5 7.5 21 9 21 11.5C21 14 19.5 15.5 19.5 15.5");
			attr$9(path0, "stroke-width", "1.5");
			attr$9(path0, "stroke-linecap", "round");
			attr$9(path0, "stroke-linejoin", "round");
			attr$9(path1, "d", "M2 13.8571V10.1429C2 9.03829 2.89543 8.14286 4 8.14286H6.9C7.09569 8.14286 7.28708 8.08544 7.45046 7.97772L13.4495 4.02228C14.1144 3.5839 15 4.06075 15 4.85714V19.1429C15 19.9392 14.1144 20.4161 13.4495 19.9777L7.45046 16.0223C7.28708 15.9146 7.09569 15.8571 6.9 15.8571H4C2.89543 15.8571 2 14.9617 2 13.8571Z");
			attr$9(path1, "stroke-width", "1.5");
			attr$9(svg, "width", "24");
			attr$9(svg, "height", "24");
			attr$9(svg, "viewBox", "0 0 24 24");
			attr$9(svg, "stroke-width", "1.5");
			attr$9(svg, "fill", "none");
			attr$9(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$9(svg, "stroke", "currentColor");
			attr$9(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$c(target, svg, anchor);
			append$8(svg, title);
			append$8(title, t);
			append$8(svg, path0);
			append$8(svg, path1);
		},
		p: noop$7,
		i: noop$7,
		o: noop$7,
		d(detaching) {
			if (detaching) {
				detach$c(svg);
			}
		}
	};
}

class VolumeLow extends SvelteComponent$c {
	constructor(options) {
		super();
		init$c(this, options, null, create_fragment$c, safe_not_equal$c, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/VolumeHigh.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$b,
	append: append$7,
	attr: attr$8,
	detach: detach$b,
	init: init$b,
	insert: insert$b,
	noop: noop$6,
	safe_not_equal: safe_not_equal$b,
	svg_element: svg_element$1,
	text: text$6
} = window.__gradio__svelte__internal;
function create_fragment$b(ctx) {
	let svg;
	let title;
	let t;
	let path0;
	let path1;
	let path2;

	return {
		c() {
			svg = svg_element$1("svg");
			title = svg_element$1("title");
			t = text$6("High volume");
			path0 = svg_element$1("path");
			path1 = svg_element$1("path");
			path2 = svg_element$1("path");
			attr$8(path0, "d", "M1 13.8571V10.1429C1 9.03829 1.89543 8.14286 3 8.14286H5.9C6.09569 8.14286 6.28708 8.08544 6.45046 7.97772L12.4495 4.02228C13.1144 3.5839 14 4.06075 14 4.85714V19.1429C14 19.9392 13.1144 20.4161 12.4495 19.9777L6.45046 16.0223C6.28708 15.9146 6.09569 15.8571 5.9 15.8571H3C1.89543 15.8571 1 14.9617 1 13.8571Z");
			attr$8(path0, "stroke-width", "1.5");
			attr$8(path1, "d", "M17.5 7.5C17.5 7.5 19 9 19 11.5C19 14 17.5 15.5 17.5 15.5");
			attr$8(path1, "stroke-width", "1.5");
			attr$8(path1, "stroke-linecap", "round");
			attr$8(path1, "stroke-linejoin", "round");
			attr$8(path2, "d", "M20.5 4.5C20.5 4.5 23 7 23 11.5C23 16 20.5 18.5 20.5 18.5");
			attr$8(path2, "stroke-width", "1.5");
			attr$8(path2, "stroke-linecap", "round");
			attr$8(path2, "stroke-linejoin", "round");
			attr$8(svg, "width", "24");
			attr$8(svg, "height", "24");
			attr$8(svg, "viewBox", "0 0 24 24");
			attr$8(svg, "stroke-width", "1.5");
			attr$8(svg, "fill", "none");
			attr$8(svg, "stroke", "currentColor");
			attr$8(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$8(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$b(target, svg, anchor);
			append$7(svg, title);
			append$7(title, t);
			append$7(svg, path0);
			append$7(svg, path1);
			append$7(svg, path2);
		},
		p: noop$6,
		i: noop$6,
		o: noop$6,
		d(detaching) {
			if (detaching) {
				detach$b(svg);
			}
		}
	};
}

class VolumeHigh extends SvelteComponent$b {
	constructor(options) {
		super();
		init$b(this, options, null, create_fragment$b, safe_not_equal$b, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/VolumeMuted.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$a,
	append: append$6,
	attr: attr$7,
	detach: detach$a,
	init: init$a,
	insert: insert$a,
	noop: noop$5,
	safe_not_equal: safe_not_equal$a,
	svg_element,
	text: text$5
} = window.__gradio__svelte__internal;
function create_fragment$a(ctx) {
	let svg;
	let title;
	let t;
	let g;
	let path0;
	let path1;
	let defs;
	let clipPath;
	let rect;

	return {
		c() {
			svg = svg_element("svg");
			title = svg_element("title");
			t = text$5("Muted volume");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			defs = svg_element("defs");
			clipPath = svg_element("clipPath");
			rect = svg_element("rect");
			attr$7(path0, "d", "M18 14L20.0005 12M22 10L20.0005 12M20.0005 12L18 10M20.0005 12L22 14");
			attr$7(path0, "stroke-width", "1.5");
			attr$7(path0, "stroke-linecap", "round");
			attr$7(path0, "stroke-linejoin", "round");
			attr$7(path1, "d", "M2 13.8571V10.1429C2 9.03829 2.89543 8.14286 4 8.14286H6.9C7.09569 8.14286 7.28708 8.08544 7.45046 7.97772L13.4495 4.02228C14.1144 3.5839 15 4.06075 15 4.85714V19.1429C15 19.9392 14.1144 20.4161 13.4495 19.9777L7.45046 16.0223C7.28708 15.9146 7.09569 15.8571 6.9 15.8571H4C2.89543 15.8571 2 14.9617 2 13.8571Z");
			attr$7(path1, "stroke-width", "1.5");
			attr$7(g, "clip-path", "url(#clip0_3173_16686)");
			attr$7(rect, "width", "24");
			attr$7(rect, "height", "24");
			attr$7(rect, "fill", "white");
			attr$7(clipPath, "id", "clip0_3173_16686");
			attr$7(svg, "width", "24");
			attr$7(svg, "height", "24");
			attr$7(svg, "viewBox", "0 0 24 24");
			attr$7(svg, "stroke-width", "1.5");
			attr$7(svg, "fill", "none");
			attr$7(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$7(svg, "stroke", "currentColor");
			attr$7(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$a(target, svg, anchor);
			append$6(svg, title);
			append$6(title, t);
			append$6(svg, g);
			append$6(g, path0);
			append$6(g, path1);
			append$6(svg, defs);
			append$6(defs, clipPath);
			append$6(clipPath, rect);
		},
		p: noop$5,
		i: noop$5,
		o: noop$5,
		d(detaching) {
			if (detaching) {
				detach$a(svg);
			}
		}
	};
}

class VolumeMuted extends SvelteComponent$a {
	constructor(options) {
		super();
		init$a(this, options, null, create_fragment$a, safe_not_equal$a, {});
	}
}

var __awaiter$3 = (globalThis && globalThis.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Decode an array buffer into an audio buffer */
function decode(audioData, sampleRate) {
    return __awaiter$3(this, void 0, void 0, function* () {
        const audioCtx = new AudioContext({ sampleRate });
        const decode = audioCtx.decodeAudioData(audioData);
        return decode.finally(() => audioCtx.close());
    });
}
/** Normalize peaks to -1..1 */
function normalize(channelData) {
    const firstChannel = channelData[0];
    if (firstChannel.some((n) => n > 1 || n < -1)) {
        const length = firstChannel.length;
        let max = 0;
        for (let i = 0; i < length; i++) {
            const absN = Math.abs(firstChannel[i]);
            if (absN > max)
                max = absN;
        }
        for (const channel of channelData) {
            for (let i = 0; i < length; i++) {
                channel[i] /= max;
            }
        }
    }
    return channelData;
}
/** Create an audio buffer from pre-decoded audio data */
function createBuffer(channelData, duration) {
    // If a single array of numbers is passed, make it an array of arrays
    if (typeof channelData[0] === 'number')
        channelData = [channelData];
    // Normalize to -1..1
    normalize(channelData);
    return {
        duration,
        length: channelData[0].length,
        sampleRate: channelData[0].length / duration,
        numberOfChannels: channelData.length,
        getChannelData: (i) => channelData === null || channelData === void 0 ? void 0 : channelData[i],
        copyFromChannel: AudioBuffer.prototype.copyFromChannel,
        copyToChannel: AudioBuffer.prototype.copyToChannel,
    };
}
const Decoder = {
    decode,
    createBuffer,
};

var __awaiter$2 = (globalThis && globalThis.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function fetchBlob(url, progressCallback, requestInit) {
    var _a, _b;
    return __awaiter$2(this, void 0, void 0, function* () {
        // Fetch the resource
        const response = yield fetch(url, requestInit);
        // Read the data to track progress
        {
            const reader = (_a = response.clone().body) === null || _a === void 0 ? void 0 : _a.getReader();
            const contentLength = Number((_b = response.headers) === null || _b === void 0 ? void 0 : _b.get('Content-Length'));
            let receivedLength = 0;
            // Process the data
            const processChunk = (done, value) => __awaiter$2(this, void 0, void 0, function* () {
                if (done)
                    return;
                // Add to the received length
                receivedLength += (value === null || value === void 0 ? void 0 : value.length) || 0;
                const percentage = Math.round((receivedLength / contentLength) * 100);
                progressCallback(percentage);
                // Continue reading data
                return reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));
            });
            reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));
        }
        return response.blob();
    });
}
const Fetcher = {
    fetchBlob,
};

/** A simple event emitter that can be used to listen to and emit events. */
class EventEmitter {
    constructor() {
        this.listeners = {};
        /** Subscribe to an event. Returns an unsubscribe function. */
        this.on = this.addEventListener;
        /** Unsubscribe from an event */
        this.un = this.removeEventListener;
    }
    /** Add an event listener */
    addEventListener(event, listener, options) {
        if (!this.listeners[event]) {
            this.listeners[event] = new Set();
        }
        this.listeners[event].add(listener);
        if (options === null || options === void 0 ? void 0 : options.once) {
            const unsubscribeOnce = () => {
                this.removeEventListener(event, unsubscribeOnce);
                this.removeEventListener(event, listener);
            };
            this.addEventListener(event, unsubscribeOnce);
            return unsubscribeOnce;
        }
        return () => this.removeEventListener(event, listener);
    }
    removeEventListener(event, listener) {
        var _a;
        (_a = this.listeners[event]) === null || _a === void 0 ? void 0 : _a.delete(listener);
    }
    /** Subscribe to an event only once */
    once(event, listener) {
        return this.on(event, listener, { once: true });
    }
    /** Clear all events */
    unAll() {
        this.listeners = {};
    }
    /** Emit an event */
    emit(eventName, ...args) {
        if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((listener) => listener(...args));
        }
    }
}

class Player extends EventEmitter {
    constructor(options) {
        super();
        this.isExternalMedia = false;
        if (options.media) {
            this.media = options.media;
            this.isExternalMedia = true;
        }
        else {
            this.media = document.createElement('audio');
        }
        // Controls
        if (options.mediaControls) {
            this.media.controls = true;
        }
        // Autoplay
        if (options.autoplay) {
            this.media.autoplay = true;
        }
        // Speed
        if (options.playbackRate != null) {
            this.onceMediaEvent('canplay', () => {
                if (options.playbackRate != null) {
                    this.media.playbackRate = options.playbackRate;
                }
            });
        }
    }
    onMediaEvent(event, callback, options) {
        this.media.addEventListener(event, callback, options);
        return () => this.media.removeEventListener(event, callback);
    }
    onceMediaEvent(event, callback) {
        return this.onMediaEvent(event, callback, { once: true });
    }
    getSrc() {
        return this.media.currentSrc || this.media.src || '';
    }
    revokeSrc() {
        const src = this.getSrc();
        if (src.startsWith('blob:')) {
            URL.revokeObjectURL(src);
        }
    }
    setSrc(url, blob) {
        const src = this.getSrc();
        if (src === url)
            return;
        this.revokeSrc();
        const newSrc = blob instanceof Blob ? URL.createObjectURL(blob) : url;
        this.media.src = newSrc;
        this.media.load();
    }
    destroy() {
        this.media.pause();
        if (this.isExternalMedia)
            return;
        this.media.remove();
        this.revokeSrc();
        this.media.src = '';
        // Load resets the media element to its initial state
        this.media.load();
    }
    setMediaElement(element) {
        this.media = element;
    }
    /** Start playing the audio */
    play() {
        return this.media.play();
    }
    /** Pause the audio */
    pause() {
        this.media.pause();
    }
    /** Check if the audio is playing */
    isPlaying() {
        return !this.media.paused && !this.media.ended;
    }
    /** Jumpt to a specific time in the audio (in seconds) */
    setTime(time) {
        this.media.currentTime = time;
    }
    /** Get the duration of the audio in seconds */
    getDuration() {
        return this.media.duration;
    }
    /** Get the current audio position in seconds */
    getCurrentTime() {
        return this.media.currentTime;
    }
    /** Get the audio volume */
    getVolume() {
        return this.media.volume;
    }
    /** Set the audio volume */
    setVolume(volume) {
        this.media.volume = volume;
    }
    /** Get the audio muted state */
    getMuted() {
        return this.media.muted;
    }
    /** Mute or unmute the audio */
    setMuted(muted) {
        this.media.muted = muted;
    }
    /** Get the playback speed */
    getPlaybackRate() {
        return this.media.playbackRate;
    }
    /** Set the playback speed, pass an optional false to NOT preserve the pitch */
    setPlaybackRate(rate, preservePitch) {
        // preservePitch is true by default in most browsers
        if (preservePitch != null) {
            this.media.preservesPitch = preservePitch;
        }
        this.media.playbackRate = rate;
    }
    /** Get the HTML media element */
    getMediaElement() {
        return this.media;
    }
    /** Set a sink id to change the audio output device */
    setSinkId(sinkId) {
        // See https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId
        const media = this.media;
        return media.setSinkId(sinkId);
    }
}

function makeDraggable(element, onDrag, onStart, onEnd, threshold = 5) {
    let unsub = () => {
        return;
    };
    if (!element)
        return unsub;
    const down = (e) => {
        // Ignore the right mouse button
        if (e.button === 2)
            return;
        e.preventDefault();
        e.stopPropagation();
        element.style.touchAction = 'none';
        let startX = e.clientX;
        let startY = e.clientY;
        let isDragging = false;
        const move = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const x = e.clientX;
            const y = e.clientY;
            if (isDragging || Math.abs(x - startX) >= threshold || Math.abs(y - startY) >= threshold) {
                const { left, top } = element.getBoundingClientRect();
                if (!isDragging) {
                    isDragging = true;
                    onStart === null || onStart === void 0 ? void 0 : onStart(startX - left, startY - top);
                }
                onDrag(x - startX, y - startY, x - left, y - top);
                startX = x;
                startY = y;
            }
        };
        const click = (e) => {
            if (isDragging) {
                e.preventDefault();
                e.stopPropagation();
            }
        };
        const up = () => {
            element.style.touchAction = '';
            if (isDragging) {
                onEnd === null || onEnd === void 0 ? void 0 : onEnd();
            }
            unsub();
        };
        document.addEventListener('pointermove', move);
        document.addEventListener('pointerup', up);
        document.addEventListener('pointerleave', up);
        document.addEventListener('click', click, true);
        unsub = () => {
            document.removeEventListener('pointermove', move);
            document.removeEventListener('pointerup', up);
            document.removeEventListener('pointerleave', up);
            setTimeout(() => {
                document.removeEventListener('click', click, true);
            }, 10);
        };
    };
    element.addEventListener('pointerdown', down);
    return () => {
        unsub();
        element.removeEventListener('pointerdown', down);
    };
}

class Renderer extends EventEmitter {
    constructor(options, audioElement) {
        super();
        this.timeouts = [];
        this.isScrolling = false;
        this.audioData = null;
        this.resizeObserver = null;
        this.isDragging = false;
        this.options = options;
        const parent = this.parentFromOptionsContainer(options.container);
        this.parent = parent;
        const [div, shadow] = this.initHtml();
        parent.appendChild(div);
        this.container = div;
        this.scrollContainer = shadow.querySelector('.scroll');
        this.wrapper = shadow.querySelector('.wrapper');
        this.canvasWrapper = shadow.querySelector('.canvases');
        this.progressWrapper = shadow.querySelector('.progress');
        this.cursor = shadow.querySelector('.cursor');
        if (audioElement) {
            shadow.appendChild(audioElement);
        }
        this.initEvents();
    }
    parentFromOptionsContainer(container) {
        let parent;
        if (typeof container === 'string') {
            parent = document.querySelector(container);
        }
        else if (container instanceof HTMLElement) {
            parent = container;
        }
        if (!parent) {
            throw new Error('Container not found');
        }
        return parent;
    }
    initEvents() {
        const getClickPosition = (e) => {
            const rect = this.wrapper.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientX - rect.left;
            const relativeX = x / rect.width;
            const relativeY = y / rect.height;
            return [relativeX, relativeY];
        };
        // Add a click listener
        this.wrapper.addEventListener('click', (e) => {
            const [x, y] = getClickPosition(e);
            this.emit('click', x, y);
        });
        // Add a double click listener
        this.wrapper.addEventListener('dblclick', (e) => {
            const [x, y] = getClickPosition(e);
            this.emit('dblclick', x, y);
        });
        // Drag
        if (this.options.dragToSeek) {
            this.initDrag();
        }
        // Add a scroll listener
        this.scrollContainer.addEventListener('scroll', () => {
            const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;
            const startX = scrollLeft / scrollWidth;
            const endX = (scrollLeft + clientWidth) / scrollWidth;
            this.emit('scroll', startX, endX);
        });
        // Re-render the waveform on container resize
        const delay = this.createDelay(100);
        this.resizeObserver = new ResizeObserver(() => {
            delay(() => this.reRender());
        });
        this.resizeObserver.observe(this.scrollContainer);
    }
    initDrag() {
        makeDraggable(this.wrapper, 
        // On drag
        (_, __, x) => {
            this.emit('drag', Math.max(0, Math.min(1, x / this.wrapper.getBoundingClientRect().width)));
        }, 
        // On start drag
        () => (this.isDragging = true), 
        // On end drag
        () => (this.isDragging = false));
    }
    getHeight() {
        const defaultHeight = 128;
        if (this.options.height == null)
            return defaultHeight;
        if (!isNaN(Number(this.options.height)))
            return Number(this.options.height);
        if (this.options.height === 'auto')
            return this.parent.clientHeight || defaultHeight;
        return defaultHeight;
    }
    initHtml() {
        const div = document.createElement('div');
        const shadow = div.attachShadow({ mode: 'open' });
        shadow.innerHTML = `
      <style>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight()}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `;
        return [div, shadow];
    }
    /** Wavesurfer itself calls this method. Do not call it manually. */
    setOptions(options) {
        if (this.options.container !== options.container) {
            const newParent = this.parentFromOptionsContainer(options.container);
            newParent.appendChild(this.container);
            this.parent = newParent;
        }
        if (options.dragToSeek && !this.options.dragToSeek) {
            this.initDrag();
        }
        this.options = options;
        // Re-render the waveform
        this.reRender();
    }
    getWrapper() {
        return this.wrapper;
    }
    getScroll() {
        return this.scrollContainer.scrollLeft;
    }
    destroy() {
        var _a;
        this.container.remove();
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    createDelay(delayMs = 10) {
        const context = {};
        this.timeouts.push(context);
        return (callback) => {
            context.timeout && clearTimeout(context.timeout);
            context.timeout = setTimeout(callback, delayMs);
        };
    }
    // Convert array of color values to linear gradient
    convertColorValues(color) {
        if (!Array.isArray(color))
            return color || '';
        if (color.length < 2)
            return color[0] || '';
        const canvasElement = document.createElement('canvas');
        const ctx = canvasElement.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, canvasElement.height);
        const colorStopPercentage = 1 / (color.length - 1);
        color.forEach((color, index) => {
            const offset = index * colorStopPercentage;
            gradient.addColorStop(offset, color);
        });
        return gradient;
    }
    renderBarWaveform(channelData, options, ctx, vScale) {
        const topChannel = channelData[0];
        const bottomChannel = channelData[1] || channelData[0];
        const length = topChannel.length;
        const { width, height } = ctx.canvas;
        const halfHeight = height / 2;
        const pixelRatio = window.devicePixelRatio || 1;
        const barWidth = options.barWidth ? options.barWidth * pixelRatio : 1;
        const barGap = options.barGap ? options.barGap * pixelRatio : options.barWidth ? barWidth / 2 : 0;
        const barRadius = options.barRadius || 0;
        const barIndexScale = width / (barWidth + barGap) / length;
        const rectFn = barRadius && 'roundRect' in ctx ? 'roundRect' : 'rect';
        ctx.beginPath();
        let prevX = 0;
        let maxTop = 0;
        let maxBottom = 0;
        for (let i = 0; i <= length; i++) {
            const x = Math.round(i * barIndexScale);
            if (x > prevX) {
                const topBarHeight = Math.round(maxTop * halfHeight * vScale);
                const bottomBarHeight = Math.round(maxBottom * halfHeight * vScale);
                const barHeight = topBarHeight + bottomBarHeight || 1;
                // Vertical alignment
                let y = halfHeight - topBarHeight;
                if (options.barAlign === 'top') {
                    y = 0;
                }
                else if (options.barAlign === 'bottom') {
                    y = height - barHeight;
                }
                ctx[rectFn](prevX * (barWidth + barGap), y, barWidth, barHeight, barRadius);
                prevX = x;
                maxTop = 0;
                maxBottom = 0;
            }
            const magnitudeTop = Math.abs(topChannel[i] || 0);
            const magnitudeBottom = Math.abs(bottomChannel[i] || 0);
            if (magnitudeTop > maxTop)
                maxTop = magnitudeTop;
            if (magnitudeBottom > maxBottom)
                maxBottom = magnitudeBottom;
        }
        ctx.fill();
        ctx.closePath();
    }
    renderLineWaveform(channelData, _options, ctx, vScale) {
        const drawChannel = (index) => {
            const channel = channelData[index] || channelData[0];
            const length = channel.length;
            const { height } = ctx.canvas;
            const halfHeight = height / 2;
            const hScale = ctx.canvas.width / length;
            ctx.moveTo(0, halfHeight);
            let prevX = 0;
            let max = 0;
            for (let i = 0; i <= length; i++) {
                const x = Math.round(i * hScale);
                if (x > prevX) {
                    const h = Math.round(max * halfHeight * vScale) || 1;
                    const y = halfHeight + h * (index === 0 ? -1 : 1);
                    ctx.lineTo(prevX, y);
                    prevX = x;
                    max = 0;
                }
                const value = Math.abs(channel[i] || 0);
                if (value > max)
                    max = value;
            }
            ctx.lineTo(prevX, halfHeight);
        };
        ctx.beginPath();
        drawChannel(0);
        drawChannel(1);
        ctx.fill();
        ctx.closePath();
    }
    renderWaveform(channelData, options, ctx) {
        ctx.fillStyle = this.convertColorValues(options.waveColor);
        // Custom rendering function
        if (options.renderFunction) {
            options.renderFunction(channelData, ctx);
            return;
        }
        // Vertical scaling
        let vScale = options.barHeight || 1;
        if (options.normalize) {
            const max = Array.from(channelData[0]).reduce((max, value) => Math.max(max, Math.abs(value)), 0);
            vScale = max ? 1 / max : 1;
        }
        // Render waveform as bars
        if (options.barWidth || options.barGap || options.barAlign) {
            this.renderBarWaveform(channelData, options, ctx, vScale);
            return;
        }
        // Render waveform as a polyline
        this.renderLineWaveform(channelData, options, ctx, vScale);
    }
    renderSingleCanvas(channelData, options, width, height, start, end, canvasContainer, progressContainer) {
        const pixelRatio = window.devicePixelRatio || 1;
        const canvas = document.createElement('canvas');
        const length = channelData[0].length;
        canvas.width = Math.round((width * (end - start)) / length);
        canvas.height = height * pixelRatio;
        canvas.style.width = `${Math.floor(canvas.width / pixelRatio)}px`;
        canvas.style.height = `${height}px`;
        canvas.style.left = `${Math.floor((start * width) / pixelRatio / length)}px`;
        canvasContainer.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        this.renderWaveform(channelData.map((channel) => channel.slice(start, end)), options, ctx);
        // Draw a progress canvas
        if (canvas.width > 0 && canvas.height > 0) {
            const progressCanvas = canvas.cloneNode();
            const progressCtx = progressCanvas.getContext('2d');
            progressCtx.drawImage(canvas, 0, 0);
            // Set the composition method to draw only where the waveform is drawn
            progressCtx.globalCompositeOperation = 'source-in';
            progressCtx.fillStyle = this.convertColorValues(options.progressColor);
            // This rectangle acts as a mask thanks to the composition method
            progressCtx.fillRect(0, 0, canvas.width, canvas.height);
            progressContainer.appendChild(progressCanvas);
        }
    }
    renderChannel(channelData, options, width) {
        // A container for canvases
        const canvasContainer = document.createElement('div');
        const height = this.getHeight();
        canvasContainer.style.height = `${height}px`;
        this.canvasWrapper.style.minHeight = `${height}px`;
        this.canvasWrapper.appendChild(canvasContainer);
        // A container for progress canvases
        const progressContainer = canvasContainer.cloneNode();
        this.progressWrapper.appendChild(progressContainer);
        // Determine the currently visible part of the waveform
        const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;
        const len = channelData[0].length;
        const scale = len / scrollWidth;
        let viewportWidth = Math.min(Renderer.MAX_CANVAS_WIDTH, clientWidth);
        // Adjust width to avoid gaps between canvases when using bars
        if (options.barWidth || options.barGap) {
            const barWidth = options.barWidth || 0.5;
            const barGap = options.barGap || barWidth / 2;
            const totalBarWidth = barWidth + barGap;
            if (viewportWidth % totalBarWidth !== 0) {
                viewportWidth = Math.floor(viewportWidth / totalBarWidth) * totalBarWidth;
            }
        }
        const start = Math.floor(Math.abs(scrollLeft) * scale);
        const end = Math.floor(start + viewportWidth * scale);
        const viewportLen = end - start;
        // Draw a portion of the waveform from start peak to end peak
        const draw = (start, end) => {
            this.renderSingleCanvas(channelData, options, width, height, Math.max(0, start), Math.min(end, len), canvasContainer, progressContainer);
        };
        // Draw the waveform in viewport chunks, each with a delay
        const headDelay = this.createDelay();
        const tailDelay = this.createDelay();
        const renderHead = (fromIndex, toIndex) => {
            draw(fromIndex, toIndex);
            if (fromIndex > 0) {
                headDelay(() => {
                    renderHead(fromIndex - viewportLen, toIndex - viewportLen);
                });
            }
        };
        const renderTail = (fromIndex, toIndex) => {
            draw(fromIndex, toIndex);
            if (toIndex < len) {
                tailDelay(() => {
                    renderTail(fromIndex + viewportLen, toIndex + viewportLen);
                });
            }
        };
        renderHead(start, end);
        if (end < len) {
            renderTail(end, end + viewportLen);
        }
    }
    render(audioData) {
        // Clear previous timeouts
        this.timeouts.forEach((context) => context.timeout && clearTimeout(context.timeout));
        this.timeouts = [];
        // Clear the canvases
        this.canvasWrapper.innerHTML = '';
        this.progressWrapper.innerHTML = '';
        this.wrapper.style.width = '';
        // Width
        if (this.options.width != null) {
            this.scrollContainer.style.width =
                typeof this.options.width === 'number' ? `${this.options.width}px` : this.options.width;
        }
        // Determine the width of the waveform
        const pixelRatio = window.devicePixelRatio || 1;
        const parentWidth = this.scrollContainer.clientWidth;
        const scrollWidth = Math.ceil(audioData.duration * (this.options.minPxPerSec || 0));
        // Whether the container should scroll
        this.isScrolling = scrollWidth > parentWidth;
        const useParentWidth = this.options.fillParent && !this.isScrolling;
        // Width of the waveform in pixels
        const width = (useParentWidth ? parentWidth : scrollWidth) * pixelRatio;
        // Set the width of the wrapper
        this.wrapper.style.width = useParentWidth ? '100%' : `${scrollWidth}px`;
        // Set additional styles
        this.scrollContainer.style.overflowX = this.isScrolling ? 'auto' : 'hidden';
        this.scrollContainer.classList.toggle('noScrollbar', !!this.options.hideScrollbar);
        this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`;
        this.cursor.style.width = `${this.options.cursorWidth}px`;
        // Render the waveform
        if (this.options.splitChannels) {
            // Render a waveform for each channel
            for (let i = 0; i < audioData.numberOfChannels; i++) {
                const options = Object.assign(Object.assign({}, this.options), this.options.splitChannels[i]);
                this.renderChannel([audioData.getChannelData(i)], options, width);
            }
        }
        else {
            // Render a single waveform for the first two channels (left and right)
            const channels = [audioData.getChannelData(0)];
            if (audioData.numberOfChannels > 1)
                channels.push(audioData.getChannelData(1));
            this.renderChannel(channels, this.options, width);
        }
        this.audioData = audioData;
        this.emit('render');
    }
    reRender() {
        // Return if the waveform has not been rendered yet
        if (!this.audioData)
            return;
        // Remember the current cursor position
        const oldCursorPosition = this.progressWrapper.clientWidth;
        // Set the new zoom level and re-render the waveform
        this.render(this.audioData);
        // Adjust the scroll position so that the cursor stays in the same place
        const newCursortPosition = this.progressWrapper.clientWidth;
        this.scrollContainer.scrollLeft += newCursortPosition - oldCursorPosition;
    }
    zoom(minPxPerSec) {
        this.options.minPxPerSec = minPxPerSec;
        this.reRender();
    }
    scrollIntoView(progress, isPlaying = false) {
        const { clientWidth, scrollLeft, scrollWidth } = this.scrollContainer;
        const progressWidth = scrollWidth * progress;
        const center = clientWidth / 2;
        const minScroll = isPlaying && this.options.autoCenter && !this.isDragging ? center : clientWidth;
        if (progressWidth > scrollLeft + minScroll || progressWidth < scrollLeft) {
            // Scroll to the center
            if (this.options.autoCenter && !this.isDragging) {
                // If the cursor is in viewport but not centered, scroll to the center slowly
                const minDiff = center / 20;
                if (progressWidth - (scrollLeft + center) >= minDiff && progressWidth < scrollLeft + clientWidth) {
                    this.scrollContainer.scrollLeft += minDiff;
                }
                else {
                    // Otherwise, scroll to the center immediately
                    this.scrollContainer.scrollLeft = progressWidth - center;
                }
            }
            else if (this.isDragging) {
                // Scroll just a little bit to allow for some space between the cursor and the edge
                const gap = 10;
                this.scrollContainer.scrollLeft =
                    progressWidth < scrollLeft ? progressWidth - gap : progressWidth - clientWidth + gap;
            }
            else {
                // Scroll to the beginning
                this.scrollContainer.scrollLeft = progressWidth;
            }
        }
        // Emit the scroll event
        {
            const { scrollLeft } = this.scrollContainer;
            const startX = scrollLeft / scrollWidth;
            const endX = (scrollLeft + clientWidth) / scrollWidth;
            this.emit('scroll', startX, endX);
        }
    }
    renderProgress(progress, isPlaying) {
        if (isNaN(progress))
            return;
        const percents = progress * 100;
        this.canvasWrapper.style.clipPath = `polygon(${percents}% 0, 100% 0, 100% 100%, ${percents}% 100%)`;
        this.progressWrapper.style.width = `${percents}%`;
        this.cursor.style.left = `${percents}%`;
        this.cursor.style.marginLeft = Math.round(percents) === 100 ? `-${this.options.cursorWidth}px` : '';
        if (this.isScrolling && this.options.autoScroll) {
            this.scrollIntoView(progress, isPlaying);
        }
    }
}
Renderer.MAX_CANVAS_WIDTH = 4000;

class Timer extends EventEmitter {
    constructor() {
        super(...arguments);
        this.unsubscribe = () => undefined;
    }
    start() {
        this.unsubscribe = this.on('tick', () => {
            requestAnimationFrame(() => {
                this.emit('tick');
            });
        });
        this.emit('tick');
    }
    stop() {
        this.unsubscribe();
    }
    destroy() {
        this.unsubscribe();
    }
}

var __awaiter$1 = (globalThis && globalThis.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * A Web Audio buffer player emulating the behavior of an HTML5 Audio element.
 */
class WebAudioPlayer extends EventEmitter {
    constructor(audioContext = new AudioContext()) {
        super();
        this.bufferNode = null;
        this.autoplay = false;
        this.playStartTime = 0;
        this.playedDuration = 0;
        this._muted = false;
        this.buffer = null;
        this.currentSrc = '';
        this.paused = true;
        this.crossOrigin = null;
        this.audioContext = audioContext;
        this.gainNode = this.audioContext.createGain();
        this.gainNode.connect(this.audioContext.destination);
    }
    load() {
        return __awaiter$1(this, void 0, void 0, function* () {
            return;
        });
    }
    get src() {
        return this.currentSrc;
    }
    set src(value) {
        this.currentSrc = value;
        fetch(value)
            .then((response) => response.arrayBuffer())
            .then((arrayBuffer) => this.audioContext.decodeAudioData(arrayBuffer))
            .then((audioBuffer) => {
            this.buffer = audioBuffer;
            this.emit('loadedmetadata');
            this.emit('canplay');
            if (this.autoplay)
                this.play();
        });
    }
    _play() {
        var _a;
        if (!this.paused)
            return;
        this.paused = false;
        (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.disconnect();
        this.bufferNode = this.audioContext.createBufferSource();
        this.bufferNode.buffer = this.buffer;
        this.bufferNode.connect(this.gainNode);
        if (this.playedDuration >= this.duration) {
            this.playedDuration = 0;
        }
        this.bufferNode.start(this.audioContext.currentTime, this.playedDuration);
        this.playStartTime = this.audioContext.currentTime;
        this.bufferNode.onended = () => {
            if (this.currentTime >= this.duration) {
                this.pause();
                this.emit('ended');
            }
        };
    }
    _pause() {
        var _a;
        if (this.paused)
            return;
        this.paused = true;
        (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.stop();
        this.playedDuration += this.audioContext.currentTime - this.playStartTime;
    }
    play() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._play();
            this.emit('play');
        });
    }
    pause() {
        this._pause();
        this.emit('pause');
    }
    setSinkId(deviceId) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const ac = this.audioContext;
            return ac.setSinkId(deviceId);
        });
    }
    get playbackRate() {
        var _a, _b;
        return (_b = (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.playbackRate.value) !== null && _b !== void 0 ? _b : 1;
    }
    set playbackRate(value) {
        if (this.bufferNode) {
            this.bufferNode.playbackRate.value = value;
        }
    }
    get currentTime() {
        return this.paused ? this.playedDuration : this.playedDuration + this.audioContext.currentTime - this.playStartTime;
    }
    set currentTime(value) {
        this.emit('seeking');
        if (this.paused) {
            this.playedDuration = value;
        }
        else {
            this._pause();
            this.playedDuration = value;
            this._play();
        }
        this.emit('timeupdate');
    }
    get duration() {
        var _a;
        return ((_a = this.buffer) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    get volume() {
        return this.gainNode.gain.value;
    }
    set volume(value) {
        this.gainNode.gain.value = value;
        this.emit('volumechange');
    }
    get muted() {
        return this._muted;
    }
    set muted(value) {
        if (this._muted === value)
            return;
        this._muted = value;
        if (this._muted) {
            this.gainNode.disconnect();
        }
        else {
            this.gainNode.connect(this.audioContext.destination);
        }
    }
    /** Get the GainNode used to play the audio. Can be used to attach filters. */
    getGainNode() {
        return this.gainNode;
    }
}

var __awaiter = (globalThis && globalThis.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultOptions = {
    waveColor: '#999',
    progressColor: '#555',
    cursorWidth: 1,
    minPxPerSec: 0,
    fillParent: true,
    interact: true,
    dragToSeek: false,
    autoScroll: true,
    autoCenter: true,
    sampleRate: 8000,
};
class WaveSurfer extends Player {
    /** Create a new WaveSurfer instance */
    static create(options) {
        return new WaveSurfer(options);
    }
    /** Create a new WaveSurfer instance */
    constructor(options) {
        const media = options.media ||
            (options.backend === 'WebAudio' ? new WebAudioPlayer() : undefined);
        super({
            media,
            mediaControls: options.mediaControls,
            autoplay: options.autoplay,
            playbackRate: options.audioRate,
        });
        this.plugins = [];
        this.decodedData = null;
        this.subscriptions = [];
        this.mediaSubscriptions = [];
        this.options = Object.assign({}, defaultOptions, options);
        this.timer = new Timer();
        const audioElement = media ? undefined : this.getMediaElement();
        this.renderer = new Renderer(this.options, audioElement);
        this.initPlayerEvents();
        this.initRendererEvents();
        this.initTimerEvents();
        this.initPlugins();
        // Load audio if URL is passed or an external media with an src
        const url = this.options.url || this.getSrc();
        if (url) {
            this.load(url, this.options.peaks, this.options.duration);
        }
        else if (this.options.peaks && this.options.duration) {
            // If pre-decoded peaks and duration are provided, render a waveform w/o loading audio
            this.loadPredecoded();
        }
    }
    initTimerEvents() {
        // The timer fires every 16ms for a smooth progress animation
        this.subscriptions.push(this.timer.on('tick', () => {
            const currentTime = this.getCurrentTime();
            this.renderer.renderProgress(currentTime / this.getDuration(), true);
            this.emit('timeupdate', currentTime);
            this.emit('audioprocess', currentTime);
        }));
    }
    initPlayerEvents() {
        this.mediaSubscriptions.push(this.onMediaEvent('timeupdate', () => {
            const currentTime = this.getCurrentTime();
            this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying());
            this.emit('timeupdate', currentTime);
        }), this.onMediaEvent('play', () => {
            this.emit('play');
            this.timer.start();
        }), this.onMediaEvent('pause', () => {
            this.emit('pause');
            this.timer.stop();
        }), this.onMediaEvent('emptied', () => {
            this.timer.stop();
        }), this.onMediaEvent('ended', () => {
            this.emit('finish');
        }), this.onMediaEvent('seeking', () => {
            this.emit('seeking', this.getCurrentTime());
        }));
    }
    initRendererEvents() {
        this.subscriptions.push(
        // Seek on click
        this.renderer.on('click', (relativeX, relativeY) => {
            if (this.options.interact) {
                this.seekTo(relativeX);
                this.emit('interaction', relativeX * this.getDuration());
                this.emit('click', relativeX, relativeY);
            }
        }), 
        // Double click
        this.renderer.on('dblclick', (relativeX, relativeY) => {
            this.emit('dblclick', relativeX, relativeY);
        }), 
        // Scroll
        this.renderer.on('scroll', (startX, endX) => {
            const duration = this.getDuration();
            this.emit('scroll', startX * duration, endX * duration);
        }), 
        // Redraw
        this.renderer.on('render', () => {
            this.emit('redraw');
        }));
        // Drag
        {
            let debounce;
            this.subscriptions.push(this.renderer.on('drag', (relativeX) => {
                if (!this.options.interact)
                    return;
                // Update the visual position
                this.renderer.renderProgress(relativeX);
                // Set the audio position with a debounce
                clearTimeout(debounce);
                debounce = setTimeout(() => {
                    this.seekTo(relativeX);
                }, this.isPlaying() ? 0 : 200);
                this.emit('interaction', relativeX * this.getDuration());
                this.emit('drag', relativeX);
            }));
        }
    }
    initPlugins() {
        var _a;
        if (!((_a = this.options.plugins) === null || _a === void 0 ? void 0 : _a.length))
            return;
        this.options.plugins.forEach((plugin) => {
            this.registerPlugin(plugin);
        });
    }
    unsubscribePlayerEvents() {
        this.mediaSubscriptions.forEach((unsubscribe) => unsubscribe());
        this.mediaSubscriptions = [];
    }
    /** Set new wavesurfer options and re-render it */
    setOptions(options) {
        this.options = Object.assign({}, this.options, options);
        this.renderer.setOptions(this.options);
        if (options.audioRate) {
            this.setPlaybackRate(options.audioRate);
        }
        if (options.mediaControls != null) {
            this.getMediaElement().controls = options.mediaControls;
        }
    }
    /** Register a wavesurfer.js plugin */
    registerPlugin(plugin) {
        plugin.init(this);
        this.plugins.push(plugin);
        // Unregister plugin on destroy
        this.subscriptions.push(plugin.once('destroy', () => {
            this.plugins = this.plugins.filter((p) => p !== plugin);
        }));
        return plugin;
    }
    /** For plugins only: get the waveform wrapper div */
    getWrapper() {
        return this.renderer.getWrapper();
    }
    /** Get the current scroll position in pixels */
    getScroll() {
        return this.renderer.getScroll();
    }
    /** Get all registered plugins */
    getActivePlugins() {
        return this.plugins;
    }
    loadPredecoded() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.peaks && this.options.duration) {
                this.decodedData = Decoder.createBuffer(this.options.peaks, this.options.duration);
                yield Promise.resolve(); // wait for event listeners to subscribe
                this.renderDecoded();
            }
        });
    }
    renderDecoded() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.decodedData) {
                this.emit('decode', this.getDuration());
                this.renderer.render(this.decodedData);
            }
        });
    }
    loadAudio(url, blob, channelData, duration) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('load', url);
            if (!this.options.media && this.isPlaying())
                this.pause();
            this.decodedData = null;
            // Fetch the entire audio as a blob if pre-decoded data is not provided
            if (!blob && !channelData) {
                const onProgress = (percentage) => this.emit('loading', percentage);
                blob = yield Fetcher.fetchBlob(url, onProgress, this.options.fetchParams);
            }
            // Set the mediaelement source
            this.setSrc(url, blob);
            // Wait for the audio duration
            // It should be a promise to allow event listeners to subscribe to the ready and decode events
            duration =
                (yield Promise.resolve(duration || this.getDuration())) ||
                    (yield new Promise((resolve) => {
                        this.onceMediaEvent('loadedmetadata', () => resolve(this.getDuration()));
                    })) ||
                    (yield Promise.resolve(0));
            // Decode the audio data or use user-provided peaks
            if (channelData) {
                this.decodedData = Decoder.createBuffer(channelData, duration);
            }
            else if (blob) {
                const arrayBuffer = yield blob.arrayBuffer();
                this.decodedData = yield Decoder.decode(arrayBuffer, this.options.sampleRate);
            }
            this.renderDecoded();
            this.emit('ready', this.getDuration());
        });
    }
    /** Load an audio file by URL, with optional pre-decoded audio data */
    load(url, channelData, duration) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadAudio(url, undefined, channelData, duration);
        });
    }
    /** Load an audio blob */
    loadBlob(blob, channelData, duration) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadAudio('blob', blob, channelData, duration);
        });
    }
    /** Zoom the waveform by a given pixels-per-second factor */
    zoom(minPxPerSec) {
        if (!this.decodedData) {
            throw new Error('No audio loaded');
        }
        this.renderer.zoom(minPxPerSec);
        this.emit('zoom', minPxPerSec);
    }
    /** Get the decoded audio data */
    getDecodedData() {
        return this.decodedData;
    }
    /** Get decoded peaks */
    exportPeaks({ channels = 2, maxLength = 8000, precision = 10000 } = {}) {
        if (!this.decodedData) {
            throw new Error('The audio has not been decoded yet');
        }
        const maxChannels = Math.min(channels, this.decodedData.numberOfChannels);
        const peaks = [];
        for (let i = 0; i < maxChannels; i++) {
            const channel = this.decodedData.getChannelData(i);
            const data = [];
            const sampleSize = Math.round(channel.length / maxLength);
            for (let i = 0; i < maxLength; i++) {
                const sample = channel.slice(i * sampleSize, (i + 1) * sampleSize);
                const max = Math.max(...sample);
                data.push(Math.round(max * precision) / precision);
            }
            peaks.push(data);
        }
        return peaks;
    }
    /** Get the duration of the audio in seconds */
    getDuration() {
        let duration = super.getDuration() || 0;
        // Fall back to the decoded data duration if the media duration is incorrect
        if ((duration === 0 || duration === Infinity) && this.decodedData) {
            duration = this.decodedData.duration;
        }
        return duration;
    }
    /** Toggle if the waveform should react to clicks */
    toggleInteraction(isInteractive) {
        this.options.interact = isInteractive;
    }
    /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */
    seekTo(progress) {
        const time = this.getDuration() * progress;
        this.setTime(time);
    }
    /** Play or pause the audio */
    playPause() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.isPlaying() ? this.pause() : this.play();
        });
    }
    /** Stop the audio and go to the beginning */
    stop() {
        this.pause();
        this.setTime(0);
    }
    /** Skip N or -N seconds from the current position */
    skip(seconds) {
        this.setTime(this.getCurrentTime() + seconds);
    }
    /** Empty the waveform by loading a tiny silent audio */
    empty() {
        this.load('', [[0]], 0.001);
    }
    /** Set HTML media element */
    setMediaElement(element) {
        this.unsubscribePlayerEvents();
        super.setMediaElement(element);
        this.initPlayerEvents();
    }
    /** Unmount wavesurfer */
    destroy() {
        this.emit('destroy');
        this.plugins.forEach((plugin) => plugin.destroy());
        this.subscriptions.forEach((unsubscribe) => unsubscribe());
        this.unsubscribePlayerEvents();
        this.timer.destroy();
        this.renderer.destroy();
        super.destroy();
    }
}

function audioBufferToWav(audioBuffer) {
  const numOfChan = audioBuffer.numberOfChannels;
  const length = audioBuffer.length * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  let offset = 0;
  const writeString = function(view2, offset2, string) {
    for (let i = 0; i < string.length; i++) {
      view2.setUint8(offset2 + i, string.charCodeAt(i));
    }
  };
  writeString(view, offset, "RIFF");
  offset += 4;
  view.setUint32(offset, length - 8, true);
  offset += 4;
  writeString(view, offset, "WAVE");
  offset += 4;
  writeString(view, offset, "fmt ");
  offset += 4;
  view.setUint32(offset, 16, true);
  offset += 4;
  view.setUint16(offset, 1, true);
  offset += 2;
  view.setUint16(offset, numOfChan, true);
  offset += 2;
  view.setUint32(offset, audioBuffer.sampleRate, true);
  offset += 4;
  view.setUint32(offset, audioBuffer.sampleRate * 2 * numOfChan, true);
  offset += 4;
  view.setUint16(offset, numOfChan * 2, true);
  offset += 2;
  view.setUint16(offset, 16, true);
  offset += 2;
  writeString(view, offset, "data");
  offset += 4;
  view.setUint32(offset, audioBuffer.length * numOfChan * 2, true);
  offset += 4;
  for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
    const channel = audioBuffer.getChannelData(i);
    for (let j = 0; j < channel.length; j++) {
      view.setInt16(offset, channel[j] * 65535, true);
      offset += 2;
    }
  }
  return new Uint8Array(buffer);
}

const process_audio = async (audioBuffer, start, end) => {
  const audioContext = new AudioContext();
  const numberOfChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  let trimmedLength = audioBuffer.length;
  let startOffset = 0;
  if (start && end) {
    startOffset = Math.round(start * sampleRate);
    const endOffset = Math.round(end * sampleRate);
    trimmedLength = endOffset - startOffset;
  }
  const trimmedAudioBuffer = audioContext.createBuffer(
    numberOfChannels,
    trimmedLength,
    sampleRate
  );
  for (let channel = 0; channel < numberOfChannels; channel++) {
    const channelData = audioBuffer.getChannelData(channel);
    const trimmedData = trimmedAudioBuffer.getChannelData(channel);
    for (let i = 0; i < trimmedLength; i++) {
      trimmedData[i] = channelData[startOffset + i];
    }
  }
  return audioBufferToWav(trimmedAudioBuffer);
};
const skipAudio = (waveform, amount) => {
  if (!waveform)
    return;
  waveform.skip(amount);
};
const getSkipRewindAmount = (audioDuration, skip_length) => {
  if (!skip_length) {
    skip_length = 5;
  }
  return audioDuration / 100 * skip_length || 5;
};

let t$1 = class t{constructor(){this.listeners={},this.on=this.addEventListener,this.un=this.removeEventListener;}addEventListener(t,e,i){if(this.listeners[t]||(this.listeners[t]=new Set),this.listeners[t].add(e),null==i?void 0:i.once){const i=()=>{this.removeEventListener(t,i),this.removeEventListener(t,e);};return this.addEventListener(t,i),i}return ()=>this.removeEventListener(t,e)}removeEventListener(t,e){var i;null===(i=this.listeners[t])||void 0===i||i.delete(e);}once(t,e){return this.on(t,e,{once:!0})}unAll(){this.listeners={};}emit(t,...e){this.listeners[t]&&this.listeners[t].forEach((t=>t(...e)));}};let e$1 = class e extends t$1{constructor(t){super(),this.subscriptions=[],this.options=t;}onInit(){}init(t){this.wavesurfer=t,this.onInit();}destroy(){this.emit("destroy"),this.subscriptions.forEach((t=>t()));}};function i$1(t,e,i,n,s=5){let r=()=>{};if(!t)return r;const o=o=>{if(2===o.button)return;o.preventDefault(),o.stopPropagation(),t.style.touchAction="none";let a=o.clientX,h=o.clientY,l=!1;const d=n=>{n.preventDefault(),n.stopPropagation();const r=n.clientX,o=n.clientY;if(l||Math.abs(r-a)>=s||Math.abs(o-h)>=s){const{left:n,top:s}=t.getBoundingClientRect();l||(l=!0,null==i||i(a-n,h-s)),e(r-a,o-h,r-n,o-s),a=r,h=o;}},u=t=>{l&&(t.preventDefault(),t.stopPropagation());},c=()=>{t.style.touchAction="",l&&(null==n||n()),r();};document.addEventListener("pointermove",d),document.addEventListener("pointerup",c),document.addEventListener("pointerleave",c),document.addEventListener("click",u,!0),r=()=>{document.removeEventListener("pointermove",d),document.removeEventListener("pointerup",c),document.removeEventListener("pointerleave",c),setTimeout((()=>{document.removeEventListener("click",u,!0);}),10);};};return t.addEventListener("pointerdown",o),()=>{r(),t.removeEventListener("pointerdown",o);}}class n extends t$1{constructor(t,e,i=0){var n,s,r,o,a,h,l;super(),this.totalDuration=e,this.numberOfChannels=i,this.minLength=0,this.maxLength=1/0,this.id=t.id||`region-${Math.random().toString(32).slice(2)}`,this.start=this.clampPosition(t.start),this.end=this.clampPosition(null!==(n=t.end)&&void 0!==n?n:t.start),this.drag=null===(s=t.drag)||void 0===s||s,this.resize=null===(r=t.resize)||void 0===r||r,this.color=null!==(o=t.color)&&void 0!==o?o:"rgba(0, 0, 0, 0.1)",this.minLength=null!==(a=t.minLength)&&void 0!==a?a:this.minLength,this.maxLength=null!==(h=t.maxLength)&&void 0!==h?h:this.maxLength,this.channelIdx=null!==(l=t.channelIdx)&&void 0!==l?l:-1,this.element=this.initElement(),this.setContent(t.content),this.setPart(),this.renderPosition(),this.initMouseEvents();}clampPosition(t){return Math.max(0,Math.min(this.totalDuration,t))}setPart(){const t=this.start===this.end;this.element.setAttribute("part",`${t?"marker":"region"} ${this.id}`);}addResizeHandles(t){const e=document.createElement("div");e.setAttribute("data-resize","left"),e.setAttribute("style","\n        position: absolute;\n        z-index: 2;\n        width: 6px;\n        height: 100%;\n        top: 0;\n        left: 0;\n        border-left: 2px solid rgba(0, 0, 0, 0.5);\n        border-radius: 2px 0 0 2px;\n        cursor: ew-resize;\n        word-break: keep-all;\n      "),e.setAttribute("part","region-handle region-handle-left");const n=e.cloneNode();n.setAttribute("data-resize","right"),n.style.left="",n.style.right="0",n.style.borderRight=n.style.borderLeft,n.style.borderLeft="",n.style.borderRadius="0 2px 2px 0",n.setAttribute("part","region-handle region-handle-right"),t.appendChild(e),t.appendChild(n);i$1(e,(t=>this.onResize(t,"start")),(()=>null),(()=>this.onEndResizing()),1),i$1(n,(t=>this.onResize(t,"end")),(()=>null),(()=>this.onEndResizing()),1);}removeResizeHandles(t){const e=t.querySelector('[data-resize="left"]'),i=t.querySelector('[data-resize="right"]');e&&t.removeChild(e),i&&t.removeChild(i);}initElement(){const t=document.createElement("div"),e=this.start===this.end;let i=0,n=100;return this.channelIdx>=0&&this.channelIdx<this.numberOfChannels&&(n=100/this.numberOfChannels,i=n*this.channelIdx),t.setAttribute("style",`\n      position: absolute;\n      top: ${i}%;\n      height: ${n}%;\n      background-color: ${e?"none":this.color};\n      border-left: ${e?"2px solid "+this.color:"none"};\n      border-radius: 2px;\n      box-sizing: border-box;\n      transition: background-color 0.2s ease;\n      cursor: ${this.drag?"grab":"default"};\n      pointer-events: all;\n    `),!e&&this.resize&&this.addResizeHandles(t),t}renderPosition(){const t=this.start/this.totalDuration,e=(this.totalDuration-this.end)/this.totalDuration;this.element.style.left=100*t+"%",this.element.style.right=100*e+"%";}initMouseEvents(){const{element:t}=this;t&&(t.addEventListener("click",(t=>this.emit("click",t))),t.addEventListener("mouseenter",(t=>this.emit("over",t))),t.addEventListener("mouseleave",(t=>this.emit("leave",t))),t.addEventListener("dblclick",(t=>this.emit("dblclick",t))),i$1(t,(t=>this.onMove(t)),(()=>this.onStartMoving()),(()=>this.onEndMoving())));}onStartMoving(){this.drag&&(this.element.style.cursor="grabbing");}onEndMoving(){this.drag&&(this.element.style.cursor="grab",this.emit("update-end"));}_onUpdate(t,e){if(!this.element.parentElement)return;const i=t/this.element.parentElement.clientWidth*this.totalDuration,n=e&&"start"!==e?this.start:this.start+i,s=e&&"end"!==e?this.end:this.end+i,r=s-n;n>=0&&s<=this.totalDuration&&n<=s&&r>=this.minLength&&r<=this.maxLength&&(this.start=n,this.end=s,this.renderPosition(),this.emit("update"));}onMove(t){this.drag&&this._onUpdate(t);}onResize(t,e){this.resize&&this._onUpdate(t,e);}onEndResizing(){this.resize&&this.emit("update-end");}_setTotalDuration(t){this.totalDuration=t,this.renderPosition();}play(){this.emit("play");}setContent(t){var e;if(null===(e=this.content)||void 0===e||e.remove(),t){if("string"==typeof t){this.content=document.createElement("div");const e=this.start===this.end;this.content.style.padding=`0.2em ${e?.2:.4}em`,this.content.textContent=t;}else this.content=t;this.content.setAttribute("part","region-content"),this.element.appendChild(this.content);}else this.content=void 0;}setOptions(t){var e,i;if(t.color&&(this.color=t.color,this.element.style.backgroundColor=this.color),void 0!==t.drag&&(this.drag=t.drag,this.element.style.cursor=this.drag?"grab":"default"),void 0!==t.start||void 0!==t.end){const n=this.start===this.end;this.start=this.clampPosition(null!==(e=t.start)&&void 0!==e?e:this.start),this.end=this.clampPosition(null!==(i=t.end)&&void 0!==i?i:n?this.start:this.end),this.renderPosition(),this.setPart();}if(t.content&&this.setContent(t.content),t.id&&(this.id=t.id,this.setPart()),void 0!==t.resize&&t.resize!==this.resize){const e=this.start===this.end;this.resize=t.resize,this.resize&&!e?this.addResizeHandles(this.element):this.removeResizeHandles(this.element);}}remove(){this.emit("remove"),this.element.remove(),this.element=null;}}let s$1 = class s extends e$1{constructor(t){super(t),this.regions=[],this.regionsContainer=this.initRegionsContainer();}static create(t){return new s(t)}onInit(){if(!this.wavesurfer)throw Error("WaveSurfer is not initialized");this.wavesurfer.getWrapper().appendChild(this.regionsContainer);let t=[];this.subscriptions.push(this.wavesurfer.on("timeupdate",(e=>{const i=this.regions.filter((t=>t.start<=e&&t.end>=e));i.forEach((e=>{t.includes(e)||this.emit("region-in",e);})),t.forEach((t=>{i.includes(t)||this.emit("region-out",t);})),t=i;})));}initRegionsContainer(){const t=document.createElement("div");return t.setAttribute("style","\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 3;\n      pointer-events: none;\n    "),t}getRegions(){return this.regions}avoidOverlapping(t){if(!t.content)return;const e=t.content,i=e.getBoundingClientRect().left,n=t.element.scrollWidth,s=this.regions.filter((e=>{if(e===t||!e.content)return !1;const s=e.content.getBoundingClientRect().left,r=e.element.scrollWidth;return i<s+r&&s<i+n})).map((t=>{var e;return (null===(e=t.content)||void 0===e?void 0:e.getBoundingClientRect().height)||0})).reduce(((t,e)=>t+e),0);e.style.marginTop=`${s}px`;}saveRegion(t){this.regionsContainer.appendChild(t.element),this.avoidOverlapping(t),this.regions.push(t);const e=[t.on("update-end",(()=>{this.avoidOverlapping(t),this.emit("region-updated",t);})),t.on("play",(()=>{var e,i;null===(e=this.wavesurfer)||void 0===e||e.play(),null===(i=this.wavesurfer)||void 0===i||i.setTime(t.start);})),t.on("click",(e=>{this.emit("region-clicked",t,e);})),t.on("dblclick",(e=>{this.emit("region-double-clicked",t,e);})),t.once("remove",(()=>{e.forEach((t=>t())),this.regions=this.regions.filter((e=>e!==t));}))];this.subscriptions.push(...e),this.emit("region-created",t);}addRegion(t){var e,i;if(!this.wavesurfer)throw Error("WaveSurfer is not initialized");const s=this.wavesurfer.getDuration(),r=null===(i=null===(e=this.wavesurfer)||void 0===e?void 0:e.getDecodedData())||void 0===i?void 0:i.numberOfChannels,o=new n(t,s,r);return s?this.saveRegion(o):this.subscriptions.push(this.wavesurfer.once("ready",(t=>{o._setTotalDuration(t),this.saveRegion(o);}))),o}enableDragSelection(t){var e,s;const r=null===(s=null===(e=this.wavesurfer)||void 0===e?void 0:e.getWrapper())||void 0===s?void 0:s.querySelector("div");if(!r)return ()=>{};let o=null,a=0;return i$1(r,((t,e,i)=>{o&&o._onUpdate(t,i>a?"end":"start");}),(e=>{var i,s;if(a=e,!this.wavesurfer)return;const r=this.wavesurfer.getDuration(),h=null===(s=null===(i=this.wavesurfer)||void 0===i?void 0:i.getDecodedData())||void 0===s?void 0:s.numberOfChannels,l=this.wavesurfer.getWrapper().clientWidth,d=e/l*r,u=(e+5)/l*r;o=new n(Object.assign(Object.assign({},t),{start:d,end:u}),r,h),this.regionsContainer.appendChild(o.element);}),(()=>{o&&(this.saveRegion(o),o=null);}))}clearRegions(){this.regions.forEach((t=>t.remove()));}destroy(){this.clearRegions(),super.destroy();}};

/* home/runner/work/gradio/gradio/js/audio/shared/VolumeLevels.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$9,
	check_outros: check_outros$6,
	create_component: create_component$7,
	destroy_component: destroy_component$7,
	detach: detach$9,
	empty: empty$6,
	group_outros: group_outros$6,
	init: init$9,
	insert: insert$9,
	mount_component: mount_component$7,
	safe_not_equal: safe_not_equal$9,
	transition_in: transition_in$7,
	transition_out: transition_out$7
} = window.__gradio__svelte__internal;
function create_if_block_2$5(ctx) {
	let volumehigh;
	let current;
	volumehigh = new VolumeHigh({});

	return {
		c() {
			create_component$7(volumehigh.$$.fragment);
		},
		m(target, anchor) {
			mount_component$7(volumehigh, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$7(volumehigh.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$7(volumehigh.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$7(volumehigh, detaching);
		}
	};
}

// (7:30) 
function create_if_block_1$5(ctx) {
	let volumelow;
	let current;
	volumelow = new VolumeLow({});

	return {
		c() {
			create_component$7(volumelow.$$.fragment);
		},
		m(target, anchor) {
			mount_component$7(volumelow, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$7(volumelow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$7(volumelow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$7(volumelow, detaching);
		}
	};
}

// (5:0) {#if currentVolume == 0}
function create_if_block$8(ctx) {
	let volumemuted;
	let current;
	volumemuted = new VolumeMuted({});

	return {
		c() {
			create_component$7(volumemuted.$$.fragment);
		},
		m(target, anchor) {
			mount_component$7(volumemuted, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$7(volumemuted.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$7(volumemuted.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$7(volumemuted, detaching);
		}
	};
}

function create_fragment$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_if_block_1$5, create_if_block_2$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*currentVolume*/ ctx[0] == 0) return 0;
		if (/*currentVolume*/ ctx[0] < 0.5) return 1;
		if (/*currentVolume*/ ctx[0] >= 0.5) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty$6();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert$9(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros$6();

					transition_out$7(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros$6();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in$7(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$7(if_block);
			current = true;
		},
		o(local) {
			transition_out$7(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$9(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { currentVolume } = $$props;

	$$self.$$set = $$props => {
		if ('currentVolume' in $$props) $$invalidate(0, currentVolume = $$props.currentVolume);
	};

	return [currentVolume];
}

class VolumeLevels extends SvelteComponent$9 {
	constructor(options) {
		super();
		init$9(this, options, instance$9, create_fragment$9, safe_not_equal$9, { currentVolume: 0 });
	}
}

const VolumeControl_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/shared/VolumeControl.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$8,
	attr: attr$6,
	binding_callbacks: binding_callbacks$6,
	detach: detach$8,
	element: element$6,
	init: init$8,
	insert: insert$8,
	listen: listen$3,
	noop: noop$4,
	run_all: run_all$2,
	safe_not_equal: safe_not_equal$8
} = window.__gradio__svelte__internal;
const { onMount: onMount$3 } = window.__gradio__svelte__internal;
function create_fragment$8(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element$6("input");
			attr$6(input, "id", "volume");
			attr$6(input, "class", "volume-slider svelte-wuo8j5");
			attr$6(input, "type", "range");
			attr$6(input, "min", "0");
			attr$6(input, "max", "1");
			attr$6(input, "step", "0.01");
			input.value = /*currentVolume*/ ctx[0];
		},
		m(target, anchor) {
			insert$8(target, input, anchor);
			/*input_binding*/ ctx[4](input);

			if (!mounted) {
				dispose = [
					listen$3(input, "focusout", /*focusout_handler*/ ctx[5]),
					listen$3(input, "input", /*input_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*currentVolume*/ 1) {
				input.value = /*currentVolume*/ ctx[0];
			}
		},
		i: noop$4,
		o: noop$4,
		d(detaching) {
			if (detaching) {
				detach$8(input);
			}

			/*input_binding*/ ctx[4](null);
			mounted = false;
			run_all$2(dispose);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { currentVolume = 1 } = $$props;
	let { show_volume_slider = false } = $$props;
	let { waveform } = $$props;
	let volumeElement;

	onMount$3(() => {
		adjustSlider();
	});

	const adjustSlider = () => {
		let slider = volumeElement;
		if (!slider) return;
		slider.style.background = `linear-gradient(to right, var(--color-accent) ${currentVolume * 100}%, var(--neutral-400) ${currentVolume * 100}%)`;
	};

	function input_binding($$value) {
		binding_callbacks$6[$$value ? 'unshift' : 'push'](() => {
			volumeElement = $$value;
			$$invalidate(3, volumeElement);
		});
	}

	const focusout_handler = () => $$invalidate(1, show_volume_slider = false);

	const input_handler = e => {
		if (e.target instanceof HTMLInputElement) {
			$$invalidate(0, currentVolume = parseFloat(e.target.value));
			waveform.setVolume(currentVolume);
		}
	};

	$$self.$$set = $$props => {
		if ('currentVolume' in $$props) $$invalidate(0, currentVolume = $$props.currentVolume);
		if ('show_volume_slider' in $$props) $$invalidate(1, show_volume_slider = $$props.show_volume_slider);
		if ('waveform' in $$props) $$invalidate(2, waveform = $$props.waveform);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*currentVolume*/ 1) {
			(adjustSlider());
		}
	};

	return [
		currentVolume,
		show_volume_slider,
		waveform,
		volumeElement,
		input_binding,
		focusout_handler,
		input_handler
	];
}

class VolumeControl extends SvelteComponent$8 {
	constructor(options) {
		super();

		init$8(this, options, instance$8, create_fragment$8, safe_not_equal$8, {
			currentVolume: 0,
			show_volume_slider: 1,
			waveform: 2
		});
	}
}

const WaveformControls_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/shared/WaveformControls.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$7,
	add_flush_callback: add_flush_callback$4,
	append: append$5,
	attr: attr$5,
	bind: bind$4,
	binding_callbacks: binding_callbacks$5,
	check_outros: check_outros$5,
	create_component: create_component$6,
	destroy_component: destroy_component$6,
	detach: detach$7,
	element: element$5,
	empty: empty$5,
	group_outros: group_outros$5,
	init: init$7,
	insert: insert$7,
	listen: listen$2,
	mount_component: mount_component$6,
	noop: noop$3,
	run_all: run_all$1,
	safe_not_equal: safe_not_equal$7,
	set_data: set_data$4,
	set_style: set_style$1,
	space: space$7,
	text: text$4,
	toggle_class,
	transition_in: transition_in$6,
	transition_out: transition_out$6
} = window.__gradio__svelte__internal;
function create_if_block_4$1(ctx) {
	let volumecontrol;
	let updating_currentVolume;
	let updating_show_volume_slider;
	let current;

	function volumecontrol_currentVolume_binding(value) {
		/*volumecontrol_currentVolume_binding*/ ctx[26](value);
	}

	function volumecontrol_show_volume_slider_binding(value) {
		/*volumecontrol_show_volume_slider_binding*/ ctx[27](value);
	}

	let volumecontrol_props = { waveform: /*waveform*/ ctx[2] };

	if (/*currentVolume*/ ctx[11] !== void 0) {
		volumecontrol_props.currentVolume = /*currentVolume*/ ctx[11];
	}

	if (/*show_volume_slider*/ ctx[1] !== void 0) {
		volumecontrol_props.show_volume_slider = /*show_volume_slider*/ ctx[1];
	}

	volumecontrol = new VolumeControl({ props: volumecontrol_props });
	binding_callbacks$5.push(() => bind$4(volumecontrol, 'currentVolume', volumecontrol_currentVolume_binding));
	binding_callbacks$5.push(() => bind$4(volumecontrol, 'show_volume_slider', volumecontrol_show_volume_slider_binding));

	return {
		c() {
			create_component$6(volumecontrol.$$.fragment);
		},
		m(target, anchor) {
			mount_component$6(volumecontrol, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const volumecontrol_changes = {};
			if (dirty[0] & /*waveform*/ 4) volumecontrol_changes.waveform = /*waveform*/ ctx[2];

			if (!updating_currentVolume && dirty[0] & /*currentVolume*/ 2048) {
				updating_currentVolume = true;
				volumecontrol_changes.currentVolume = /*currentVolume*/ ctx[11];
				add_flush_callback$4(() => updating_currentVolume = false);
			}

			if (!updating_show_volume_slider && dirty[0] & /*show_volume_slider*/ 2) {
				updating_show_volume_slider = true;
				volumecontrol_changes.show_volume_slider = /*show_volume_slider*/ ctx[1];
				add_flush_callback$4(() => updating_show_volume_slider = false);
			}

			volumecontrol.$set(volumecontrol_changes);
		},
		i(local) {
			if (current) return;
			transition_in$6(volumecontrol.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$6(volumecontrol.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$6(volumecontrol, detaching);
		}
	};
}

// (198:3) {:else}
function create_else_block_1$1(ctx) {
	let play;
	let current;
	play = new Play({});

	return {
		c() {
			create_component$6(play.$$.fragment);
		},
		m(target, anchor) {
			mount_component$6(play, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$6(play.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$6(play.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$6(play, detaching);
		}
	};
}

// (196:3) {#if playing}
function create_if_block_3$3(ctx) {
	let pause;
	let current;
	pause = new Pause({});

	return {
		c() {
			create_component$6(pause.$$.fragment);
		},
		m(target, anchor) {
			mount_component$6(pause, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$6(pause.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$6(pause.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$6(pause, detaching);
		}
	};
}

// (218:2) {#if showRedo && mode === ""}
function create_if_block_2$4(ctx) {
	let button;
	let undo;
	let current;
	let mounted;
	let dispose;
	undo = new Undo({});

	return {
		c() {
			button = element$5("button");
			create_component$6(undo.$$.fragment);
			attr$5(button, "class", "action icon svelte-t8ovdf");
			attr$5(button, "aria-label", "Reset audio");
		},
		m(target, anchor) {
			insert$7(target, button, anchor);
			mount_component$6(undo, button, null);
			current = true;

			if (!mounted) {
				dispose = listen$2(button, "click", /*click_handler_5*/ ctx[32]);
				mounted = true;
			}
		},
		p: noop$3,
		i(local) {
			if (current) return;
			transition_in$6(undo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$6(undo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$7(button);
			}

			destroy_component$6(undo);
			mounted = false;
			dispose();
		}
	};
}

// (232:2) {#if interactive}
function create_if_block$7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$4, create_else_block$7];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*mode*/ ctx[0] === "") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty$5();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert$7(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$5();

				transition_out$6(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$5();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in$6(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$6(if_block);
			current = true;
		},
		o(local) {
			transition_out$6(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$7(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (241:3) {:else}
function create_else_block$7(ctx) {
	let button0;
	let t1;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			button0 = element$5("button");
			button0.textContent = "Trim";
			t1 = space$7();
			button1 = element$5("button");
			button1.textContent = "Cancel";
			attr$5(button0, "class", "text-button svelte-t8ovdf");
			attr$5(button1, "class", "text-button svelte-t8ovdf");
		},
		m(target, anchor) {
			insert$7(target, button0, anchor);
			insert$7(target, t1, anchor);
			insert$7(target, button1, anchor);

			if (!mounted) {
				dispose = [
					listen$2(button0, "click", /*trimAudio*/ ctx[13]),
					listen$2(button1, "click", /*toggleTrimmingMode*/ ctx[15])
				];

				mounted = true;
			}
		},
		p: noop$3,
		i: noop$3,
		o: noop$3,
		d(detaching) {
			if (detaching) {
				detach$7(button0);
				detach$7(t1);
				detach$7(button1);
			}

			mounted = false;
			run_all$1(dispose);
		}
	};
}

// (233:3) {#if mode === ""}
function create_if_block_1$4(ctx) {
	let button;
	let trim;
	let current;
	let mounted;
	let dispose;
	trim = new Trim({});

	return {
		c() {
			button = element$5("button");
			create_component$6(trim.$$.fragment);
			attr$5(button, "class", "action icon svelte-t8ovdf");
			attr$5(button, "aria-label", "Trim audio to selection");
		},
		m(target, anchor) {
			insert$7(target, button, anchor);
			mount_component$6(trim, button, null);
			current = true;

			if (!mounted) {
				dispose = listen$2(button, "click", /*toggleTrimmingMode*/ ctx[15]);
				mounted = true;
			}
		},
		p: noop$3,
		i(local) {
			if (current) return;
			transition_in$6(trim.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$6(trim.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$7(button);
			}

			destroy_component$6(trim);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$7(ctx) {
	let div3;
	let div0;
	let button0;
	let volumelevels;
	let t0;
	let t1;
	let button1;
	let span;
	let t2;
	let t3;
	let button1_aria_label_value;
	let t4;
	let div1;
	let button2;
	let backward;
	let button2_aria_label_value;
	let t5;
	let button3;
	let current_block_type_index;
	let if_block1;
	let button3_aria_label_value;
	let t6;
	let button4;
	let forward;
	let button4_aria_label_value;
	let t7;
	let div2;
	let t8;
	let current;
	let mounted;
	let dispose;

	volumelevels = new VolumeLevels({
			props: { currentVolume: /*currentVolume*/ ctx[11] }
		});

	let if_block0 = /*show_volume_slider*/ ctx[1] && create_if_block_4$1(ctx);
	backward = new Backward({});
	const if_block_creators = [create_if_block_3$3, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*playing*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	forward = new Forward({});
	let if_block2 = /*showRedo*/ ctx[6] && /*mode*/ ctx[0] === "" && create_if_block_2$4(ctx);
	let if_block3 = /*interactive*/ ctx[7] && create_if_block$7(ctx);

	return {
		c() {
			div3 = element$5("div");
			div0 = element$5("div");
			button0 = element$5("button");
			create_component$6(volumelevels.$$.fragment);
			t0 = space$7();
			if (if_block0) if_block0.c();
			t1 = space$7();
			button1 = element$5("button");
			span = element$5("span");
			t2 = text$4(/*playbackSpeed*/ ctx[10]);
			t3 = text$4("x");
			t4 = space$7();
			div1 = element$5("div");
			button2 = element$5("button");
			create_component$6(backward.$$.fragment);
			t5 = space$7();
			button3 = element$5("button");
			if_block1.c();
			t6 = space$7();
			button4 = element$5("button");
			create_component$6(forward.$$.fragment);
			t7 = space$7();
			div2 = element$5("div");
			if (if_block2) if_block2.c();
			t8 = space$7();
			if (if_block3) if_block3.c();
			attr$5(button0, "class", "action icon volume svelte-t8ovdf");
			attr$5(button0, "aria-label", "Adjust volume");

			set_style$1(button0, "color", /*show_volume_slider*/ ctx[1]
			? "var(--color-accent)"
			: "var(--neutral-400)");

			attr$5(span, "class", "svelte-t8ovdf");
			attr$5(button1, "class", "playback icon svelte-t8ovdf");
			attr$5(button1, "aria-label", button1_aria_label_value = `Adjust playback speed to ${/*playbackSpeeds*/ ctx[12][(/*playbackSpeeds*/ ctx[12].indexOf(/*playbackSpeed*/ ctx[10]) + 1) % /*playbackSpeeds*/ ctx[12].length]}x`);
			toggle_class(button1, "hidden", /*show_volume_slider*/ ctx[1]);
			attr$5(div0, "class", "control-wrapper svelte-t8ovdf");
			attr$5(button2, "class", "rewind icon svelte-t8ovdf");
			attr$5(button2, "aria-label", button2_aria_label_value = `Skip backwards by ${getSkipRewindAmount(/*audioDuration*/ ctx[3], /*waveform_options*/ ctx[9].skip_length)} seconds`);
			attr$5(button3, "class", "play-pause-button icon svelte-t8ovdf");

			attr$5(button3, "aria-label", button3_aria_label_value = /*playing*/ ctx[5]
			? /*i18n*/ ctx[4]("audio.pause")
			: /*i18n*/ ctx[4]("audio.play"));

			attr$5(button4, "class", "skip icon svelte-t8ovdf");
			attr$5(button4, "aria-label", button4_aria_label_value = "Skip forward by " + getSkipRewindAmount(/*audioDuration*/ ctx[3], /*waveform_options*/ ctx[9].skip_length) + " seconds");
			attr$5(div1, "class", "play-pause-wrapper svelte-t8ovdf");
			attr$5(div2, "class", "settings-wrapper svelte-t8ovdf");
			attr$5(div3, "class", "controls svelte-t8ovdf");
			attr$5(div3, "data-testid", "waveform-controls");
		},
		m(target, anchor) {
			insert$7(target, div3, anchor);
			append$5(div3, div0);
			append$5(div0, button0);
			mount_component$6(volumelevels, button0, null);
			append$5(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append$5(div0, t1);
			append$5(div0, button1);
			append$5(button1, span);
			append$5(span, t2);
			append$5(span, t3);
			append$5(div3, t4);
			append$5(div3, div1);
			append$5(div1, button2);
			mount_component$6(backward, button2, null);
			append$5(div1, t5);
			append$5(div1, button3);
			if_blocks[current_block_type_index].m(button3, null);
			append$5(div1, t6);
			append$5(div1, button4);
			mount_component$6(forward, button4, null);
			append$5(div3, t7);
			append$5(div3, div2);
			if (if_block2) if_block2.m(div2, null);
			append$5(div2, t8);
			if (if_block3) if_block3.m(div2, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen$2(button0, "click", /*click_handler*/ ctx[25]),
					listen$2(button1, "click", /*click_handler_1*/ ctx[28]),
					listen$2(button2, "click", /*click_handler_2*/ ctx[29]),
					listen$2(button3, "click", /*click_handler_3*/ ctx[30]),
					listen$2(button4, "click", /*click_handler_4*/ ctx[31])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const volumelevels_changes = {};
			if (dirty[0] & /*currentVolume*/ 2048) volumelevels_changes.currentVolume = /*currentVolume*/ ctx[11];
			volumelevels.$set(volumelevels_changes);

			if (dirty[0] & /*show_volume_slider*/ 2) {
				set_style$1(button0, "color", /*show_volume_slider*/ ctx[1]
				? "var(--color-accent)"
				: "var(--neutral-400)");
			}

			if (/*show_volume_slider*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_volume_slider*/ 2) {
						transition_in$6(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					transition_in$6(if_block0, 1);
					if_block0.m(div0, t1);
				}
			} else if (if_block0) {
				group_outros$5();

				transition_out$6(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$5();
			}

			if (!current || dirty[0] & /*playbackSpeed*/ 1024) set_data$4(t2, /*playbackSpeed*/ ctx[10]);

			if (!current || dirty[0] & /*playbackSpeed*/ 1024 && button1_aria_label_value !== (button1_aria_label_value = `Adjust playback speed to ${/*playbackSpeeds*/ ctx[12][(/*playbackSpeeds*/ ctx[12].indexOf(/*playbackSpeed*/ ctx[10]) + 1) % /*playbackSpeeds*/ ctx[12].length]}x`)) {
				attr$5(button1, "aria-label", button1_aria_label_value);
			}

			if (!current || dirty[0] & /*show_volume_slider*/ 2) {
				toggle_class(button1, "hidden", /*show_volume_slider*/ ctx[1]);
			}

			if (!current || dirty[0] & /*audioDuration, waveform_options*/ 520 && button2_aria_label_value !== (button2_aria_label_value = `Skip backwards by ${getSkipRewindAmount(/*audioDuration*/ ctx[3], /*waveform_options*/ ctx[9].skip_length)} seconds`)) {
				attr$5(button2, "aria-label", button2_aria_label_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros$5();

				transition_out$6(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$5();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in$6(if_block1, 1);
				if_block1.m(button3, null);
			}

			if (!current || dirty[0] & /*playing, i18n*/ 48 && button3_aria_label_value !== (button3_aria_label_value = /*playing*/ ctx[5]
			? /*i18n*/ ctx[4]("audio.pause")
			: /*i18n*/ ctx[4]("audio.play"))) {
				attr$5(button3, "aria-label", button3_aria_label_value);
			}

			if (!current || dirty[0] & /*audioDuration, waveform_options*/ 520 && button4_aria_label_value !== (button4_aria_label_value = "Skip forward by " + getSkipRewindAmount(/*audioDuration*/ ctx[3], /*waveform_options*/ ctx[9].skip_length) + " seconds")) {
				attr$5(button4, "aria-label", button4_aria_label_value);
			}

			if (/*showRedo*/ ctx[6] && /*mode*/ ctx[0] === "") {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*showRedo, mode*/ 65) {
						transition_in$6(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$4(ctx);
					if_block2.c();
					transition_in$6(if_block2, 1);
					if_block2.m(div2, t8);
				}
			} else if (if_block2) {
				group_outros$5();

				transition_out$6(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros$5();
			}

			if (/*interactive*/ ctx[7]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*interactive*/ 128) {
						transition_in$6(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$7(ctx);
					if_block3.c();
					transition_in$6(if_block3, 1);
					if_block3.m(div2, null);
				}
			} else if (if_block3) {
				group_outros$5();

				transition_out$6(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros$5();
			}
		},
		i(local) {
			if (current) return;
			transition_in$6(volumelevels.$$.fragment, local);
			transition_in$6(if_block0);
			transition_in$6(backward.$$.fragment, local);
			transition_in$6(if_block1);
			transition_in$6(forward.$$.fragment, local);
			transition_in$6(if_block2);
			transition_in$6(if_block3);
			current = true;
		},
		o(local) {
			transition_out$6(volumelevels.$$.fragment, local);
			transition_out$6(if_block0);
			transition_out$6(backward.$$.fragment, local);
			transition_out$6(if_block1);
			transition_out$6(forward.$$.fragment, local);
			transition_out$6(if_block2);
			transition_out$6(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$7(div3);
			}

			destroy_component$6(volumelevels);
			if (if_block0) if_block0.d();
			destroy_component$6(backward);
			if_blocks[current_block_type_index].d();
			destroy_component$6(forward);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all$1(dispose);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { waveform } = $$props;
	let { audioDuration } = $$props;
	let { i18n } = $$props;
	let { playing } = $$props;
	let { showRedo = false } = $$props;
	let { interactive = false } = $$props;
	let { handle_trim_audio } = $$props;
	let { mode = "" } = $$props;
	let { container } = $$props;
	let { handle_reset_value } = $$props;
	let { waveform_options = {} } = $$props;
	let { trim_region_settings = {} } = $$props;
	let { show_volume_slider = false } = $$props;
	let { trimDuration = 0 } = $$props;
	let playbackSpeeds = [0.5, 1, 1.5, 2];
	let playbackSpeed = playbackSpeeds[1];
	let trimRegion;
	let activeRegion = null;
	let leftRegionHandle;
	let rightRegionHandle;
	let activeHandle = "";
	let currentVolume = 1;

	const addTrimRegion = () => {
		$$invalidate(21, activeRegion = trimRegion.addRegion({
			start: audioDuration / 4,
			end: audioDuration / 2,
			...trim_region_settings
		}));

		$$invalidate(16, trimDuration = activeRegion.end - activeRegion.start);
	};

	const trimAudio = () => {
		if (waveform && trimRegion) {
			if (activeRegion) {
				const start = activeRegion.start;
				const end = activeRegion.end;
				handle_trim_audio(start, end);
				$$invalidate(0, mode = "");
				$$invalidate(21, activeRegion = null);
			}
		}
	};

	const clearRegions = () => {
		trimRegion?.getRegions().forEach(region => {
			region.remove();
		});

		trimRegion?.clearRegions();
	};

	const toggleTrimmingMode = () => {
		clearRegions();

		if (mode === "edit") {
			$$invalidate(0, mode = "");
		} else {
			$$invalidate(0, mode = "edit");
			addTrimRegion();
		}
	};

	const adjustRegionHandles = (handle, key) => {
		let newStart;
		let newEnd;
		if (!activeRegion) return;

		if (handle === "left") {
			if (key === "ArrowLeft") {
				newStart = activeRegion.start - 0.05;
				newEnd = activeRegion.end;
			} else {
				newStart = activeRegion.start + 0.05;
				newEnd = activeRegion.end;
			}
		} else {
			if (key === "ArrowLeft") {
				newStart = activeRegion.start;
				newEnd = activeRegion.end - 0.05;
			} else {
				newStart = activeRegion.start;
				newEnd = activeRegion.end + 0.05;
			}
		}

		activeRegion.setOptions({ start: newStart, end: newEnd });
		$$invalidate(16, trimDuration = activeRegion.end - activeRegion.start);
	};

	const click_handler = () => $$invalidate(1, show_volume_slider = !show_volume_slider);

	function volumecontrol_currentVolume_binding(value) {
		currentVolume = value;
		$$invalidate(11, currentVolume);
	}

	function volumecontrol_show_volume_slider_binding(value) {
		show_volume_slider = value;
		$$invalidate(1, show_volume_slider);
	}

	const click_handler_1 = () => {
		$$invalidate(10, playbackSpeed = playbackSpeeds[(playbackSpeeds.indexOf(playbackSpeed) + 1) % playbackSpeeds.length]);
		waveform.setPlaybackRate(playbackSpeed);
	};

	const click_handler_2 = () => waveform.skip(getSkipRewindAmount(audioDuration, waveform_options.skip_length) * -1);
	const click_handler_3 = () => waveform.playPause();
	const click_handler_4 = () => waveform.skip(getSkipRewindAmount(audioDuration, waveform_options.skip_length));

	const click_handler_5 = () => {
		handle_reset_value();
		clearRegions();
		$$invalidate(0, mode = "");
	};

	$$self.$$set = $$props => {
		if ('waveform' in $$props) $$invalidate(2, waveform = $$props.waveform);
		if ('audioDuration' in $$props) $$invalidate(3, audioDuration = $$props.audioDuration);
		if ('i18n' in $$props) $$invalidate(4, i18n = $$props.i18n);
		if ('playing' in $$props) $$invalidate(5, playing = $$props.playing);
		if ('showRedo' in $$props) $$invalidate(6, showRedo = $$props.showRedo);
		if ('interactive' in $$props) $$invalidate(7, interactive = $$props.interactive);
		if ('handle_trim_audio' in $$props) $$invalidate(17, handle_trim_audio = $$props.handle_trim_audio);
		if ('mode' in $$props) $$invalidate(0, mode = $$props.mode);
		if ('container' in $$props) $$invalidate(18, container = $$props.container);
		if ('handle_reset_value' in $$props) $$invalidate(8, handle_reset_value = $$props.handle_reset_value);
		if ('waveform_options' in $$props) $$invalidate(9, waveform_options = $$props.waveform_options);
		if ('trim_region_settings' in $$props) $$invalidate(19, trim_region_settings = $$props.trim_region_settings);
		if ('show_volume_slider' in $$props) $$invalidate(1, show_volume_slider = $$props.show_volume_slider);
		if ('trimDuration' in $$props) $$invalidate(16, trimDuration = $$props.trimDuration);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*waveform*/ 4) {
			$$invalidate(20, trimRegion = waveform.registerPlugin(s$1.create()));
		}

		if ($$self.$$.dirty[0] & /*trimRegion*/ 1048576) {
			trimRegion?.on("region-out", region => {
				region.play();
			});
		}

		if ($$self.$$.dirty[0] & /*trimRegion*/ 1048576) {
			trimRegion?.on("region-updated", region => {
				$$invalidate(16, trimDuration = region.end - region.start);
			});
		}

		if ($$self.$$.dirty[0] & /*trimRegion*/ 1048576) {
			trimRegion?.on("region-clicked", (region, e) => {
				e.stopPropagation(); // prevent triggering a click on the waveform
				$$invalidate(21, activeRegion = region);
				region.play();
			});
		}

		if ($$self.$$.dirty[0] & /*activeRegion, container, leftRegionHandle, rightRegionHandle, trimRegion*/ 15990784) {
			if (activeRegion) {
				const shadowRoot = container.children[0].shadowRoot;
				$$invalidate(23, rightRegionHandle = shadowRoot.querySelector('[data-resize="right"]'));
				$$invalidate(22, leftRegionHandle = shadowRoot.querySelector('[data-resize="left"]'));

				if (leftRegionHandle && rightRegionHandle) {
					leftRegionHandle.setAttribute("role", "button");
					rightRegionHandle.setAttribute("role", "button");
					leftRegionHandle?.setAttribute("aria-label", "Drag to adjust start time");
					rightRegionHandle?.setAttribute("aria-label", "Drag to adjust end time");
					leftRegionHandle?.setAttribute("tabindex", "0");
					rightRegionHandle?.setAttribute("tabindex", "0");

					leftRegionHandle.addEventListener("focus", () => {
						if (trimRegion) $$invalidate(24, activeHandle = "left");
					});

					rightRegionHandle.addEventListener("focus", () => {
						if (trimRegion) $$invalidate(24, activeHandle = "right");
					});
				}
			}
		}

		if ($$self.$$.dirty[0] & /*trimRegion, activeHandle*/ 17825792) {
			trimRegion && window.addEventListener("keydown", e => {
				if (e.key === "ArrowLeft") {
					adjustRegionHandles(activeHandle, "ArrowLeft");
				} else if (e.key === "ArrowRight") {
					adjustRegionHandles(activeHandle, "ArrowRight");
				}
			});
		}
	};

	return [
		mode,
		show_volume_slider,
		waveform,
		audioDuration,
		i18n,
		playing,
		showRedo,
		interactive,
		handle_reset_value,
		waveform_options,
		playbackSpeed,
		currentVolume,
		playbackSpeeds,
		trimAudio,
		clearRegions,
		toggleTrimmingMode,
		trimDuration,
		handle_trim_audio,
		container,
		trim_region_settings,
		trimRegion,
		activeRegion,
		leftRegionHandle,
		rightRegionHandle,
		activeHandle,
		click_handler,
		volumecontrol_currentVolume_binding,
		volumecontrol_show_volume_slider_binding,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class WaveformControls extends SvelteComponent$7 {
	constructor(options) {
		super();

		init$7(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal$7,
			{
				waveform: 2,
				audioDuration: 3,
				i18n: 4,
				playing: 5,
				showRedo: 6,
				interactive: 7,
				handle_trim_audio: 17,
				mode: 0,
				container: 18,
				handle_reset_value: 8,
				waveform_options: 9,
				trim_region_settings: 19,
				show_volume_slider: 1,
				trimDuration: 16
			},
			null,
			[-1, -1]
		);
	}
}

const AudioPlayer_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/player/AudioPlayer.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$6,
	add_flush_callback: add_flush_callback$3,
	append: append$4,
	attr: attr$4,
	bind: bind$3,
	binding_callbacks: binding_callbacks$4,
	check_outros: check_outros$4,
	create_component: create_component$5,
	destroy_component: destroy_component$5,
	detach: detach$6,
	element: element$4,
	empty: empty$4,
	group_outros: group_outros$4,
	init: init$6,
	insert: insert$6,
	mount_component: mount_component$5,
	noop: noop$2,
	safe_not_equal: safe_not_equal$6,
	set_data: set_data$3,
	space: space$6,
	src_url_equal,
	text: text$3,
	transition_in: transition_in$5,
	transition_out: transition_out$5
} = window.__gradio__svelte__internal;
const { onMount: onMount$2 } = window.__gradio__svelte__internal;const { createEventDispatcher: createEventDispatcher$4 } = window.__gradio__svelte__internal;
function create_else_block$6(ctx) {
	let div4;
	let div1;
	let div0;
	let t0;
	let div3;
	let time0;
	let t2;
	let div2;
	let t3;
	let time1;
	let t5;
	let div4_data_testid_value;
	let current;
	let if_block0 = /*mode*/ ctx[0] === "edit" && /*trimDuration*/ ctx[15] > 0 && create_if_block_3$2(ctx);
	let if_block1 = /*waveform*/ ctx[10] && create_if_block_2$3(ctx);

	return {
		c() {
			div4 = element$4("div");
			div1 = element$4("div");
			div0 = element$4("div");
			t0 = space$6();
			div3 = element$4("div");
			time0 = element$4("time");
			time0.textContent = "0:00";
			t2 = space$6();
			div2 = element$4("div");
			if (if_block0) if_block0.c();
			t3 = space$6();
			time1 = element$4("time");
			time1.textContent = "0:00";
			t5 = space$6();
			if (if_block1) if_block1.c();
			attr$4(div0, "id", "waveform");
			attr$4(div0, "class", "svelte-q2r1hx");
			attr$4(div1, "class", "waveform-container svelte-q2r1hx");
			attr$4(time0, "id", "time");
			attr$4(time0, "class", "svelte-q2r1hx");
			attr$4(time1, "id", "duration");
			attr$4(time1, "class", "svelte-q2r1hx");
			attr$4(div3, "class", "timestamps svelte-q2r1hx");
			attr$4(div4, "class", "component-wrapper svelte-q2r1hx");

			attr$4(div4, "data-testid", div4_data_testid_value = /*label*/ ctx[2]
			? "waveform-" + /*label*/ ctx[2]
			: "unlabelled-audio");
		},
		m(target, anchor) {
			insert$6(target, div4, anchor);
			append$4(div4, div1);
			append$4(div1, div0);
			/*div0_binding*/ ctx[21](div0);
			append$4(div4, t0);
			append$4(div4, div3);
			append$4(div3, time0);
			/*time0_binding*/ ctx[22](time0);
			append$4(div3, t2);
			append$4(div3, div2);
			if (if_block0) if_block0.m(div2, null);
			append$4(div2, t3);
			append$4(div2, time1);
			/*time1_binding*/ ctx[23](time1);
			append$4(div4, t5);
			if (if_block1) if_block1.m(div4, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*mode*/ ctx[0] === "edit" && /*trimDuration*/ ctx[15] > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(div2, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*waveform*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*waveform*/ 1024) {
						transition_in$5(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$3(ctx);
					if_block1.c();
					transition_in$5(if_block1, 1);
					if_block1.m(div4, null);
				}
			} else if (if_block1) {
				group_outros$4();

				transition_out$5(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$4();
			}

			if (!current || dirty & /*label*/ 4 && div4_data_testid_value !== (div4_data_testid_value = /*label*/ ctx[2]
			? "waveform-" + /*label*/ ctx[2]
			: "unlabelled-audio")) {
				attr$4(div4, "data-testid", div4_data_testid_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$5(if_block1);
			current = true;
		},
		o(local) {
			transition_out$5(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$6(div4);
			}

			/*div0_binding*/ ctx[21](null);
			/*time0_binding*/ ctx[22](null);
			if (if_block0) if_block0.d();
			/*time1_binding*/ ctx[23](null);
			if (if_block1) if_block1.d();
		}
	};
}

// (111:26) 
function create_if_block_1$3(ctx) {
	let audio;
	let audio_src_value;
	let audio_autoplay_value;

	return {
		c() {
			audio = element$4("audio");
			attr$4(audio, "class", "standard-player svelte-q2r1hx");
			if (!src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1].url)) attr$4(audio, "src", audio_src_value);
			audio.controls = true;
			audio.autoplay = audio_autoplay_value = /*waveform_settings*/ ctx[6].autoplay;
		},
		m(target, anchor) {
			insert$6(target, audio, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && !src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1].url)) {
				attr$4(audio, "src", audio_src_value);
			}

			if (dirty & /*waveform_settings*/ 64 && audio_autoplay_value !== (audio_autoplay_value = /*waveform_settings*/ ctx[6].autoplay)) {
				audio.autoplay = audio_autoplay_value;
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) {
				detach$6(audio);
			}
		}
	};
}

// (107:0) {#if value === null}
function create_if_block$6(ctx) {
	let empty_1;
	let current;

	empty_1 = new Empty({
			props: {
				size: "small",
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component$5(empty_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$5(empty_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const empty_1_changes = {};

			if (dirty & /*$$scope*/ 1073741824) {
				empty_1_changes.$$scope = { dirty, ctx };
			}

			empty_1.$set(empty_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$5(empty_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$5(empty_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$5(empty_1, detaching);
		}
	};
}

// (130:4) {#if mode === "edit" && trimDuration > 0}
function create_if_block_3$2(ctx) {
	let time;
	let t_value = /*formatTime*/ ctx[17](/*trimDuration*/ ctx[15]) + "";
	let t;

	return {
		c() {
			time = element$4("time");
			t = text$3(t_value);
			attr$4(time, "id", "trim-duration");
			attr$4(time, "class", "svelte-q2r1hx");
		},
		m(target, anchor) {
			insert$6(target, time, anchor);
			append$4(time, t);
		},
		p(ctx, dirty) {
			if (dirty & /*trimDuration*/ 32768 && t_value !== (t_value = /*formatTime*/ ctx[17](/*trimDuration*/ ctx[15]) + "")) set_data$3(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$6(time);
			}
		}
	};
}

// (137:2) {#if waveform}
function create_if_block_2$3(ctx) {
	let waveformcontrols;
	let updating_mode;
	let updating_trimDuration;
	let updating_show_volume_slider;
	let current;

	function waveformcontrols_mode_binding(value) {
		/*waveformcontrols_mode_binding*/ ctx[24](value);
	}

	function waveformcontrols_trimDuration_binding(value) {
		/*waveformcontrols_trimDuration_binding*/ ctx[25](value);
	}

	function waveformcontrols_show_volume_slider_binding(value) {
		/*waveformcontrols_show_volume_slider_binding*/ ctx[26](value);
	}

	let waveformcontrols_props = {
		container: /*container*/ ctx[9],
		waveform: /*waveform*/ ctx[10],
		playing: /*playing*/ ctx[13],
		audioDuration: /*audioDuration*/ ctx[14],
		i18n: /*i18n*/ ctx[3],
		interactive: /*interactive*/ ctx[4],
		handle_trim_audio: /*handle_trim_audio*/ ctx[18],
		showRedo: /*interactive*/ ctx[4],
		handle_reset_value: /*handle_reset_value*/ ctx[8],
		waveform_options: /*waveform_options*/ ctx[7],
		trim_region_settings: /*trim_region_settings*/ ctx[5]
	};

	if (/*mode*/ ctx[0] !== void 0) {
		waveformcontrols_props.mode = /*mode*/ ctx[0];
	}

	if (/*trimDuration*/ ctx[15] !== void 0) {
		waveformcontrols_props.trimDuration = /*trimDuration*/ ctx[15];
	}

	if (/*show_volume_slider*/ ctx[16] !== void 0) {
		waveformcontrols_props.show_volume_slider = /*show_volume_slider*/ ctx[16];
	}

	waveformcontrols = new WaveformControls({ props: waveformcontrols_props });
	binding_callbacks$4.push(() => bind$3(waveformcontrols, 'mode', waveformcontrols_mode_binding));
	binding_callbacks$4.push(() => bind$3(waveformcontrols, 'trimDuration', waveformcontrols_trimDuration_binding));
	binding_callbacks$4.push(() => bind$3(waveformcontrols, 'show_volume_slider', waveformcontrols_show_volume_slider_binding));

	return {
		c() {
			create_component$5(waveformcontrols.$$.fragment);
		},
		m(target, anchor) {
			mount_component$5(waveformcontrols, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const waveformcontrols_changes = {};
			if (dirty & /*container*/ 512) waveformcontrols_changes.container = /*container*/ ctx[9];
			if (dirty & /*waveform*/ 1024) waveformcontrols_changes.waveform = /*waveform*/ ctx[10];
			if (dirty & /*playing*/ 8192) waveformcontrols_changes.playing = /*playing*/ ctx[13];
			if (dirty & /*audioDuration*/ 16384) waveformcontrols_changes.audioDuration = /*audioDuration*/ ctx[14];
			if (dirty & /*i18n*/ 8) waveformcontrols_changes.i18n = /*i18n*/ ctx[3];
			if (dirty & /*interactive*/ 16) waveformcontrols_changes.interactive = /*interactive*/ ctx[4];
			if (dirty & /*interactive*/ 16) waveformcontrols_changes.showRedo = /*interactive*/ ctx[4];
			if (dirty & /*handle_reset_value*/ 256) waveformcontrols_changes.handle_reset_value = /*handle_reset_value*/ ctx[8];
			if (dirty & /*waveform_options*/ 128) waveformcontrols_changes.waveform_options = /*waveform_options*/ ctx[7];
			if (dirty & /*trim_region_settings*/ 32) waveformcontrols_changes.trim_region_settings = /*trim_region_settings*/ ctx[5];

			if (!updating_mode && dirty & /*mode*/ 1) {
				updating_mode = true;
				waveformcontrols_changes.mode = /*mode*/ ctx[0];
				add_flush_callback$3(() => updating_mode = false);
			}

			if (!updating_trimDuration && dirty & /*trimDuration*/ 32768) {
				updating_trimDuration = true;
				waveformcontrols_changes.trimDuration = /*trimDuration*/ ctx[15];
				add_flush_callback$3(() => updating_trimDuration = false);
			}

			if (!updating_show_volume_slider && dirty & /*show_volume_slider*/ 65536) {
				updating_show_volume_slider = true;
				waveformcontrols_changes.show_volume_slider = /*show_volume_slider*/ ctx[16];
				add_flush_callback$3(() => updating_show_volume_slider = false);
			}

			waveformcontrols.$set(waveformcontrols_changes);
		},
		i(local) {
			if (current) return;
			transition_in$5(waveformcontrols.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$5(waveformcontrols.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$5(waveformcontrols, detaching);
		}
	};
}

// (108:1) <Empty size="small">
function create_default_slot$3(ctx) {
	let music;
	let current;
	music = new Music({});

	return {
		c() {
			create_component$5(music.$$.fragment);
		},
		m(target, anchor) {
			mount_component$5(music, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$5(music.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$5(music.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$5(music, detaching);
		}
	};
}

function create_fragment$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_if_block_1$3, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[1] === null) return 0;
		if (/*value*/ ctx[1].is_stream) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty$4();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert$6(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$4();

				transition_out$5(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$4();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in$5(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$5(if_block);
			current = true;
		},
		o(local) {
			transition_out$5(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$6(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let url;
	let { value = null } = $$props;
	let { label } = $$props;
	let { i18n } = $$props;
	let { dispatch_blob = () => Promise.resolve() } = $$props;
	let { interactive = false } = $$props;
	let { trim_region_settings = {} } = $$props;
	let { waveform_settings } = $$props;
	let { waveform_options } = $$props;
	let { mode = "" } = $$props;

	let { handle_reset_value = () => {
		
	} } = $$props;

	let container;
	let waveform;
	let playing = false;
	let timeRef;
	let durationRef;
	let audioDuration;
	let trimDuration = 0;
	let show_volume_slider = false;
	const dispatch = createEventDispatcher$4();

	const formatTime = seconds => {
		const minutes = Math.floor(seconds / 60);
		const secondsRemainder = Math.round(seconds) % 60;
		const paddedSeconds = `0${secondsRemainder}`.slice(-2);
		return `${minutes}:${paddedSeconds}`;
	};

	const create_waveform = () => {
		$$invalidate(10, waveform = WaveSurfer.create({
			container,
			url: value?.url,
			...waveform_settings
		}));
	};

	const handle_trim_audio = async (start, end) => {
		$$invalidate(0, mode = "");
		const decodedData = waveform?.getDecodedData();

		if (decodedData) await process_audio(decodedData, start, end).then(async trimmedBlob => {
			await dispatch_blob([trimmedBlob], "change");
			waveform?.destroy();
			create_waveform();
		});

		dispatch("edit");
	};

	async function load_audio(data) {
		await resolve_wasm_src(data).then(resolved_src => {
			if (!resolved_src || value?.is_stream) return;
			return waveform?.load(resolved_src);
		});
	}

	onMount$2(() => {
		window.addEventListener("keydown", e => {
			if (!waveform || show_volume_slider) return;

			if (e.key === "ArrowRight" && mode !== "edit") {
				skipAudio(waveform, 0.1);
			} else if (e.key === "ArrowLeft" && mode !== "edit") {
				skipAudio(waveform, -0.1);
			}
		});
	});

	function div0_binding($$value) {
		binding_callbacks$4[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			($$invalidate(9, container), $$invalidate(10, waveform));
		});
	}

	function time0_binding($$value) {
		binding_callbacks$4[$$value ? 'unshift' : 'push'](() => {
			timeRef = $$value;
			($$invalidate(11, timeRef), $$invalidate(10, waveform));
		});
	}

	function time1_binding($$value) {
		binding_callbacks$4[$$value ? 'unshift' : 'push'](() => {
			durationRef = $$value;
			($$invalidate(12, durationRef), $$invalidate(10, waveform));
		});
	}

	function waveformcontrols_mode_binding(value) {
		mode = value;
		$$invalidate(0, mode);
	}

	function waveformcontrols_trimDuration_binding(value) {
		trimDuration = value;
		$$invalidate(15, trimDuration);
	}

	function waveformcontrols_show_volume_slider_binding(value) {
		show_volume_slider = value;
		$$invalidate(16, show_volume_slider);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('i18n' in $$props) $$invalidate(3, i18n = $$props.i18n);
		if ('dispatch_blob' in $$props) $$invalidate(19, dispatch_blob = $$props.dispatch_blob);
		if ('interactive' in $$props) $$invalidate(4, interactive = $$props.interactive);
		if ('trim_region_settings' in $$props) $$invalidate(5, trim_region_settings = $$props.trim_region_settings);
		if ('waveform_settings' in $$props) $$invalidate(6, waveform_settings = $$props.waveform_settings);
		if ('waveform_options' in $$props) $$invalidate(7, waveform_options = $$props.waveform_options);
		if ('mode' in $$props) $$invalidate(0, mode = $$props.mode);
		if ('handle_reset_value' in $$props) $$invalidate(8, handle_reset_value = $$props.handle_reset_value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 2) {
			$$invalidate(20, url = value?.url);
		}

		if ($$self.$$.dirty & /*container, waveform*/ 1536) {
			if (container !== undefined) {
				if (waveform !== undefined) waveform.destroy();
				$$invalidate(9, container.innerHTML = "", container);
				create_waveform();
				$$invalidate(13, playing = false);
			}
		}

		if ($$self.$$.dirty & /*waveform, durationRef*/ 5120) {
			waveform?.on("decode", duration => {
				$$invalidate(14, audioDuration = duration);
				durationRef && $$invalidate(12, durationRef.textContent = formatTime(duration), durationRef);
			});
		}

		if ($$self.$$.dirty & /*waveform, timeRef*/ 3072) {
			waveform?.on("timeupdate", currentTime => timeRef && $$invalidate(11, timeRef.textContent = formatTime(currentTime), timeRef));
		}

		if ($$self.$$.dirty & /*waveform, waveform_settings*/ 1088) {
			waveform?.on("ready", () => {
				if (!waveform_settings.autoplay) {
					waveform?.stop();
				} else {
					waveform?.play();
				}
			});
		}

		if ($$self.$$.dirty & /*waveform*/ 1024) {
			waveform?.on("finish", () => {
				$$invalidate(13, playing = false);
				dispatch("stop");
			});
		}

		if ($$self.$$.dirty & /*waveform*/ 1024) {
			waveform?.on("pause", () => {
				$$invalidate(13, playing = false);
				dispatch("pause");
			});
		}

		if ($$self.$$.dirty & /*waveform*/ 1024) {
			waveform?.on("play", () => {
				$$invalidate(13, playing = true);
				dispatch("play");
			});
		}

		if ($$self.$$.dirty & /*url*/ 1048576) {
			url && load_audio(url);
		}
	};

	return [
		mode,
		value,
		label,
		i18n,
		interactive,
		trim_region_settings,
		waveform_settings,
		waveform_options,
		handle_reset_value,
		container,
		waveform,
		timeRef,
		durationRef,
		playing,
		audioDuration,
		trimDuration,
		show_volume_slider,
		formatTime,
		handle_trim_audio,
		dispatch_blob,
		url,
		div0_binding,
		time0_binding,
		time1_binding,
		waveformcontrols_mode_binding,
		waveformcontrols_trimDuration_binding,
		waveformcontrols_show_volume_slider_binding
	];
}

class AudioPlayer extends SvelteComponent$6 {
	constructor(options) {
		super();

		init$6(this, options, instance$6, create_fragment$6, safe_not_equal$6, {
			value: 1,
			label: 2,
			i18n: 3,
			dispatch_blob: 19,
			interactive: 4,
			trim_region_settings: 5,
			waveform_settings: 6,
			waveform_options: 7,
			mode: 0,
			handle_reset_value: 8
		});
	}
}

const AudioPlayer$1 = AudioPlayer;

const StaticAudio_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/static/StaticAudio.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$5,
	append: append$3,
	attr: attr$3,
	bubble: bubble$1,
	check_outros: check_outros$3,
	create_component: create_component$4,
	destroy_component: destroy_component$4,
	detach: detach$5,
	element: element$3,
	empty: empty$3,
	group_outros: group_outros$3,
	init: init$5,
	insert: insert$5,
	mount_component: mount_component$4,
	safe_not_equal: safe_not_equal$5,
	space: space$5,
	transition_in: transition_in$4,
	transition_out: transition_out$4
} = window.__gradio__svelte__internal;const { createEventDispatcher: createEventDispatcher$3 } = window.__gradio__svelte__internal;
function create_else_block$5(ctx) {
	let empty_1;
	let current;

	empty_1 = new Empty({
			props: {
				size: "small",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component$4(empty_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$4(empty_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const empty_1_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				empty_1_changes.$$scope = { dirty, ctx };
			}

			empty_1.$set(empty_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$4(empty_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$4(empty_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$4(empty_1, detaching);
		}
	};
}

// (26:0) {#if value !== null}
function create_if_block$5(ctx) {
	let div;
	let t0;
	let t1;
	let audioplayer;
	let current;
	let if_block0 = /*show_download_button*/ ctx[3] && create_if_block_2$2(ctx);
	let if_block1 = /*show_share_button*/ ctx[4] && create_if_block_1$2(ctx);

	audioplayer = new AudioPlayer$1({
			props: {
				value: /*value*/ ctx[0],
				label: /*label*/ ctx[1],
				i18n: /*i18n*/ ctx[5],
				waveform_settings: /*waveform_settings*/ ctx[6],
				waveform_options: /*waveform_options*/ ctx[7]
			}
		});

	audioplayer.$on("pause", /*pause_handler*/ ctx[11]);
	audioplayer.$on("play", /*play_handler*/ ctx[12]);
	audioplayer.$on("stop", /*stop_handler*/ ctx[13]);

	return {
		c() {
			div = element$3("div");
			if (if_block0) if_block0.c();
			t0 = space$5();
			if (if_block1) if_block1.c();
			t1 = space$5();
			create_component$4(audioplayer.$$.fragment);
			attr$3(div, "class", "icon-buttons svelte-rvdo70");
		},
		m(target, anchor) {
			insert$5(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append$3(div, t0);
			if (if_block1) if_block1.m(div, null);
			insert$5(target, t1, anchor);
			mount_component$4(audioplayer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*show_download_button*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*show_download_button*/ 8) {
						transition_in$4(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in$4(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros$3();

				transition_out$4(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$3();
			}

			if (/*show_share_button*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*show_share_button*/ 16) {
						transition_in$4(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in$4(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros$3();

				transition_out$4(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$3();
			}

			const audioplayer_changes = {};
			if (dirty & /*value*/ 1) audioplayer_changes.value = /*value*/ ctx[0];
			if (dirty & /*label*/ 2) audioplayer_changes.label = /*label*/ ctx[1];
			if (dirty & /*i18n*/ 32) audioplayer_changes.i18n = /*i18n*/ ctx[5];
			if (dirty & /*waveform_settings*/ 64) audioplayer_changes.waveform_settings = /*waveform_settings*/ ctx[6];
			if (dirty & /*waveform_options*/ 128) audioplayer_changes.waveform_options = /*waveform_options*/ ctx[7];
			audioplayer.$set(audioplayer_changes);
		},
		i(local) {
			if (current) return;
			transition_in$4(if_block0);
			transition_in$4(if_block1);
			transition_in$4(audioplayer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$4(if_block0);
			transition_out$4(if_block1);
			transition_out$4(audioplayer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$5(div);
				detach$5(t1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component$4(audioplayer, detaching);
		}
	};
}

// (63:1) <Empty size="small">
function create_default_slot$2(ctx) {
	let music;
	let current;
	music = new Music({});

	return {
		c() {
			create_component$4(music.$$.fragment);
		},
		m(target, anchor) {
			mount_component$4(music, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$4(music.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$4(music.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$4(music, detaching);
		}
	};
}

// (28:2) {#if show_download_button}
function create_if_block_2$2(ctx) {
	let a;
	let iconbutton;
	let a_href_value;
	let a_download_value;
	let current;

	iconbutton = new IconButton({
			props: {
				Icon: Download,
				label: /*i18n*/ ctx[5]("common.download")
			}
		});

	return {
		c() {
			a = element$3("a");
			create_component$4(iconbutton.$$.fragment);
			attr$3(a, "href", a_href_value = /*value*/ ctx[0].url);
			attr$3(a, "target", window.__is_colab__ ? "_blank" : null);
			attr$3(a, "download", a_download_value = /*value*/ ctx[0].orig_name || /*value*/ ctx[0].path);
		},
		m(target, anchor) {
			insert$5(target, a, anchor);
			mount_component$4(iconbutton, a, null);
			current = true;
		},
		p(ctx, dirty) {
			const iconbutton_changes = {};
			if (dirty & /*i18n*/ 32) iconbutton_changes.label = /*i18n*/ ctx[5]("common.download");
			iconbutton.$set(iconbutton_changes);

			if (!current || dirty & /*value*/ 1 && a_href_value !== (a_href_value = /*value*/ ctx[0].url)) {
				attr$3(a, "href", a_href_value);
			}

			if (!current || dirty & /*value*/ 1 && a_download_value !== (a_download_value = /*value*/ ctx[0].orig_name || /*value*/ ctx[0].path)) {
				attr$3(a, "download", a_download_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$4(iconbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$4(iconbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$5(a);
			}

			destroy_component$4(iconbutton);
		}
	};
}

// (37:2) {#if show_share_button}
function create_if_block_1$2(ctx) {
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[5],
				formatter: /*func*/ ctx[8],
				value: /*value*/ ctx[0]
			}
		});

	sharebutton.$on("error", /*error_handler*/ ctx[9]);
	sharebutton.$on("share", /*share_handler*/ ctx[10]);

	return {
		c() {
			create_component$4(sharebutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component$4(sharebutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty & /*i18n*/ 32) sharebutton_changes.i18n = /*i18n*/ ctx[5];
			if (dirty & /*value*/ 1) sharebutton_changes.value = /*value*/ ctx[0];
			sharebutton.$set(sharebutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$4(sharebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$4(sharebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$4(sharebutton, detaching);
		}
	};
}

function create_fragment$5(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[2],
				Icon: Music,
				float: false,
				label: /*label*/ ctx[1] || /*i18n*/ ctx[5]("audio.audio")
			}
		});

	const if_block_creators = [create_if_block$5, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component$4(blocklabel.$$.fragment);
			t = space$5();
			if_block.c();
			if_block_anchor = empty$3();
		},
		m(target, anchor) {
			mount_component$4(blocklabel, target, anchor);
			insert$5(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert$5(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const blocklabel_changes = {};
			if (dirty & /*show_label*/ 4) blocklabel_changes.show_label = /*show_label*/ ctx[2];
			if (dirty & /*label, i18n*/ 34) blocklabel_changes.label = /*label*/ ctx[1] || /*i18n*/ ctx[5]("audio.audio");
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$3();

				transition_out$4(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$3();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in$4(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$4(blocklabel.$$.fragment, local);
			transition_in$4(if_block);
			current = true;
		},
		o(local) {
			transition_out$4(blocklabel.$$.fragment, local);
			transition_out$4(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$5(t);
				detach$5(if_block_anchor);
			}

			destroy_component$4(blocklabel, detaching);
			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { value = null } = $$props;
	let { label } = $$props;
	let { show_label = true } = $$props;
	let { show_download_button = true } = $$props;
	let { show_share_button = false } = $$props;
	let { i18n } = $$props;
	let { waveform_settings } = $$props;
	let { waveform_options } = $$props;
	const dispatch = createEventDispatcher$3();

	const func = async value => {
		if (!value) return "";
		let url = await uploadToHuggingFace(value.url, "url");
		return `<audio controls src="${url}"></audio>`;
	};

	function error_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	function share_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	function play_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	function stop_handler(event) {
		bubble$1.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
		if ('show_download_button' in $$props) $$invalidate(3, show_download_button = $$props.show_download_button);
		if ('show_share_button' in $$props) $$invalidate(4, show_share_button = $$props.show_share_button);
		if ('i18n' in $$props) $$invalidate(5, i18n = $$props.i18n);
		if ('waveform_settings' in $$props) $$invalidate(6, waveform_settings = $$props.waveform_settings);
		if ('waveform_options' in $$props) $$invalidate(7, waveform_options = $$props.waveform_options);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			value && dispatch("change", value);
		}
	};

	return [
		value,
		label,
		show_label,
		show_download_button,
		show_share_button,
		i18n,
		waveform_settings,
		waveform_options,
		func,
		error_handler,
		share_handler,
		pause_handler,
		play_handler,
		stop_handler
	];
}

class StaticAudio extends SvelteComponent$5 {
	constructor(options) {
		super();

		init$5(this, options, instance$5, create_fragment$5, safe_not_equal$5, {
			value: 0,
			label: 1,
			show_label: 2,
			show_download_button: 3,
			show_share_button: 4,
			i18n: 5,
			waveform_settings: 6,
			waveform_options: 7
		});
	}
}

const StaticAudio$1 = StaticAudio;

function e(e,t,i,s){return new(i||(i=Promise))((function(r,n){function o(e){try{d(s.next(e));}catch(e){n(e);}}function a(e){try{d(s.throw(e));}catch(e){n(e);}}function d(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t);}))).then(o,a);}d((s=s.apply(e,t||[])).next());}))}"function"==typeof SuppressedError&&SuppressedError;class t{constructor(){this.listeners={},this.on=this.addEventListener,this.un=this.removeEventListener;}addEventListener(e,t,i){if(this.listeners[e]||(this.listeners[e]=new Set),this.listeners[e].add(t),null==i?void 0:i.once){const i=()=>{this.removeEventListener(e,i),this.removeEventListener(e,t);};return this.addEventListener(e,i),i}return ()=>this.removeEventListener(e,t)}removeEventListener(e,t){var i;null===(i=this.listeners[e])||void 0===i||i.delete(t);}once(e,t){return this.on(e,t,{once:!0})}unAll(){this.listeners={};}emit(e,...t){this.listeners[e]&&this.listeners[e].forEach((e=>e(...t)));}}class i extends t{constructor(e){super(),this.subscriptions=[],this.options=e;}onInit(){}init(e){this.wavesurfer=e,this.onInit();}destroy(){this.emit("destroy"),this.subscriptions.forEach((e=>e()));}}const s=["audio/webm","audio/wav","audio/mpeg","audio/mp4","audio/mp3"];class r extends i{constructor(e){var t;super(Object.assign(Object.assign({},e),{audioBitsPerSecond:null!==(t=e.audioBitsPerSecond)&&void 0!==t?t:128e3})),this.stream=null,this.mediaRecorder=null;}static create(e){return new r(e||{})}renderMicStream(e){const t=new AudioContext,i=t.createMediaStreamSource(e),s=t.createAnalyser();i.connect(s);const r=s.frequencyBinCount,n=new Float32Array(r),o=r/t.sampleRate;let a;const d=()=>{s.getFloatTimeDomainData(n),this.wavesurfer&&(this.wavesurfer.options.cursorWidth=0,this.wavesurfer.options.interact=!1,this.wavesurfer.load("",[n],o)),a=requestAnimationFrame(d);};return d(),()=>{cancelAnimationFrame(a),null==i||i.disconnect(),null==t||t.close();}}startMic(t){return e(this,void 0,void 0,(function*(){let e;try{e=yield navigator.mediaDevices.getUserMedia({audio:!(null==t?void 0:t.deviceId)||{deviceId:t.deviceId}});}catch(e){throw new Error("Error accessing the microphone: "+e.message)}const i=this.renderMicStream(e);return this.subscriptions.push(this.once("destroy",i)),this.stream=e,e}))}stopMic(){this.stream&&(this.stream.getTracks().forEach((e=>e.stop())),this.stream=null,this.mediaRecorder=null);}startRecording(t){return e(this,void 0,void 0,(function*(){const e=this.stream||(yield this.startMic(t)),i=this.mediaRecorder||new MediaRecorder(e,{mimeType:this.options.mimeType||s.find((e=>MediaRecorder.isTypeSupported(e))),audioBitsPerSecond:this.options.audioBitsPerSecond});this.mediaRecorder=i,this.stopRecording();const r=[];i.ondataavailable=e=>{e.data.size>0&&r.push(e.data);},i.onstop=()=>{var e;const t=new Blob(r,{type:i.mimeType});this.emit("record-end",t),!1!==this.options.renderRecordedAudio&&(null===(e=this.wavesurfer)||void 0===e||e.load(URL.createObjectURL(t)));},i.start(),this.emit("record-start");}))}isRecording(){var e;return "recording"===(null===(e=this.mediaRecorder)||void 0===e?void 0:e.state)}isPaused(){var e;return "paused"===(null===(e=this.mediaRecorder)||void 0===e?void 0:e.state)}stopRecording(){var e;this.isRecording()&&(null===(e=this.mediaRecorder)||void 0===e||e.stop());}pauseRecording(){var e;this.isRecording()&&(null===(e=this.mediaRecorder)||void 0===e||e.pause(),this.emit("record-pause"));}resumeRecording(){var e;this.isPaused()&&(null===(e=this.mediaRecorder)||void 0===e||e.resume(),this.emit("record-resume"));}static getAvailableAudioDevices(){return e(this,void 0,void 0,(function*(){return navigator.mediaDevices.enumerateDevices().then((e=>e.filter((e=>"audioinput"===e.kind))))}))}destroy(){super.destroy(),this.stopRecording(),this.stopMic();}}

const WaveformRecordControls_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/shared/WaveformRecordControls.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$4,
	append: append$2,
	attr: attr$2,
	binding_callbacks: binding_callbacks$3,
	create_component: create_component$3,
	destroy_component: destroy_component$3,
	destroy_each,
	detach: detach$4,
	element: element$2,
	empty: empty$2,
	ensure_array_like,
	init: init$4,
	insert: insert$4,
	listen: listen$1,
	mount_component: mount_component$3,
	run_all,
	safe_not_equal: safe_not_equal$4,
	set_data: set_data$2,
	set_input_value,
	space: space$4,
	text: text$2,
	transition_in: transition_in$3,
	transition_out: transition_out$3
} = window.__gradio__svelte__internal;const { createEventDispatcher: createEventDispatcher$2 } = window.__gradio__svelte__internal;
function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	return child_ctx;
}

// (117:2) {:else}
function create_else_block$4(ctx) {
	let each_1_anchor;
	let each_value = ensure_array_like(/*micDevices*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty$2();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert$4(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*micDevices*/ 4) {
				each_value = ensure_array_like(/*micDevices*/ ctx[2]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach$4(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (115:2) {#if micDevices.length === 0}
function create_if_block$4(ctx) {
	let option;
	let t_value = /*i18n*/ ctx[1]("audio.no_microphone") + "";
	let t;

	return {
		c() {
			option = element$2("option");
			t = text$2(t_value);
			option.__value = "";
			set_input_value(option, option.__value);
		},
		m(target, anchor) {
			insert$4(target, option, anchor);
			append$2(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*i18n*/ 2 && t_value !== (t_value = /*i18n*/ ctx[1]("audio.no_microphone") + "")) set_data$2(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$4(option);
			}
		}
	};
}

// (118:3) {#each micDevices as micDevice}
function create_each_block(ctx) {
	let option;
	let t_value = /*micDevice*/ ctx[19].label + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element$2("option");
			t = text$2(t_value);
			option.__value = option_value_value = /*micDevice*/ ctx[19].deviceId;
			set_input_value(option, option.__value);
		},
		m(target, anchor) {
			insert$4(target, option, anchor);
			append$2(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*micDevices*/ 4 && t_value !== (t_value = /*micDevice*/ ctx[19].label + "")) set_data$2(t, t_value);

			if (dirty & /*micDevices*/ 4 && option_value_value !== (option_value_value = /*micDevice*/ ctx[19].deviceId)) {
				option.__value = option_value_value;
				set_input_value(option, option.__value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach$4(option);
			}
		}
	};
}

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let button0;
	let t0_value = /*i18n*/ ctx[1]("audio.record") + "";
	let t0;
	let t1;
	let button1;
	let t2_value = /*i18n*/ ctx[1]("audio.stop") + "";
	let t2;
	let button1_class_value;
	let t3;
	let button2;
	let t4_value = /*i18n*/ ctx[1]("audio.stop") + "";
	let t4;
	let t5;
	let button3;
	let pause;
	let t6;
	let button4;
	let t7_value = /*i18n*/ ctx[1]("audio.resume") + "";
	let t7;
	let t8;
	let select;
	let select_disabled_value;
	let current;
	let mounted;
	let dispose;
	pause = new Pause({});

	function select_block_type(ctx, dirty) {
		if (/*micDevices*/ ctx[2].length === 0) return create_if_block$4;
		return create_else_block$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div1 = element$2("div");
			div0 = element$2("div");
			button0 = element$2("button");
			t0 = text$2(t0_value);
			t1 = space$4();
			button1 = element$2("button");
			t2 = text$2(t2_value);
			t3 = space$4();
			button2 = element$2("button");
			t4 = text$2(t4_value);
			t5 = space$4();
			button3 = element$2("button");
			create_component$3(pause.$$.fragment);
			t6 = space$4();
			button4 = element$2("button");
			t7 = text$2(t7_value);
			t8 = space$4();
			select = element$2("select");
			if_block.c();
			attr$2(button0, "class", "record record-button svelte-9uoz5m");
			attr$2(button1, "class", button1_class_value = "stop-button " + (/*record*/ ctx[0].isPaused() ? 'stop-button-paused' : '') + " svelte-9uoz5m");
			attr$2(button2, "id", "stop-paused");
			attr$2(button2, "class", "stop-button-paused svelte-9uoz5m");
			attr$2(button3, "class", "pause-button svelte-9uoz5m");
			attr$2(button4, "class", "resume-button svelte-9uoz5m");
			attr$2(div0, "class", "wrapper svelte-9uoz5m");
			attr$2(select, "class", "mic-select svelte-9uoz5m");
			attr$2(select, "aria-label", "Select input device");
			select.disabled = select_disabled_value = /*micDevices*/ ctx[2].length === 0;
			attr$2(div1, "class", "controls svelte-9uoz5m");
		},
		m(target, anchor) {
			insert$4(target, div1, anchor);
			append$2(div1, div0);
			append$2(div0, button0);
			append$2(button0, t0);
			/*button0_binding*/ ctx[8](button0);
			append$2(div0, t1);
			append$2(div0, button1);
			append$2(button1, t2);
			/*button1_binding*/ ctx[10](button1);
			append$2(div0, t3);
			append$2(div0, button2);
			append$2(button2, t4);
			/*button2_binding*/ ctx[12](button2);
			append$2(div0, t5);
			append$2(div0, button3);
			mount_component$3(pause, button3, null);
			/*button3_binding*/ ctx[14](button3);
			append$2(div0, t6);
			append$2(div0, button4);
			append$2(button4, t7);
			/*button4_binding*/ ctx[16](button4);
			append$2(div1, t8);
			append$2(div1, select);
			if_block.m(select, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen$1(button0, "click", /*click_handler*/ ctx[9]),
					listen$1(button1, "click", /*click_handler_1*/ ctx[11]),
					listen$1(button2, "click", /*click_handler_2*/ ctx[13]),
					listen$1(button3, "click", /*click_handler_3*/ ctx[15]),
					listen$1(button4, "click", /*click_handler_4*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*i18n*/ 2) && t0_value !== (t0_value = /*i18n*/ ctx[1]("audio.record") + "")) set_data$2(t0, t0_value);
			if ((!current || dirty & /*i18n*/ 2) && t2_value !== (t2_value = /*i18n*/ ctx[1]("audio.stop") + "")) set_data$2(t2, t2_value);

			if (!current || dirty & /*record*/ 1 && button1_class_value !== (button1_class_value = "stop-button " + (/*record*/ ctx[0].isPaused() ? 'stop-button-paused' : '') + " svelte-9uoz5m")) {
				attr$2(button1, "class", button1_class_value);
			}

			if ((!current || dirty & /*i18n*/ 2) && t4_value !== (t4_value = /*i18n*/ ctx[1]("audio.stop") + "")) set_data$2(t4, t4_value);
			if ((!current || dirty & /*i18n*/ 2) && t7_value !== (t7_value = /*i18n*/ ctx[1]("audio.resume") + "")) set_data$2(t7, t7_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(select, null);
				}
			}

			if (!current || dirty & /*micDevices*/ 4 && select_disabled_value !== (select_disabled_value = /*micDevices*/ ctx[2].length === 0)) {
				select.disabled = select_disabled_value;
			}
		},
		i(local) {
			if (current) return;
			transition_in$3(pause.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(pause.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$4(div1);
			}

			/*button0_binding*/ ctx[8](null);
			/*button1_binding*/ ctx[10](null);
			/*button2_binding*/ ctx[12](null);
			destroy_component$3(pause);
			/*button3_binding*/ ctx[14](null);
			/*button4_binding*/ ctx[16](null);
			if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { record } = $$props;
	let { i18n } = $$props;
	let micDevices = [];
	let recordButton;
	let pauseButton;
	let resumeButton;
	let stopButton;
	let stopButtonPaused;
	const dispatch = createEventDispatcher$2();

	function button0_binding($$value) {
		binding_callbacks$3[$$value ? 'unshift' : 'push'](() => {
			recordButton = $$value;
			($$invalidate(3, recordButton), $$invalidate(0, record));
		});
	}

	const click_handler = () => record.startRecording();

	function button1_binding($$value) {
		binding_callbacks$3[$$value ? 'unshift' : 'push'](() => {
			stopButton = $$value;
			($$invalidate(6, stopButton), $$invalidate(0, record));
		});
	}

	const click_handler_1 = () => {
		if (record.isPaused()) {
			record.resumeRecording();
			record.stopRecording();
		}

		record.stopRecording();
	};

	function button2_binding($$value) {
		binding_callbacks$3[$$value ? 'unshift' : 'push'](() => {
			stopButtonPaused = $$value;
			($$invalidate(7, stopButtonPaused), $$invalidate(0, record));
		});
	}

	const click_handler_2 = () => {
		if (record.isPaused()) {
			record.resumeRecording();
			record.stopRecording();
		}

		record.stopRecording();
	};

	function button3_binding($$value) {
		binding_callbacks$3[$$value ? 'unshift' : 'push'](() => {
			pauseButton = $$value;
			($$invalidate(4, pauseButton), $$invalidate(0, record));
		});
	}

	const click_handler_3 = () => record.pauseRecording();

	function button4_binding($$value) {
		binding_callbacks$3[$$value ? 'unshift' : 'push'](() => {
			resumeButton = $$value;
			($$invalidate(5, resumeButton), $$invalidate(0, record));
		});
	}

	const click_handler_4 = () => record.resumeRecording();

	$$self.$$set = $$props => {
		if ('record' in $$props) $$invalidate(0, record = $$props.record);
		if ('i18n' in $$props) $$invalidate(1, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*i18n*/ 2) {
			try {
				let tempDevices = [];

				r.getAvailableAudioDevices().then(devices => {
					$$invalidate(2, micDevices = devices);

					devices.forEach(device => {
						if (device.deviceId) {
							tempDevices.push(device);
						}
					});

					$$invalidate(2, micDevices = tempDevices);
				});
			} catch(err) {
				if (err instanceof DOMException && err.name == "NotAllowedError") {
					dispatch("error", i18n("audio.allow_recording_access"));
				}

				throw err;
			}
		}

		if ($$self.$$.dirty & /*record*/ 1) {
			record.on("record-start", () => {
				record.startMic();
				$$invalidate(3, recordButton.style.display = "none", recordButton);
				$$invalidate(6, stopButton.style.display = "flex", stopButton);
				$$invalidate(4, pauseButton.style.display = "block", pauseButton);
			});
		}

		if ($$self.$$.dirty & /*record*/ 1) {
			record.on("record-end", () => {
				if (record.isPaused()) {
					record.resumeRecording();
					record.stopRecording();
				}

				record.stopMic();
				$$invalidate(3, recordButton.style.display = "flex", recordButton);
				$$invalidate(6, stopButton.style.display = "none", stopButton);
				$$invalidate(4, pauseButton.style.display = "none", pauseButton);
				$$invalidate(3, recordButton.disabled = false, recordButton);
			});
		}

		if ($$self.$$.dirty & /*record*/ 1) {
			record.on("record-pause", () => {
				$$invalidate(4, pauseButton.style.display = "none", pauseButton);
				$$invalidate(5, resumeButton.style.display = "block", resumeButton);
				$$invalidate(6, stopButton.style.display = "none", stopButton);
				$$invalidate(7, stopButtonPaused.style.display = "flex", stopButtonPaused);
			});
		}

		if ($$self.$$.dirty & /*record*/ 1) {
			record.on("record-resume", () => {
				$$invalidate(4, pauseButton.style.display = "block", pauseButton);
				$$invalidate(5, resumeButton.style.display = "none", resumeButton);
				$$invalidate(3, recordButton.style.display = "none", recordButton);
				$$invalidate(6, stopButton.style.display = "flex", stopButton);
				$$invalidate(7, stopButtonPaused.style.display = "none", stopButtonPaused);
			});
		}
	};

	return [
		record,
		i18n,
		micDevices,
		recordButton,
		pauseButton,
		resumeButton,
		stopButton,
		stopButtonPaused,
		button0_binding,
		click_handler,
		button1_binding,
		click_handler_1,
		button2_binding,
		click_handler_2,
		button3_binding,
		click_handler_3,
		button4_binding,
		click_handler_4
	];
}

class WaveformRecordControls extends SvelteComponent$4 {
	constructor(options) {
		super();
		init$4(this, options, instance$4, create_fragment$4, safe_not_equal$4, { record: 0, i18n: 1 });
	}
}

const AudioRecorder_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/recorder/AudioRecorder.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$3,
	add_flush_callback: add_flush_callback$2,
	append: append$1,
	attr: attr$1,
	bind: bind$2,
	binding_callbacks: binding_callbacks$2,
	check_outros: check_outros$2,
	create_component: create_component$2,
	destroy_component: destroy_component$2,
	detach: detach$3,
	element: element$1,
	group_outros: group_outros$2,
	init: init$3,
	insert: insert$3,
	mount_component: mount_component$2,
	noop: noop$1,
	safe_not_equal: safe_not_equal$3,
	set_data: set_data$1,
	space: space$3,
	text: text$1,
	transition_in: transition_in$2,
	transition_out: transition_out$2
} = window.__gradio__svelte__internal;
const { onMount: onMount$1 } = window.__gradio__svelte__internal;const { createEventDispatcher: createEventDispatcher$1 } = window.__gradio__svelte__internal;
function create_if_block_2$1(ctx) {
	let div1;
	let time;
	let t1;
	let div0;
	let t2;
	let if_block0 = /*mode*/ ctx[0] === "edit" && /*trimDuration*/ ctx[16] > 0 && create_if_block_4(ctx);

	function select_block_type(ctx, dirty) {
		if (/*timing*/ ctx[15]) return create_if_block_3$1;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type(ctx);

	return {
		c() {
			div1 = element$1("div");
			time = element$1("time");
			time.textContent = "0:00";
			t1 = space$3();
			div0 = element$1("div");
			if (if_block0) if_block0.c();
			t2 = space$3();
			if_block1.c();
			attr$1(time, "class", "time svelte-7hmw24");
			attr$1(div1, "class", "timestamps svelte-7hmw24");
		},
		m(target, anchor) {
			insert$3(target, div1, anchor);
			append$1(div1, time);
			/*time_binding*/ ctx[24](time);
			append$1(div1, t1);
			append$1(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append$1(div0, t2);
			if_block1.m(div0, null);
		},
		p(ctx, dirty) {
			if (/*mode*/ ctx[0] === "edit" && /*trimDuration*/ ctx[16] > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(div0, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div0, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach$3(div1);
			}

			/*time_binding*/ ctx[24](null);
			if (if_block0) if_block0.d();
			if_block1.d();
		}
	};
}

// (163:4) {#if mode === "edit" && trimDuration > 0}
function create_if_block_4(ctx) {
	let time;
	let t_value = /*format_time*/ ctx[17](/*trimDuration*/ ctx[16]) + "";
	let t;

	return {
		c() {
			time = element$1("time");
			t = text$1(t_value);
			attr$1(time, "class", "trim-duration svelte-7hmw24");
		},
		m(target, anchor) {
			insert$3(target, time, anchor);
			append$1(time, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*trimDuration*/ 65536 && t_value !== (t_value = /*format_time*/ ctx[17](/*trimDuration*/ ctx[16]) + "")) set_data$1(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$3(time);
			}
		}
	};
}

// (168:4) {:else}
function create_else_block$3(ctx) {
	let time;

	return {
		c() {
			time = element$1("time");
			time.textContent = "0:00";
			attr$1(time, "class", "duration svelte-7hmw24");
		},
		m(target, anchor) {
			insert$3(target, time, anchor);
			/*time_binding_1*/ ctx[25](time);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach$3(time);
			}

			/*time_binding_1*/ ctx[25](null);
		}
	};
}

// (166:4) {#if timing}
function create_if_block_3$1(ctx) {
	let time;
	let t_value = /*format_time*/ ctx[17](/*seconds*/ ctx[14]) + "";
	let t;

	return {
		c() {
			time = element$1("time");
			t = text$1(t_value);
			attr$1(time, "class", "duration svelte-7hmw24");
		},
		m(target, anchor) {
			insert$3(target, time, anchor);
			append$1(time, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*seconds*/ 16384 && t_value !== (t_value = /*format_time*/ ctx[17](/*seconds*/ ctx[14]) + "")) set_data$1(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$3(time);
			}
		}
	};
}

// (175:1) {#if micWaveform && !recordedAudio}
function create_if_block_1$1(ctx) {
	let waveformrecordcontrols;
	let updating_record;
	let current;

	function waveformrecordcontrols_record_binding(value) {
		/*waveformrecordcontrols_record_binding*/ ctx[26](value);
	}

	let waveformrecordcontrols_props = { i18n: /*i18n*/ ctx[1] };

	if (/*record*/ ctx[7] !== void 0) {
		waveformrecordcontrols_props.record = /*record*/ ctx[7];
	}

	waveformrecordcontrols = new WaveformRecordControls({ props: waveformrecordcontrols_props });
	binding_callbacks$2.push(() => bind$2(waveformrecordcontrols, 'record', waveformrecordcontrols_record_binding));

	return {
		c() {
			create_component$2(waveformrecordcontrols.$$.fragment);
		},
		m(target, anchor) {
			mount_component$2(waveformrecordcontrols, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const waveformrecordcontrols_changes = {};
			if (dirty[0] & /*i18n*/ 2) waveformrecordcontrols_changes.i18n = /*i18n*/ ctx[1];

			if (!updating_record && dirty[0] & /*record*/ 128) {
				updating_record = true;
				waveformrecordcontrols_changes.record = /*record*/ ctx[7];
				add_flush_callback$2(() => updating_record = false);
			}

			waveformrecordcontrols.$set(waveformrecordcontrols_changes);
		},
		i(local) {
			if (current) return;
			transition_in$2(waveformrecordcontrols.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(waveformrecordcontrols.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$2(waveformrecordcontrols, detaching);
		}
	};
}

// (179:1) {#if recordingWaveform && recordedAudio}
function create_if_block$3(ctx) {
	let waveformcontrols;
	let updating_waveform;
	let updating_trimDuration;
	let updating_mode;
	let current;

	function waveformcontrols_waveform_binding(value) {
		/*waveformcontrols_waveform_binding*/ ctx[27](value);
	}

	function waveformcontrols_trimDuration_binding(value) {
		/*waveformcontrols_trimDuration_binding*/ ctx[28](value);
	}

	function waveformcontrols_mode_binding(value) {
		/*waveformcontrols_mode_binding*/ ctx[29](value);
	}

	let waveformcontrols_props = {
		container: /*recordingContainer*/ ctx[5],
		playing: /*playing*/ ctx[12],
		audioDuration: /*audioDuration*/ ctx[13],
		i18n: /*i18n*/ ctx[1],
		interactive: true,
		handle_trim_audio: /*handle_trim_audio*/ ctx[18],
		showRedo: true,
		handle_reset_value: /*handle_reset_value*/ ctx[3],
		waveform_options: /*waveform_options*/ ctx[2]
	};

	if (/*recordingWaveform*/ ctx[4] !== void 0) {
		waveformcontrols_props.waveform = /*recordingWaveform*/ ctx[4];
	}

	if (/*trimDuration*/ ctx[16] !== void 0) {
		waveformcontrols_props.trimDuration = /*trimDuration*/ ctx[16];
	}

	if (/*mode*/ ctx[0] !== void 0) {
		waveformcontrols_props.mode = /*mode*/ ctx[0];
	}

	waveformcontrols = new WaveformControls({ props: waveformcontrols_props });
	binding_callbacks$2.push(() => bind$2(waveformcontrols, 'waveform', waveformcontrols_waveform_binding));
	binding_callbacks$2.push(() => bind$2(waveformcontrols, 'trimDuration', waveformcontrols_trimDuration_binding));
	binding_callbacks$2.push(() => bind$2(waveformcontrols, 'mode', waveformcontrols_mode_binding));

	return {
		c() {
			create_component$2(waveformcontrols.$$.fragment);
		},
		m(target, anchor) {
			mount_component$2(waveformcontrols, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const waveformcontrols_changes = {};
			if (dirty[0] & /*recordingContainer*/ 32) waveformcontrols_changes.container = /*recordingContainer*/ ctx[5];
			if (dirty[0] & /*playing*/ 4096) waveformcontrols_changes.playing = /*playing*/ ctx[12];
			if (dirty[0] & /*audioDuration*/ 8192) waveformcontrols_changes.audioDuration = /*audioDuration*/ ctx[13];
			if (dirty[0] & /*i18n*/ 2) waveformcontrols_changes.i18n = /*i18n*/ ctx[1];
			if (dirty[0] & /*handle_reset_value*/ 8) waveformcontrols_changes.handle_reset_value = /*handle_reset_value*/ ctx[3];
			if (dirty[0] & /*waveform_options*/ 4) waveformcontrols_changes.waveform_options = /*waveform_options*/ ctx[2];

			if (!updating_waveform && dirty[0] & /*recordingWaveform*/ 16) {
				updating_waveform = true;
				waveformcontrols_changes.waveform = /*recordingWaveform*/ ctx[4];
				add_flush_callback$2(() => updating_waveform = false);
			}

			if (!updating_trimDuration && dirty[0] & /*trimDuration*/ 65536) {
				updating_trimDuration = true;
				waveformcontrols_changes.trimDuration = /*trimDuration*/ ctx[16];
				add_flush_callback$2(() => updating_trimDuration = false);
			}

			if (!updating_mode && dirty[0] & /*mode*/ 1) {
				updating_mode = true;
				waveformcontrols_changes.mode = /*mode*/ ctx[0];
				add_flush_callback$2(() => updating_mode = false);
			}

			waveformcontrols.$set(waveformcontrols_changes);
		},
		i(local) {
			if (current) return;
			transition_in$2(waveformcontrols.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(waveformcontrols.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$2(waveformcontrols, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let div2;
	let div0;
	let t0;
	let div1;
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = (/*timing*/ ctx[15] || /*recordedAudio*/ ctx[8]) && create_if_block_2$1(ctx);
	let if_block1 = /*micWaveform*/ ctx[11] && !/*recordedAudio*/ ctx[8] && create_if_block_1$1(ctx);
	let if_block2 = /*recordingWaveform*/ ctx[4] && /*recordedAudio*/ ctx[8] && create_if_block$3(ctx);

	return {
		c() {
			div2 = element$1("div");
			div0 = element$1("div");
			t0 = space$3();
			div1 = element$1("div");
			t1 = space$3();
			if (if_block0) if_block0.c();
			t2 = space$3();
			if (if_block1) if_block1.c();
			t3 = space$3();
			if (if_block2) if_block2.c();
			attr$1(div0, "class", "microphone svelte-7hmw24");
			attr$1(div0, "data-testid", "microphone-waveform");
			attr$1(div1, "data-testid", "recording-waveform");
			attr$1(div2, "class", "component-wrapper svelte-7hmw24");
		},
		m(target, anchor) {
			insert$3(target, div2, anchor);
			append$1(div2, div0);
			/*div0_binding*/ ctx[22](div0);
			append$1(div2, t0);
			append$1(div2, div1);
			/*div1_binding*/ ctx[23](div1);
			append$1(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			append$1(div2, t2);
			if (if_block1) if_block1.m(div2, null);
			append$1(div2, t3);
			if (if_block2) if_block2.m(div2, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*timing*/ ctx[15] || /*recordedAudio*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					if_block0.m(div2, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*micWaveform*/ ctx[11] && !/*recordedAudio*/ ctx[8]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*micWaveform, recordedAudio*/ 2304) {
						transition_in$2(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in$2(if_block1, 1);
					if_block1.m(div2, t3);
				}
			} else if (if_block1) {
				group_outros$2();

				transition_out$2(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$2();
			}

			if (/*recordingWaveform*/ ctx[4] && /*recordedAudio*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*recordingWaveform, recordedAudio*/ 272) {
						transition_in$2(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$3(ctx);
					if_block2.c();
					transition_in$2(if_block2, 1);
					if_block2.m(div2, null);
				}
			} else if (if_block2) {
				group_outros$2();

				transition_out$2(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros$2();
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(if_block1);
			transition_in$2(if_block2);
			current = true;
		},
		o(local) {
			transition_out$2(if_block1);
			transition_out$2(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$3(div2);
			}

			/*div0_binding*/ ctx[22](null);
			/*div1_binding*/ ctx[23](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { mode } = $$props;
	let { i18n } = $$props;
	let { dispatch_blob } = $$props;
	let { waveform_settings } = $$props;
	let { waveform_options } = $$props;
	let { handle_reset_value } = $$props;
	let micWaveform;
	let recordingWaveform;
	let playing = false;
	let recordingContainer;
	let microphoneContainer;
	let record;
	let recordedAudio = null;

	// timestamps
	let timeRef;

	let durationRef;
	let audioDuration;
	let seconds = 0;
	let interval;
	let timing = false;

	// trimming
	let trimDuration = 0;

	const start_interval = () => {
		clearInterval(interval);

		$$invalidate(21, interval = setInterval(
			() => {
				$$invalidate(14, seconds++, seconds);
			},
			1000
		));
	};

	const dispatch = createEventDispatcher$1();

	const format_time = seconds => {
		const minutes = Math.floor(seconds / 60);
		const secondsRemainder = Math.round(seconds) % 60;
		const paddedSeconds = `0${secondsRemainder}`.slice(-2);
		return `${minutes}:${paddedSeconds}`;
	};

	const create_mic_waveform = () => {
		const recorder = microphoneContainer;
		if (recorder) recorder.innerHTML = "";
		if (micWaveform !== undefined) micWaveform.destroy();
		if (!recorder) return;

		$$invalidate(11, micWaveform = WaveSurfer.create({
			...waveform_settings,
			normalize: false,
			container: recorder
		}));

		$$invalidate(7, record = micWaveform.registerPlugin(r.create()));
		record.startMic();
	};

	const create_recording_waveform = () => {
		let recording = recordingContainer;
		if (!recordedAudio || !recording) return;

		$$invalidate(4, recordingWaveform = WaveSurfer.create({
			container: recording,
			url: recordedAudio,
			...waveform_settings
		}));
	};

	const handle_trim_audio = async (start, end) => {
		$$invalidate(0, mode = "edit");
		const decodedData = recordingWaveform.getDecodedData();

		if (decodedData) await process_audio(decodedData, start, end).then(async trimmedAudio => {
			await dispatch_blob([trimmedAudio], "change");
			await dispatch_blob([trimmedAudio], "stop_recording");
			recordingWaveform.destroy();
			create_recording_waveform();
		});

		dispatch("edit");
	};

	onMount$1(() => {
		create_mic_waveform();

		window.addEventListener("keydown", e => {
			if (e.key === "ArrowRight") {
				skipAudio(recordingWaveform, 0.1);
			} else if (e.key === "ArrowLeft") {
				skipAudio(recordingWaveform, -0.1);
			}
		});
	});

	function div0_binding($$value) {
		binding_callbacks$2[$$value ? 'unshift' : 'push'](() => {
			microphoneContainer = $$value;
			$$invalidate(6, microphoneContainer);
		});
	}

	function div1_binding($$value) {
		binding_callbacks$2[$$value ? 'unshift' : 'push'](() => {
			recordingContainer = $$value;
			$$invalidate(5, recordingContainer);
		});
	}

	function time_binding($$value) {
		binding_callbacks$2[$$value ? 'unshift' : 'push'](() => {
			timeRef = $$value;
			($$invalidate(9, timeRef), $$invalidate(4, recordingWaveform));
		});
	}

	function time_binding_1($$value) {
		binding_callbacks$2[$$value ? 'unshift' : 'push'](() => {
			durationRef = $$value;
			($$invalidate(10, durationRef), $$invalidate(4, recordingWaveform));
		});
	}

	function waveformrecordcontrols_record_binding(value) {
		record = value;
		$$invalidate(7, record);
	}

	function waveformcontrols_waveform_binding(value) {
		recordingWaveform = value;
		$$invalidate(4, recordingWaveform);
	}

	function waveformcontrols_trimDuration_binding(value) {
		trimDuration = value;
		$$invalidate(16, trimDuration);
	}

	function waveformcontrols_mode_binding(value) {
		mode = value;
		$$invalidate(0, mode);
	}

	$$self.$$set = $$props => {
		if ('mode' in $$props) $$invalidate(0, mode = $$props.mode);
		if ('i18n' in $$props) $$invalidate(1, i18n = $$props.i18n);
		if ('dispatch_blob' in $$props) $$invalidate(19, dispatch_blob = $$props.dispatch_blob);
		if ('waveform_settings' in $$props) $$invalidate(20, waveform_settings = $$props.waveform_settings);
		if ('waveform_options' in $$props) $$invalidate(2, waveform_options = $$props.waveform_options);
		if ('handle_reset_value' in $$props) $$invalidate(3, handle_reset_value = $$props.handle_reset_value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*record, microphoneContainer*/ 192) {
			record?.on("record-start", () => {
				start_interval();
				$$invalidate(15, timing = true);
				dispatch("start_recording");
				let waveformCanvas = microphoneContainer;
				if (waveformCanvas) waveformCanvas.style.display = "block";
			});
		}

		if ($$self.$$.dirty[0] & /*record, interval, dispatch_blob*/ 2621568) {
			record?.on("record-end", async blob => {
				$$invalidate(14, seconds = 0);
				$$invalidate(15, timing = false);
				clearInterval(interval);
				const array_buffer = await blob.arrayBuffer();
				const context = new AudioContext();
				const audio_buffer = await context.decodeAudioData(array_buffer);

				if (audio_buffer) await process_audio(audio_buffer).then(async audio => {
					await dispatch_blob([audio], "change");
					await dispatch_blob([audio], "stop_recording");
				});
			});
		}

		if ($$self.$$.dirty[0] & /*record, interval*/ 2097280) {
			record?.on("record-pause", () => {
				dispatch("pause_recording");
				clearInterval(interval);
			});
		}

		if ($$self.$$.dirty[0] & /*record*/ 128) {
			record?.on("record-resume", () => {
				start_interval();
			});
		}

		if ($$self.$$.dirty[0] & /*recordingWaveform, durationRef*/ 1040) {
			recordingWaveform?.on("decode", duration => {
				$$invalidate(13, audioDuration = duration);
				durationRef && $$invalidate(10, durationRef.textContent = format_time(duration), durationRef);
			});
		}

		if ($$self.$$.dirty[0] & /*recordingWaveform, timeRef*/ 528) {
			recordingWaveform?.on("timeupdate", currentTime => timeRef && $$invalidate(9, timeRef.textContent = format_time(currentTime), timeRef));
		}

		if ($$self.$$.dirty[0] & /*recordingWaveform*/ 16) {
			recordingWaveform?.on("pause", () => {
				dispatch("pause");
				$$invalidate(12, playing = false);
			});
		}

		if ($$self.$$.dirty[0] & /*recordingWaveform*/ 16) {
			recordingWaveform?.on("play", () => {
				dispatch("play");
				$$invalidate(12, playing = true);
			});
		}

		if ($$self.$$.dirty[0] & /*recordingWaveform*/ 16) {
			recordingWaveform?.on("finish", () => {
				dispatch("stop");
				$$invalidate(12, playing = false);
			});
		}

		if ($$self.$$.dirty[0] & /*record, microphoneContainer, recordingContainer, recordedAudio*/ 480) {
			record?.on("record-end", blob => {
				$$invalidate(8, recordedAudio = URL.createObjectURL(blob));
				const microphone = microphoneContainer;
				const recording = recordingContainer;
				if (microphone) microphone.style.display = "none";

				if (recording && recordedAudio) {
					recording.innerHTML = "";
					create_recording_waveform();
				}
			});
		}
	};

	return [
		mode,
		i18n,
		waveform_options,
		handle_reset_value,
		recordingWaveform,
		recordingContainer,
		microphoneContainer,
		record,
		recordedAudio,
		timeRef,
		durationRef,
		micWaveform,
		playing,
		audioDuration,
		seconds,
		timing,
		trimDuration,
		format_time,
		handle_trim_audio,
		dispatch_blob,
		waveform_settings,
		interval,
		div0_binding,
		div1_binding,
		time_binding,
		time_binding_1,
		waveformrecordcontrols_record_binding,
		waveformcontrols_waveform_binding,
		waveformcontrols_trimDuration_binding,
		waveformcontrols_mode_binding
	];
}

class AudioRecorder extends SvelteComponent$3 {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal$3,
			{
				mode: 0,
				i18n: 1,
				dispatch_blob: 19,
				waveform_settings: 20,
				waveform_options: 2,
				handle_reset_value: 3
			},
			null,
			[-1, -1]
		);
	}
}

const StreamAudio_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/audio/streaming/StreamAudio.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$2,
	append,
	attr,
	detach: detach$2,
	element,
	init: init$2,
	insert: insert$2,
	listen,
	noop,
	null_to_empty,
	safe_not_equal: safe_not_equal$2,
	set_data,
	set_style,
	space: space$2,
	text
} = window.__gradio__svelte__internal;
const { onMount } = window.__gradio__svelte__internal;
function create_else_block$2(ctx) {
	let button;
	let span1;
	let t0;
	let t1_value = /*i18n*/ ctx[4]("audio.record") + "";
	let t1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			span1 = element("span");
			span1.innerHTML = `<span class="dot"></span>`;
			t0 = space$2();
			t1 = text(t1_value);
			attr(span1, "class", "record-icon");
			attr(button, "class", "record-button svelte-16e5vwh");
		},
		m(target, anchor) {
			insert$2(target, button, anchor);
			append(button, span1);
			append(button, t0);
			append(button, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*i18n*/ 16 && t1_value !== (t1_value = /*i18n*/ ctx[4]("audio.record") + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) {
				detach$2(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (29:1) {#if recording}
function create_if_block$2(ctx) {
	let button;
	let span2;
	let t1;

	let t2_value = (/*paused_recording*/ ctx[1]
	? /*i18n*/ ctx[4]("audio.pause")
	: /*i18n*/ ctx[4]("audio.stop")) + "";

	let t2;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			span2 = element("span");
			span2.innerHTML = `<span class="pinger"></span> <span class="dot"></span>`;
			t1 = space$2();
			t2 = text(t2_value);
			attr(span2, "class", "record-icon");

			attr(button, "class", button_class_value = "" + (null_to_empty(/*paused_recording*/ ctx[1]
			? "stop-button-paused"
			: "stop-button") + " svelte-16e5vwh"));
		},
		m(target, anchor) {
			insert$2(target, button, anchor);
			append(button, span2);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*paused_recording, i18n*/ 18 && t2_value !== (t2_value = (/*paused_recording*/ ctx[1]
			? /*i18n*/ ctx[4]("audio.pause")
			: /*i18n*/ ctx[4]("audio.stop")) + "")) set_data(t2, t2_value);

			if (dirty & /*paused_recording*/ 2 && button_class_value !== (button_class_value = "" + (null_to_empty(/*paused_recording*/ ctx[1]
			? "stop-button-paused"
			: "stop-button") + " svelte-16e5vwh"))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach$2(button);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$2(ctx) {
	let div1;
	let div0;
	let t;

	function select_block_type(ctx, dirty) {
		if (/*recording*/ ctx[0]) return create_if_block$2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space$2();
			if_block.c();
			attr(div0, "id", "microphone");
			set_style(div0, "display", /*recording*/ ctx[0] ? "block" : "none");
			attr(div1, "class", "mic-wrap svelte-16e5vwh");
		},
		m(target, anchor) {
			insert$2(target, div1, anchor);
			append(div1, div0);
			append(div1, t);
			if_block.m(div1, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*recording*/ 1) {
				set_style(div0, "display", /*recording*/ ctx[0] ? "block" : "none");
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div1, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$2(div1);
			}

			if_block.d();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { recording = false } = $$props;
	let { paused_recording = false } = $$props;
	let { stop } = $$props;
	let { record } = $$props;
	let { i18n } = $$props;
	let { waveform_settings } = $$props;
	let micWaveform;
	let waveformRecord;

	onMount(() => {
		create_mic_waveform();
	});

	const create_mic_waveform = () => {
		if (micWaveform !== undefined) micWaveform.destroy();

		micWaveform = WaveSurfer.create({
			...waveform_settings,
			height: 100,
			container: "#microphone"
		});

		$$invalidate(5, waveformRecord = micWaveform.registerPlugin(r.create()));
	};

	const click_handler = () => {
		waveformRecord.stopMic();
		stop();
	};

	const click_handler_1 = () => {
		waveformRecord.startMic();
		record();
	};

	$$self.$$set = $$props => {
		if ('recording' in $$props) $$invalidate(0, recording = $$props.recording);
		if ('paused_recording' in $$props) $$invalidate(1, paused_recording = $$props.paused_recording);
		if ('stop' in $$props) $$invalidate(2, stop = $$props.stop);
		if ('record' in $$props) $$invalidate(3, record = $$props.record);
		if ('i18n' in $$props) $$invalidate(4, i18n = $$props.i18n);
		if ('waveform_settings' in $$props) $$invalidate(6, waveform_settings = $$props.waveform_settings);
	};

	return [
		recording,
		paused_recording,
		stop,
		record,
		i18n,
		waveformRecord,
		waveform_settings,
		click_handler,
		click_handler_1
	];
}

class StreamAudio extends SvelteComponent$2 {
	constructor(options) {
		super();

		init$2(this, options, instance$2, create_fragment$2, safe_not_equal$2, {
			recording: 0,
			paused_recording: 1,
			stop: 2,
			record: 3,
			i18n: 4,
			waveform_settings: 6
		});
	}
}

const {
	SvelteComponent: SvelteComponent$1,
	add_flush_callback: add_flush_callback$1,
	bind: bind$1,
	binding_callbacks: binding_callbacks$1,
	bubble,
	check_outros: check_outros$1,
	create_component: create_component$1,
	create_slot,
	destroy_component: destroy_component$1,
	detach: detach$1,
	empty: empty$1,
	get_all_dirty_from_scope,
	get_slot_changes,
	group_outros: group_outros$1,
	init: init$1,
	insert: insert$1,
	mount_component: mount_component$1,
	safe_not_equal: safe_not_equal$1,
	space: space$1,
	transition_in: transition_in$1,
	transition_out: transition_out$1,
	update_slot_base
} = window.__gradio__svelte__internal;
const { onDestroy, createEventDispatcher } = window.__gradio__svelte__internal;
function create_else_block_1(ctx) {
	let modifyupload;
	let t;
	let audioplayer;
	let updating_mode;
	let current;

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[8], absolute: true }
		});

	modifyupload.$on("clear", /*clear*/ ctx[18]);
	modifyupload.$on("edit", /*edit_handler_1*/ ctx[29]);

	function audioplayer_mode_binding(value) {
		/*audioplayer_mode_binding*/ ctx[30](value);
	}

	let audioplayer_props = {
		value: /*value*/ ctx[1],
		label: /*label*/ ctx[3],
		i18n: /*i18n*/ ctx[8],
		dispatch_blob: /*dispatch_blob*/ ctx[16],
		waveform_settings: /*waveform_settings*/ ctx[9],
		waveform_options: /*waveform_options*/ ctx[11],
		trim_region_settings: /*trim_region_settings*/ ctx[10],
		handle_reset_value: /*handle_reset_value*/ ctx[12],
		interactive: true
	};

	if (/*mode*/ ctx[14] !== void 0) {
		audioplayer_props.mode = /*mode*/ ctx[14];
	}

	audioplayer = new AudioPlayer$1({ props: audioplayer_props });
	binding_callbacks$1.push(() => bind$1(audioplayer, 'mode', audioplayer_mode_binding));
	audioplayer.$on("stop", /*stop_handler*/ ctx[31]);
	audioplayer.$on("play", /*play_handler*/ ctx[32]);
	audioplayer.$on("pause", /*pause_handler*/ ctx[33]);
	audioplayer.$on("edit", /*edit_handler*/ ctx[34]);

	return {
		c() {
			create_component$1(modifyupload.$$.fragment);
			t = space$1();
			create_component$1(audioplayer.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(modifyupload, target, anchor);
			insert$1(target, t, anchor);
			mount_component$1(audioplayer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 256) modifyupload_changes.i18n = /*i18n*/ ctx[8];
			modifyupload.$set(modifyupload_changes);
			const audioplayer_changes = {};
			if (dirty[0] & /*value*/ 2) audioplayer_changes.value = /*value*/ ctx[1];
			if (dirty[0] & /*label*/ 8) audioplayer_changes.label = /*label*/ ctx[3];
			if (dirty[0] & /*i18n*/ 256) audioplayer_changes.i18n = /*i18n*/ ctx[8];
			if (dirty[0] & /*waveform_settings*/ 512) audioplayer_changes.waveform_settings = /*waveform_settings*/ ctx[9];
			if (dirty[0] & /*waveform_options*/ 2048) audioplayer_changes.waveform_options = /*waveform_options*/ ctx[11];
			if (dirty[0] & /*trim_region_settings*/ 1024) audioplayer_changes.trim_region_settings = /*trim_region_settings*/ ctx[10];
			if (dirty[0] & /*handle_reset_value*/ 4096) audioplayer_changes.handle_reset_value = /*handle_reset_value*/ ctx[12];

			if (!updating_mode && dirty[0] & /*mode*/ 16384) {
				updating_mode = true;
				audioplayer_changes.mode = /*mode*/ ctx[14];
				add_flush_callback$1(() => updating_mode = false);
			}

			audioplayer.$set(audioplayer_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(modifyupload.$$.fragment, local);
			transition_in$1(audioplayer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(modifyupload.$$.fragment, local);
			transition_out$1(audioplayer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
			}

			destroy_component$1(modifyupload, detaching);
			destroy_component$1(audioplayer, detaching);
		}
	};
}

// (163:0) {#if value === null || streaming}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*active_source*/ ctx[2] === "microphone") return 0;
		if (/*active_source*/ ctx[2] === "upload") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert$1(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros$1();

					transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros$1();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in$1(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block);
			current = true;
		},
		o(local) {
			transition_out$1(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (178:38) 
function create_if_block_3(ctx) {
	let upload_1;
	let updating_dragging;
	let current;

	function upload_1_dragging_binding(value) {
		/*upload_1_dragging_binding*/ ctx[27](value);
	}

	let upload_1_props = {
		filetype: "audio/aac,audio/midi,audio/mpeg,audio/ogg,audio/wav,audio/x-wav,audio/opus,audio/webm,audio/flac,audio/vnd.rn-realaudio,audio/x-ms-wma,audio/x-aiff,audio/amr,audio/*",
		root: /*root*/ ctx[4],
		include_sources: /*sources*/ ctx[6].length > 1,
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[0] !== void 0) {
		upload_1_props.dragging = /*dragging*/ ctx[0];
	}

	upload_1 = new Upload({ props: upload_1_props });
	binding_callbacks$1.push(() => bind$1(upload_1, 'dragging', upload_1_dragging_binding));
	upload_1.$on("load", /*handle_load*/ ctx[19]);
	upload_1.$on("error", /*error_handler*/ ctx[28]);

	return {
		c() {
			create_component$1(upload_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(upload_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const upload_1_changes = {};
			if (dirty[0] & /*root*/ 16) upload_1_changes.root = /*root*/ ctx[4];
			if (dirty[0] & /*sources*/ 64) upload_1_changes.include_sources = /*sources*/ ctx[6].length > 1;

			if (dirty[1] & /*$$scope*/ 32) {
				upload_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 1) {
				updating_dragging = true;
				upload_1_changes.dragging = /*dragging*/ ctx[0];
				add_flush_callback$1(() => updating_dragging = false);
			}

			upload_1.$set(upload_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(upload_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(upload_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(upload_1, detaching);
		}
	};
}

// (164:1) {#if active_source === "microphone"}
function create_if_block_1(ctx) {
	let modifyupload;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[8], absolute: true }
		});

	modifyupload.$on("clear", /*clear*/ ctx[18]);
	const if_block_creators = [create_if_block_2, create_else_block$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*streaming*/ ctx[7]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component$1(modifyupload.$$.fragment);
			t = space$1();
			if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			mount_component$1(modifyupload, target, anchor);
			insert$1(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert$1(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 256) modifyupload_changes.i18n = /*i18n*/ ctx[8];
			modifyupload.$set(modifyupload_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$1();

				transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$1();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in$1(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(modifyupload.$$.fragment, local);
			transition_in$1(if_block);
			current = true;
		},
		o(local) {
			transition_out$1(modifyupload.$$.fragment, local);
			transition_out$1(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(if_block_anchor);
			}

			destroy_component$1(modifyupload, detaching);
			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (180:2) <Upload    filetype="audio/aac,audio/midi,audio/mpeg,audio/ogg,audio/wav,audio/x-wav,audio/opus,audio/webm,audio/flac,audio/vnd.rn-realaudio,audio/x-ms-wma,audio/x-aiff,audio/amr,audio/*"    on:load={handle_load}    bind:dragging    on:error={({ detail }) => dispatch("error", detail)}    {root}    include_sources={sources.length > 1}   >
function create_default_slot$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[36], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[36],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[36])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[36], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out$1(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (168:2) {:else}
function create_else_block$1(ctx) {
	let audiorecorder;
	let updating_mode;
	let current;

	function audiorecorder_mode_binding(value) {
		/*audiorecorder_mode_binding*/ ctx[26](value);
	}

	let audiorecorder_props = {
		i18n: /*i18n*/ ctx[8],
		dispatch_blob: /*dispatch_blob*/ ctx[16],
		waveform_settings: /*waveform_settings*/ ctx[9],
		waveform_options: /*waveform_options*/ ctx[11],
		handle_reset_value: /*handle_reset_value*/ ctx[12]
	};

	if (/*mode*/ ctx[14] !== void 0) {
		audiorecorder_props.mode = /*mode*/ ctx[14];
	}

	audiorecorder = new AudioRecorder({ props: audiorecorder_props });
	binding_callbacks$1.push(() => bind$1(audiorecorder, 'mode', audiorecorder_mode_binding));

	return {
		c() {
			create_component$1(audiorecorder.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(audiorecorder, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const audiorecorder_changes = {};
			if (dirty[0] & /*i18n*/ 256) audiorecorder_changes.i18n = /*i18n*/ ctx[8];
			if (dirty[0] & /*waveform_settings*/ 512) audiorecorder_changes.waveform_settings = /*waveform_settings*/ ctx[9];
			if (dirty[0] & /*waveform_options*/ 2048) audiorecorder_changes.waveform_options = /*waveform_options*/ ctx[11];
			if (dirty[0] & /*handle_reset_value*/ 4096) audiorecorder_changes.handle_reset_value = /*handle_reset_value*/ ctx[12];

			if (!updating_mode && dirty[0] & /*mode*/ 16384) {
				updating_mode = true;
				audiorecorder_changes.mode = /*mode*/ ctx[14];
				add_flush_callback$1(() => updating_mode = false);
			}

			audiorecorder.$set(audiorecorder_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(audiorecorder.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(audiorecorder.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(audiorecorder, detaching);
		}
	};
}

// (166:2) {#if streaming}
function create_if_block_2(ctx) {
	let streamaudio;
	let current;

	streamaudio = new StreamAudio({
			props: {
				record: /*record*/ ctx[17],
				recording: /*recording*/ ctx[13],
				stop: /*stop*/ ctx[20],
				i18n: /*i18n*/ ctx[8],
				waveform_settings: /*waveform_settings*/ ctx[9]
			}
		});

	return {
		c() {
			create_component$1(streamaudio.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(streamaudio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const streamaudio_changes = {};
			if (dirty[0] & /*recording*/ 8192) streamaudio_changes.recording = /*recording*/ ctx[13];
			if (dirty[0] & /*i18n*/ 256) streamaudio_changes.i18n = /*i18n*/ ctx[8];
			if (dirty[0] & /*waveform_settings*/ 512) streamaudio_changes.waveform_settings = /*waveform_settings*/ ctx[9];
			streamaudio.$set(streamaudio_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(streamaudio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(streamaudio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(streamaudio, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let blocklabel;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let selectsource;
	let updating_active_source;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[5],
				Icon: Music,
				float: /*active_source*/ ctx[2] === "upload" && /*value*/ ctx[1] === null,
				label: /*label*/ ctx[3] || /*i18n*/ ctx[8]("audio.audio")
			}
		});

	const if_block_creators = [create_if_block$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[1] === null || /*streaming*/ ctx[7]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function selectsource_active_source_binding(value) {
		/*selectsource_active_source_binding*/ ctx[35](value);
	}

	let selectsource_props = {
		sources: /*sources*/ ctx[6],
		handle_clear: /*clear*/ ctx[18]
	};

	if (/*active_source*/ ctx[2] !== void 0) {
		selectsource_props.active_source = /*active_source*/ ctx[2];
	}

	selectsource = new SelectSource({ props: selectsource_props });
	binding_callbacks$1.push(() => bind$1(selectsource, 'active_source', selectsource_active_source_binding));

	return {
		c() {
			create_component$1(blocklabel.$$.fragment);
			t0 = space$1();
			if_block.c();
			t1 = space$1();
			create_component$1(selectsource.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(blocklabel, target, anchor);
			insert$1(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert$1(target, t1, anchor);
			mount_component$1(selectsource, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 32) blocklabel_changes.show_label = /*show_label*/ ctx[5];
			if (dirty[0] & /*active_source, value*/ 6) blocklabel_changes.float = /*active_source*/ ctx[2] === "upload" && /*value*/ ctx[1] === null;
			if (dirty[0] & /*label, i18n*/ 264) blocklabel_changes.label = /*label*/ ctx[3] || /*i18n*/ ctx[8]("audio.audio");
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$1();

				transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$1();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in$1(if_block, 1);
				if_block.m(t1.parentNode, t1);
			}

			const selectsource_changes = {};
			if (dirty[0] & /*sources*/ 64) selectsource_changes.sources = /*sources*/ ctx[6];

			if (!updating_active_source && dirty[0] & /*active_source*/ 4) {
				updating_active_source = true;
				selectsource_changes.active_source = /*active_source*/ ctx[2];
				add_flush_callback$1(() => updating_active_source = false);
			}

			selectsource.$set(selectsource_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(blocklabel.$$.fragment, local);
			transition_in$1(if_block);
			transition_in$1(selectsource.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(blocklabel.$$.fragment, local);
			transition_out$1(if_block);
			transition_out$1(selectsource.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t0);
				detach$1(t1);
			}

			destroy_component$1(blocklabel, detaching);
			if_blocks[current_block_type_index].d(detaching);
			destroy_component$1(selectsource, detaching);
		}
	};
}

const STREAM_TIMESLICE = 500;
const NUM_HEADER_BYTES = 44;

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value = null } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { show_label = true } = $$props;
	let { sources = ["microphone", "upload"] } = $$props;
	let { pending = false } = $$props;
	let { streaming = false } = $$props;
	let { i18n } = $$props;
	let { waveform_settings } = $$props;
	let { trim_region_settings = {} } = $$props;
	let { waveform_options = {} } = $$props;
	let { dragging } = $$props;
	let { active_source } = $$props;

	let { handle_reset_value = () => {
		
	} } = $$props;

	// TODO: make use of this
	// export let type: "normal" | "numpy" = "normal";
	let recording = false;

	let recorder;
	let mode = "";
	let header = undefined;
	let pending_stream = [];
	let submit_pending_stream_on_pending_end = false;
	let inited = false;
	let audio_chunks = [];
	let module_promises;

	function get_modules() {
		module_promises = [
			__vitePreload(() => import('./module-8d330bac.js'),true?["./module-8d330bac.js","./module-a4efca6e.js","./Index-2cec2c56.js","./index-5550136d.js","./index-449ec8c6.css","./Index-0d30506b.css"]:void 0,import.meta.url),
			__vitePreload(() => import('./module-698c739c.js'),true?["./module-698c739c.js","./module-a4efca6e.js"]:void 0,import.meta.url)
		];
	}

	if (streaming) {
		get_modules();
	}

	const dispatch = createEventDispatcher();

	const dispatch_blob = async (blobs, event) => {
		let _audio_blob = new File(blobs, "audio.wav");
		const val = await prepare_files([_audio_blob], event === "stream");
		$$invalidate(1, value = (await upload(val, root))?.filter(Boolean)[0]);
		dispatch(event, value);
	};

	onDestroy(() => {
		if (streaming && recorder && recorder.state !== "inactive") {
			recorder.stop();
		}
	});

	async function prepare_audio() {
		let stream;

		try {
			stream = await navigator.mediaDevices.getUserMedia({ audio: true });
		} catch(err) {
			if (!navigator.mediaDevices) {
				dispatch("error", i18n("audio.no_device_support"));
				return;
			}

			if (err instanceof DOMException && err.name == "NotAllowedError") {
				dispatch("error", i18n("audio.allow_recording_access"));
				return;
			}

			throw err;
		}

		if (stream == null) return;

		if (streaming) {
			const [{ MediaRecorder, register }, { connect }] = await Promise.all(module_promises);
			await register(await connect());
			recorder = new MediaRecorder(stream, { mimeType: "audio/wav" });
			recorder.addEventListener("dataavailable", handle_chunk);
		} else {
			recorder = new MediaRecorder(stream);

			recorder.addEventListener("dataavailable", event => {
				audio_chunks.push(event.data);
			});

			recorder.addEventListener("stop", async () => {
				$$invalidate(13, recording = false);
				await dispatch_blob(audio_chunks, "change");
				await dispatch_blob(audio_chunks, "stop_recording");
				audio_chunks = [];
			});
		}

		inited = true;
	}

	async function handle_chunk(event) {
		let buffer = await event.data.arrayBuffer();
		let payload = new Uint8Array(buffer);

		if (!header) {
			$$invalidate(22, header = new Uint8Array(buffer.slice(0, NUM_HEADER_BYTES)));
			payload = new Uint8Array(buffer.slice(NUM_HEADER_BYTES));
		}

		if (pending) {
			pending_stream.push(payload);
		} else {
			let blobParts = [header].concat(pending_stream, [payload]);
			dispatch_blob(blobParts, "stream");
			$$invalidate(23, pending_stream = []);
		}
	}

	async function record() {
		$$invalidate(13, recording = true);
		dispatch("start_recording");
		if (!inited) await prepare_audio();
		$$invalidate(22, header = undefined);

		if (streaming) {
			recorder.start(STREAM_TIMESLICE);
		}
	}

	function clear() {
		dispatch("change", null);
		dispatch("clear");
		$$invalidate(14, mode = "");
		$$invalidate(1, value = null);
	}

	function handle_load({ detail }) {
		$$invalidate(1, value = detail);
		dispatch("change", detail);
		dispatch("upload", detail);
	}

	function stop() {
		$$invalidate(13, recording = false);

		if (streaming) {
			dispatch("stop_recording");
			recorder.stop();

			if (pending) {
				$$invalidate(24, submit_pending_stream_on_pending_end = true);
			}

			dispatch_blob(audio_chunks, "stop_recording");
			dispatch("clear");
			$$invalidate(14, mode = "");
		}
	}

	function audiorecorder_mode_binding(value) {
		mode = value;
		$$invalidate(14, mode);
	}

	function upload_1_dragging_binding(value) {
		dragging = value;
		$$invalidate(0, dragging);
	}

	const error_handler = ({ detail }) => dispatch("error", detail);
	const edit_handler_1 = () => $$invalidate(14, mode = "edit");

	function audioplayer_mode_binding(value) {
		mode = value;
		$$invalidate(14, mode);
	}

	function stop_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function edit_handler(event) {
		bubble.call(this, $$self, event);
	}

	function selectsource_active_source_binding(value) {
		active_source = value;
		$$invalidate(2, active_source);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('root' in $$props) $$invalidate(4, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(5, show_label = $$props.show_label);
		if ('sources' in $$props) $$invalidate(6, sources = $$props.sources);
		if ('pending' in $$props) $$invalidate(21, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(7, streaming = $$props.streaming);
		if ('i18n' in $$props) $$invalidate(8, i18n = $$props.i18n);
		if ('waveform_settings' in $$props) $$invalidate(9, waveform_settings = $$props.waveform_settings);
		if ('trim_region_settings' in $$props) $$invalidate(10, trim_region_settings = $$props.trim_region_settings);
		if ('waveform_options' in $$props) $$invalidate(11, waveform_options = $$props.waveform_options);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('active_source' in $$props) $$invalidate(2, active_source = $$props.active_source);
		if ('handle_reset_value' in $$props) $$invalidate(12, handle_reset_value = $$props.handle_reset_value);
		if ('$$scope' in $$props) $$invalidate(36, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*dragging*/ 1) {
			dispatch("drag", dragging);
		}

		if ($$self.$$.dirty[0] & /*submit_pending_stream_on_pending_end, pending, header, pending_stream*/ 31457280) {
			if (submit_pending_stream_on_pending_end && pending === false) {
				$$invalidate(24, submit_pending_stream_on_pending_end = false);

				if (header && pending_stream) {
					let blobParts = [header].concat(pending_stream);
					$$invalidate(23, pending_stream = []);
					dispatch_blob(blobParts, "stream");
				}
			}
		}
	};

	return [
		dragging,
		value,
		active_source,
		label,
		root,
		show_label,
		sources,
		streaming,
		i18n,
		waveform_settings,
		trim_region_settings,
		waveform_options,
		handle_reset_value,
		recording,
		mode,
		dispatch,
		dispatch_blob,
		record,
		clear,
		handle_load,
		stop,
		pending,
		header,
		pending_stream,
		submit_pending_stream_on_pending_end,
		slots,
		audiorecorder_mode_binding,
		upload_1_dragging_binding,
		error_handler,
		edit_handler_1,
		audioplayer_mode_binding,
		stop_handler,
		play_handler,
		pause_handler,
		edit_handler,
		selectsource_active_source_binding,
		$$scope
	];
}

class InteractiveAudio extends SvelteComponent$1 {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal$1,
			{
				value: 1,
				label: 3,
				root: 4,
				show_label: 5,
				sources: 6,
				pending: 21,
				streaming: 7,
				i18n: 8,
				waveform_settings: 9,
				trim_region_settings: 10,
				waveform_options: 11,
				dragging: 0,
				active_source: 2,
				handle_reset_value: 12
			},
			null,
			[-1, -1]
		);
	}
}

const InteractiveAudio$1 = InteractiveAudio;

/* home/runner/work/gradio/gradio/js/audio/Index.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	add_flush_callback,
	assign,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	empty,
	flush,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} = window.__gradio__svelte__internal;
function create_else_block(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				variant: /*value*/ ctx[0] === null && /*active_source*/ ctx[20] === "upload"
				? "dashed"
				: "solid",
				border_mode: /*dragging*/ ctx[21] ? "focus" : "base",
				padding: false,
				elem_id: /*elem_id*/ ctx[2],
				elem_classes: /*elem_classes*/ ctx[3],
				visible: /*visible*/ ctx[4],
				container: /*container*/ ctx[10],
				scale: /*scale*/ ctx[11],
				min_width: /*min_width*/ ctx[12],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};

			if (dirty[0] & /*value, active_source*/ 1048577) block_changes.variant = /*value*/ ctx[0] === null && /*active_source*/ ctx[20] === "upload"
			? "dashed"
			: "solid";

			if (dirty[0] & /*dragging*/ 2097152) block_changes.border_mode = /*dragging*/ ctx[21] ? "focus" : "base";
			if (dirty[0] & /*elem_id*/ 4) block_changes.elem_id = /*elem_id*/ ctx[2];
			if (dirty[0] & /*elem_classes*/ 8) block_changes.elem_classes = /*elem_classes*/ ctx[3];
			if (dirty[0] & /*visible*/ 16) block_changes.visible = /*visible*/ ctx[4];
			if (dirty[0] & /*container*/ 1024) block_changes.container = /*container*/ ctx[10];
			if (dirty[0] & /*scale*/ 2048) block_changes.scale = /*scale*/ ctx[11];
			if (dirty[0] & /*min_width*/ 4096) block_changes.min_width = /*min_width*/ ctx[12];

			if (dirty[0] & /*label, show_label, _value, root, sources, active_source, pending, streaming, gradio, waveform_settings, waveform_options, dragging, value, loading_status*/ 8356803 | dirty[1] & /*$$scope*/ 131072) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

// (85:0) {#if !interactive}
function create_if_block(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				variant: "solid",
				border_mode: /*dragging*/ ctx[21] ? "focus" : "base",
				padding: false,
				elem_id: /*elem_id*/ ctx[2],
				elem_classes: /*elem_classes*/ ctx[3],
				visible: /*visible*/ ctx[4],
				container: /*container*/ ctx[10],
				scale: /*scale*/ ctx[11],
				min_width: /*min_width*/ ctx[12],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};
			if (dirty[0] & /*dragging*/ 2097152) block_changes.border_mode = /*dragging*/ ctx[21] ? "focus" : "base";
			if (dirty[0] & /*elem_id*/ 4) block_changes.elem_id = /*elem_id*/ ctx[2];
			if (dirty[0] & /*elem_classes*/ 8) block_changes.elem_classes = /*elem_classes*/ ctx[3];
			if (dirty[0] & /*visible*/ 16) block_changes.visible = /*visible*/ ctx[4];
			if (dirty[0] & /*container*/ 1024) block_changes.container = /*container*/ ctx[10];
			if (dirty[0] & /*scale*/ 2048) block_changes.scale = /*scale*/ ctx[11];
			if (dirty[0] & /*min_width*/ 4096) block_changes.min_width = /*min_width*/ ctx[12];

			if (dirty[0] & /*gradio, show_label, show_download_button, show_share_button, _value, label, waveform_settings, waveform_options, loading_status*/ 5038722 | dirty[1] & /*$$scope*/ 131072) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

// (136:2) <InteractiveAudio    {label}    {show_label}    value={_value}    on:change={({ detail }) => (value = detail)}    on:stream={({ detail }) => {     value = detail;     gradio.dispatch("stream", value);    }}    on:drag={({ detail }) => (dragging = detail)}    {root}    {sources}    {active_source}    {pending}    {streaming}    {handle_reset_value}    bind:dragging    on:edit={() => gradio.dispatch("edit")}    on:play={() => gradio.dispatch("play")}    on:pause={() => gradio.dispatch("pause")}    on:stop={() => gradio.dispatch("stop")}    on:start_recording={() => gradio.dispatch("start_recording")}    on:pause_recording={() => gradio.dispatch("pause_recording")}    on:stop_recording={(e) => gradio.dispatch("stop_recording", e.detail)}    on:upload={() => gradio.dispatch("upload")}    on:clear={() => gradio.dispatch("clear")}    on:error={handle_error}    i18n={gradio.i18n}    {waveform_settings}    {waveform_options}    {trim_region_settings}   >
function create_default_slot_2(ctx) {
	let uploadtext;
	let current;

	uploadtext = new UploadText({
			props: {
				i18n: /*gradio*/ ctx[18].i18n,
				type: "audio"
			}
		});

	return {
		c() {
			create_component(uploadtext.$$.fragment);
		},
		m(target, anchor) {
			mount_component(uploadtext, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const uploadtext_changes = {};
			if (dirty[0] & /*gradio*/ 262144) uploadtext_changes.i18n = /*gradio*/ ctx[18].i18n;
			uploadtext.$set(uploadtext_changes);
		},
		i(local) {
			if (current) return;
			transition_in(uploadtext.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(uploadtext.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(uploadtext, detaching);
		}
	};
}

// (120:1) <Block   variant={value === null && active_source === "upload" ? "dashed" : "solid"}   border_mode={dragging ? "focus" : "base"}   padding={false}   {elem_id}   {elem_classes}   {visible}   {container}   {scale}   {min_width}  >
function create_default_slot_1(ctx) {
	let statustracker;
	let t;
	let interactiveaudio;
	let updating_dragging;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[18].autoscroll
		},
		{ i18n: /*gradio*/ ctx[18].i18n },
		/*loading_status*/ ctx[1]
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({ props: statustracker_props });

	function interactiveaudio_dragging_binding(value) {
		/*interactiveaudio_dragging_binding*/ ctx[35](value);
	}

	let interactiveaudio_props = {
		label: /*label*/ ctx[7],
		show_label: /*show_label*/ ctx[9],
		value: /*_value*/ ctx[19],
		root: /*root*/ ctx[8],
		sources: /*sources*/ ctx[6],
		active_source: /*active_source*/ ctx[20],
		pending: /*pending*/ ctx[16],
		streaming: /*streaming*/ ctx[17],
		handle_reset_value: /*handle_reset_value*/ ctx[23],
		i18n: /*gradio*/ ctx[18].i18n,
		waveform_settings: /*waveform_settings*/ ctx[22],
		waveform_options: /*waveform_options*/ ctx[15],
		trim_region_settings: /*trim_region_settings*/ ctx[24],
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[21] !== void 0) {
		interactiveaudio_props.dragging = /*dragging*/ ctx[21];
	}

	interactiveaudio = new InteractiveAudio$1({ props: interactiveaudio_props });
	binding_callbacks.push(() => bind(interactiveaudio, 'dragging', interactiveaudio_dragging_binding));
	interactiveaudio.$on("change", /*change_handler*/ ctx[36]);
	interactiveaudio.$on("stream", /*stream_handler*/ ctx[37]);
	interactiveaudio.$on("drag", /*drag_handler*/ ctx[38]);
	interactiveaudio.$on("edit", /*edit_handler*/ ctx[39]);
	interactiveaudio.$on("play", /*play_handler_1*/ ctx[40]);
	interactiveaudio.$on("pause", /*pause_handler_1*/ ctx[41]);
	interactiveaudio.$on("stop", /*stop_handler_1*/ ctx[42]);
	interactiveaudio.$on("start_recording", /*start_recording_handler*/ ctx[43]);
	interactiveaudio.$on("pause_recording", /*pause_recording_handler*/ ctx[44]);
	interactiveaudio.$on("stop_recording", /*stop_recording_handler*/ ctx[45]);
	interactiveaudio.$on("upload", /*upload_handler*/ ctx[46]);
	interactiveaudio.$on("clear", /*clear_handler*/ ctx[47]);
	interactiveaudio.$on("error", /*handle_error*/ ctx[25]);

	return {
		c() {
			create_component(statustracker.$$.fragment);
			t = space();
			create_component(interactiveaudio.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert(target, t, anchor);
			mount_component(interactiveaudio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 262146)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 262144 && {
						autoscroll: /*gradio*/ ctx[18].autoscroll
					},
					dirty[0] & /*gradio*/ 262144 && { i18n: /*gradio*/ ctx[18].i18n },
					dirty[0] & /*loading_status*/ 2 && get_spread_object(/*loading_status*/ ctx[1])
				])
			: {};

			statustracker.$set(statustracker_changes);
			const interactiveaudio_changes = {};
			if (dirty[0] & /*label*/ 128) interactiveaudio_changes.label = /*label*/ ctx[7];
			if (dirty[0] & /*show_label*/ 512) interactiveaudio_changes.show_label = /*show_label*/ ctx[9];
			if (dirty[0] & /*_value*/ 524288) interactiveaudio_changes.value = /*_value*/ ctx[19];
			if (dirty[0] & /*root*/ 256) interactiveaudio_changes.root = /*root*/ ctx[8];
			if (dirty[0] & /*sources*/ 64) interactiveaudio_changes.sources = /*sources*/ ctx[6];
			if (dirty[0] & /*active_source*/ 1048576) interactiveaudio_changes.active_source = /*active_source*/ ctx[20];
			if (dirty[0] & /*pending*/ 65536) interactiveaudio_changes.pending = /*pending*/ ctx[16];
			if (dirty[0] & /*streaming*/ 131072) interactiveaudio_changes.streaming = /*streaming*/ ctx[17];
			if (dirty[0] & /*gradio*/ 262144) interactiveaudio_changes.i18n = /*gradio*/ ctx[18].i18n;
			if (dirty[0] & /*waveform_settings*/ 4194304) interactiveaudio_changes.waveform_settings = /*waveform_settings*/ ctx[22];
			if (dirty[0] & /*waveform_options*/ 32768) interactiveaudio_changes.waveform_options = /*waveform_options*/ ctx[15];

			if (dirty[0] & /*gradio*/ 262144 | dirty[1] & /*$$scope*/ 131072) {
				interactiveaudio_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 2097152) {
				updating_dragging = true;
				interactiveaudio_changes.dragging = /*dragging*/ ctx[21];
				add_flush_callback(() => updating_dragging = false);
			}

			interactiveaudio.$set(interactiveaudio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(interactiveaudio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(interactiveaudio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_component(statustracker, detaching);
			destroy_component(interactiveaudio, detaching);
		}
	};
}

// (86:1) <Block   variant={"solid"}   border_mode={dragging ? "focus" : "base"}   padding={false}   {elem_id}   {elem_classes}   {visible}   {container}   {scale}   {min_width}  >
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let staticaudio;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[18].autoscroll
		},
		{ i18n: /*gradio*/ ctx[18].i18n },
		/*loading_status*/ ctx[1]
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({ props: statustracker_props });

	staticaudio = new StaticAudio$1({
			props: {
				i18n: /*gradio*/ ctx[18].i18n,
				show_label: /*show_label*/ ctx[9],
				show_download_button: /*show_download_button*/ ctx[13],
				show_share_button: /*show_share_button*/ ctx[14],
				value: /*_value*/ ctx[19],
				label: /*label*/ ctx[7],
				waveform_settings: /*waveform_settings*/ ctx[22],
				waveform_options: /*waveform_options*/ ctx[15]
			}
		});

	staticaudio.$on("share", /*share_handler*/ ctx[30]);
	staticaudio.$on("error", /*error_handler*/ ctx[31]);
	staticaudio.$on("play", /*play_handler*/ ctx[32]);
	staticaudio.$on("pause", /*pause_handler*/ ctx[33]);
	staticaudio.$on("stop", /*stop_handler*/ ctx[34]);

	return {
		c() {
			create_component(statustracker.$$.fragment);
			t = space();
			create_component(staticaudio.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert(target, t, anchor);
			mount_component(staticaudio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 262146)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 262144 && {
						autoscroll: /*gradio*/ ctx[18].autoscroll
					},
					dirty[0] & /*gradio*/ 262144 && { i18n: /*gradio*/ ctx[18].i18n },
					dirty[0] & /*loading_status*/ 2 && get_spread_object(/*loading_status*/ ctx[1])
				])
			: {};

			statustracker.$set(statustracker_changes);
			const staticaudio_changes = {};
			if (dirty[0] & /*gradio*/ 262144) staticaudio_changes.i18n = /*gradio*/ ctx[18].i18n;
			if (dirty[0] & /*show_label*/ 512) staticaudio_changes.show_label = /*show_label*/ ctx[9];
			if (dirty[0] & /*show_download_button*/ 8192) staticaudio_changes.show_download_button = /*show_download_button*/ ctx[13];
			if (dirty[0] & /*show_share_button*/ 16384) staticaudio_changes.show_share_button = /*show_share_button*/ ctx[14];
			if (dirty[0] & /*_value*/ 524288) staticaudio_changes.value = /*_value*/ ctx[19];
			if (dirty[0] & /*label*/ 128) staticaudio_changes.label = /*label*/ ctx[7];
			if (dirty[0] & /*waveform_settings*/ 4194304) staticaudio_changes.waveform_settings = /*waveform_settings*/ ctx[22];
			if (dirty[0] & /*waveform_options*/ 32768) staticaudio_changes.waveform_options = /*waveform_options*/ ctx[15];
			staticaudio.$set(staticaudio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(staticaudio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(staticaudio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_component(statustracker, detaching);
			destroy_component(staticaudio, detaching);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*interactive*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { interactive } = $$props;
	let { value = null } = $$props;
	let { sources } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { show_label } = $$props;
	let { proxy_url } = $$props;
	let { container = true } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { loading_status } = $$props;
	let { autoplay = false } = $$props;
	let { show_download_button = true } = $$props;
	let { show_share_button = false } = $$props;
	let { waveform_options = {} } = $$props;
	let { pending } = $$props;
	let { streaming } = $$props;
	let { gradio } = $$props;
	let old_value = null;
	let _value;
	let active_source;
	let initial_value = value;

	const handle_reset_value = () => {
		if (initial_value === null || value === initial_value) {
			return;
		}

		$$invalidate(0, value = initial_value);
	};

	let dragging;
	let waveform_settings;

	const trim_region_settings = {
		color: waveform_options.trim_region_color || "hsla(15, 85%, 40%, 0.4)",
		drag: true,
		resize: true
	};

	function handle_error({ detail }) {
		const [level, status] = detail.includes("Invalid file type")
		? ["warning", "complete"]
		: ["error", "error"];

		$$invalidate(1, loading_status = loading_status || {});
		$$invalidate(1, loading_status.status = status, loading_status);
		$$invalidate(1, loading_status.message = detail, loading_status);
		gradio.dispatch(level, detail);
	}

	const share_handler = e => gradio.dispatch("share", e.detail);
	const error_handler = e => gradio.dispatch("error", e.detail);
	const play_handler = () => gradio.dispatch("play");
	const pause_handler = () => gradio.dispatch("pause");
	const stop_handler = () => gradio.dispatch("stop");

	function interactiveaudio_dragging_binding(value) {
		dragging = value;
		$$invalidate(21, dragging);
	}

	const change_handler = ({ detail }) => $$invalidate(0, value = detail);

	const stream_handler = ({ detail }) => {
		$$invalidate(0, value = detail);
		gradio.dispatch("stream", value);
	};

	const drag_handler = ({ detail }) => $$invalidate(21, dragging = detail);
	const edit_handler = () => gradio.dispatch("edit");
	const play_handler_1 = () => gradio.dispatch("play");
	const pause_handler_1 = () => gradio.dispatch("pause");
	const stop_handler_1 = () => gradio.dispatch("stop");
	const start_recording_handler = () => gradio.dispatch("start_recording");
	const pause_recording_handler = () => gradio.dispatch("pause_recording");
	const stop_recording_handler = e => gradio.dispatch("stop_recording", e.detail);
	const upload_handler = () => gradio.dispatch("upload");
	const clear_handler = () => gradio.dispatch("clear");

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(3, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
		if ('interactive' in $$props) $$invalidate(5, interactive = $$props.interactive);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('sources' in $$props) $$invalidate(6, sources = $$props.sources);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('root' in $$props) $$invalidate(8, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(9, show_label = $$props.show_label);
		if ('proxy_url' in $$props) $$invalidate(26, proxy_url = $$props.proxy_url);
		if ('container' in $$props) $$invalidate(10, container = $$props.container);
		if ('scale' in $$props) $$invalidate(11, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(12, min_width = $$props.min_width);
		if ('loading_status' in $$props) $$invalidate(1, loading_status = $$props.loading_status);
		if ('autoplay' in $$props) $$invalidate(27, autoplay = $$props.autoplay);
		if ('show_download_button' in $$props) $$invalidate(13, show_download_button = $$props.show_download_button);
		if ('show_share_button' in $$props) $$invalidate(14, show_share_button = $$props.show_share_button);
		if ('waveform_options' in $$props) $$invalidate(15, waveform_options = $$props.waveform_options);
		if ('pending' in $$props) $$invalidate(16, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(17, streaming = $$props.streaming);
		if ('gradio' in $$props) $$invalidate(18, gradio = $$props.gradio);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, root, proxy_url*/ 67109121) {
			$$invalidate(19, _value = normalise_file(value, root, proxy_url));
		}

		if ($$self.$$.dirty[0] & /*value, initial_value*/ 536870913) {
			if (value && initial_value === null) {
				$$invalidate(29, initial_value = value);
			}
		}

		if ($$self.$$.dirty[0] & /*value, old_value, gradio*/ 268697601) {
			{
				if (JSON.stringify(value) !== JSON.stringify(old_value)) {
					$$invalidate(28, old_value = value);
					gradio.dispatch("change");
				}
			}
		}

		if ($$self.$$.dirty[0] & /*sources*/ 64) {
			if (sources) {
				$$invalidate(20, active_source = sources[0]);
			}
		}

		if ($$self.$$.dirty[0] & /*waveform_options, autoplay*/ 134250496) {
			$$invalidate(22, waveform_settings = {
				height: 50,
				waveColor: waveform_options.waveform_color || "#9ca3af",
				progressColor: waveform_options.waveform_progress_color || "#f97316",
				barWidth: 2,
				barGap: 3,
				cursorWidth: 2,
				cursorColor: "#ddd5e9",
				autoplay,
				barRadius: 10,
				dragToSeek: true,
				normalize: true,
				minPxPerSec: 20,
				mediaControls: waveform_options.show_controls
			});
		}
	};

	return [
		value,
		loading_status,
		elem_id,
		elem_classes,
		visible,
		interactive,
		sources,
		label,
		root,
		show_label,
		container,
		scale,
		min_width,
		show_download_button,
		show_share_button,
		waveform_options,
		pending,
		streaming,
		gradio,
		_value,
		active_source,
		dragging,
		waveform_settings,
		handle_reset_value,
		trim_region_settings,
		handle_error,
		proxy_url,
		autoplay,
		old_value,
		initial_value,
		share_handler,
		error_handler,
		play_handler,
		pause_handler,
		stop_handler,
		interactiveaudio_dragging_binding,
		change_handler,
		stream_handler,
		drag_handler,
		edit_handler,
		play_handler_1,
		pause_handler_1,
		stop_handler_1,
		start_recording_handler,
		pause_recording_handler,
		stop_recording_handler,
		upload_handler,
		clear_handler
	];
}

class Index extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				elem_id: 2,
				elem_classes: 3,
				visible: 4,
				interactive: 5,
				value: 0,
				sources: 6,
				label: 7,
				root: 8,
				show_label: 9,
				proxy_url: 26,
				container: 10,
				scale: 11,
				min_width: 12,
				loading_status: 1,
				autoplay: 27,
				show_download_button: 13,
				show_share_button: 14,
				waveform_options: 15,
				pending: 16,
				streaming: 17,
				gradio: 18
			},
			null,
			[-1, -1]
		);
	}

	get elem_id() {
		return this.$$.ctx[2];
	}

	set elem_id(elem_id) {
		this.$$set({ elem_id });
		flush();
	}

	get elem_classes() {
		return this.$$.ctx[3];
	}

	set elem_classes(elem_classes) {
		this.$$set({ elem_classes });
		flush();
	}

	get visible() {
		return this.$$.ctx[4];
	}

	set visible(visible) {
		this.$$set({ visible });
		flush();
	}

	get interactive() {
		return this.$$.ctx[5];
	}

	set interactive(interactive) {
		this.$$set({ interactive });
		flush();
	}

	get value() {
		return this.$$.ctx[0];
	}

	set value(value) {
		this.$$set({ value });
		flush();
	}

	get sources() {
		return this.$$.ctx[6];
	}

	set sources(sources) {
		this.$$set({ sources });
		flush();
	}

	get label() {
		return this.$$.ctx[7];
	}

	set label(label) {
		this.$$set({ label });
		flush();
	}

	get root() {
		return this.$$.ctx[8];
	}

	set root(root) {
		this.$$set({ root });
		flush();
	}

	get show_label() {
		return this.$$.ctx[9];
	}

	set show_label(show_label) {
		this.$$set({ show_label });
		flush();
	}

	get proxy_url() {
		return this.$$.ctx[26];
	}

	set proxy_url(proxy_url) {
		this.$$set({ proxy_url });
		flush();
	}

	get container() {
		return this.$$.ctx[10];
	}

	set container(container) {
		this.$$set({ container });
		flush();
	}

	get scale() {
		return this.$$.ctx[11];
	}

	set scale(scale) {
		this.$$set({ scale });
		flush();
	}

	get min_width() {
		return this.$$.ctx[12];
	}

	set min_width(min_width) {
		this.$$set({ min_width });
		flush();
	}

	get loading_status() {
		return this.$$.ctx[1];
	}

	set loading_status(loading_status) {
		this.$$set({ loading_status });
		flush();
	}

	get autoplay() {
		return this.$$.ctx[27];
	}

	set autoplay(autoplay) {
		this.$$set({ autoplay });
		flush();
	}

	get show_download_button() {
		return this.$$.ctx[13];
	}

	set show_download_button(show_download_button) {
		this.$$set({ show_download_button });
		flush();
	}

	get show_share_button() {
		return this.$$.ctx[14];
	}

	set show_share_button(show_share_button) {
		this.$$set({ show_share_button });
		flush();
	}

	get waveform_options() {
		return this.$$.ctx[15];
	}

	set waveform_options(waveform_options) {
		this.$$set({ waveform_options });
		flush();
	}

	get pending() {
		return this.$$.ctx[16];
	}

	set pending(pending) {
		this.$$set({ pending });
		flush();
	}

	get streaming() {
		return this.$$.ctx[17];
	}

	set streaming(streaming) {
		this.$$set({ streaming });
		flush();
	}

	get gradio() {
		return this.$$.ctx[18];
	}

	set gradio(gradio) {
		this.$$set({ gradio });
		flush();
	}
}

const Index$1 = Index;

export { InteractiveAudio$1 as BaseInteractiveAudio, AudioPlayer$1 as BasePlayer, StaticAudio$1 as BaseStaticAudio, Index$1 as default };
//# sourceMappingURL=index-457eb9c1.js.map
